(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
    new MutationObserver(i => {
        for (const s of i)
            if (s.type === "childList")
                for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function n(i) {
        const s = {};
        return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s
    }

    function r(i) {
        if (i.ep) return;
        i.ep = !0;
        const s = n(i);
        fetch(i.href, s)
    }
})();

function Gh(t, e) {
    const n = Object.create(null),
        r = t.split(",");
    for (let i = 0; i < r.length; i++) n[r[i]] = !0;
    return e ? i => !!n[i.toLowerCase()] : i => !!n[i]
}
const wt = {},
    go = [],
    Er = () => {},
    JA = () => !1,
    KA = /^on[^a-z]/,
    xu = t => KA.test(t),
    Wh = t => t.startsWith("onUpdate:"),
    Jt = Object.assign,
    Qh = (t, e) => {
        const n = t.indexOf(e);
        n > -1 && t.splice(n, 1)
    },
    ZA = Object.prototype.hasOwnProperty,
    ot = (t, e) => ZA.call(t, e),
    Me = Array.isArray,
    yo = t => ml(t) === "[object Map]",
    Au = t => ml(t) === "[object Set]",
    Lm = t => ml(t) === "[object Date]",
    We = t => typeof t == "function",
    zt = t => typeof t == "string",
    Po = t => typeof t == "symbol",
    gt = t => t !== null && typeof t == "object",
    Uy = t => (gt(t) || We(t)) && We(t.then) && We(t.catch),
    Hy = Object.prototype.toString,
    ml = t => Hy.call(t),
    YA = t => ml(t).slice(8, -1),
    zy = t => ml(t) === "[object Object]",
    Jh = t => zt(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t,
    Rc = Gh(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    ku = t => {
        const e = Object.create(null);
        return n => e[n] || (e[n] = t(n))
    },
    XA = /-(\w)/g,
    Br = ku(t => t.replace(XA, (e, n) => n ? n.toUpperCase() : "")),
    qA = /\B([A-Z])/g,
    Fs = ku(t => t.replace(qA, "-$1").toLowerCase()),
    _u = ku(t => t.charAt(0).toUpperCase() + t.slice(1)),
    kf = ku(t => t ? `on${_u(t)}` : ""),
    Ss = (t, e) => !Object.is(t, e),
    Cc = (t, e) => {
        for (let n = 0; n < t.length; n++) t[n](e)
    },
    Wc = (t, e, n) => {
        Object.defineProperty(t, e, {
            configurable: !0,
            enumerable: !1,
            value: n
        })
    },
    jy = t => {
        const e = parseFloat(t);
        return isNaN(e) ? t : e
    },
    $A = t => {
        const e = zt(t) ? Number(t) : NaN;
        return isNaN(e) ? t : e
    };
let Mm;
const Rd = () => Mm || (Mm = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

function Eu(t) {
    if (Me(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const r = t[n],
                i = zt(r) ? rk(r) : Eu(r);
            if (i)
                for (const s in i) e[s] = i[s]
        }
        return e
    } else if (zt(t) || gt(t)) return t
}
const ek = /;(?![^(]*\))/g,
    tk = /:([^]+)/,
    nk = /\/\*[^]*?\*\//g;

function rk(t) {
    const e = {};
    return t.replace(nk, "").split(ek).forEach(n => {
        if (n) {
            const r = n.split(tk);
            r.length > 1 && (e[r[0].trim()] = r[1].trim())
        }
    }), e
}

function Rt(t) {
    let e = "";
    if (zt(t)) e = t;
    else if (Me(t))
        for (let n = 0; n < t.length; n++) {
            const r = Rt(t[n]);
            r && (e += r + " ")
        } else if (gt(t))
            for (const n in t) t[n] && (e += n + " ");
    return e.trim()
}
const ik = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    sk = Gh(ik);

function Vy(t) {
    return !!t || t === ""
}

function ok(t, e) {
    if (t.length !== e.length) return !1;
    let n = !0;
    for (let r = 0; n && r < t.length; r++) n = Pu(t[r], e[r]);
    return n
}

function Pu(t, e) {
    if (t === e) return !0;
    let n = Lm(t),
        r = Lm(e);
    if (n || r) return n && r ? t.getTime() === e.getTime() : !1;
    if (n = Po(t), r = Po(e), n || r) return t === e;
    if (n = Me(t), r = Me(e), n || r) return n && r ? ok(t, e) : !1;
    if (n = gt(t), r = gt(e), n || r) {
        if (!n || !r) return !1;
        const i = Object.keys(t).length,
            s = Object.keys(e).length;
        if (i !== s) return !1;
        for (const o in t) {
            const a = t.hasOwnProperty(o),
                c = e.hasOwnProperty(o);
            if (a && !c || !a && c || !Pu(t[o], e[o])) return !1
        }
    }
    return String(t) === String(e)
}

function ak(t, e) {
    return t.findIndex(n => Pu(n, e))
}
const ue = t => zt(t) ? t : t == null ? "" : Me(t) || gt(t) && (t.toString === Hy || !We(t.toString)) ? JSON.stringify(t, Gy, 2) : String(t),
    Gy = (t, e) => e && e.__v_isRef ? Gy(t, e.value) : yo(e) ? {
        [`Map(${e.size})`]: [...e.entries()].reduce((n, [r, i]) => (n[`${r} =>`] = i, n), {})
    } : Au(e) ? {
        [`Set(${e.size})`]: [...e.values()]
    } : gt(e) && !Me(e) && !zy(e) ? String(e) : e;
let On;
class lk {
    constructor(e = !1) {
        this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = On, !e && On && (this.index = (On.scopes || (On.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(e) {
        if (this._active) {
            const n = On;
            try {
                return On = this, e()
            } finally {
                On = n
            }
        }
    }
    on() {
        On = this
    }
    off() {
        On = this.parent
    }
    stop(e) {
        if (this._active) {
            let n, r;
            for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop();
            for (n = 0, r = this.cleanups.length; n < r; n++) this.cleanups[n]();
            if (this.scopes)
                for (n = 0, r = this.scopes.length; n < r; n++) this.scopes[n].stop(!0);
            if (!this.detached && this.parent && !e) {
                const i = this.parent.scopes.pop();
                i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index)
            }
            this.parent = void 0, this._active = !1
        }
    }
}

function ck(t, e = On) {
    e && e.active && e.effects.push(t)
}

function Wy() {
    return On
}

function uk(t) {
    On && On.cleanups.push(t)
}
const Kh = t => {
        const e = new Set(t);
        return e.w = 0, e.n = 0, e
    },
    Qy = t => (t.w & ji) > 0,
    Jy = t => (t.n & ji) > 0,
    fk = ({
        deps: t
    }) => {
        if (t.length)
            for (let e = 0; e < t.length; e++) t[e].w |= ji
    },
    dk = t => {
        const {
            deps: e
        } = t;
        if (e.length) {
            let n = 0;
            for (let r = 0; r < e.length; r++) {
                const i = e[r];
                Qy(i) && !Jy(i) ? i.delete(t) : e[n++] = i, i.w &= ~ji, i.n &= ~ji
            }
            e.length = n
        }
    },
    Qc = new WeakMap;
let ha = 0,
    ji = 1;
const Cd = 30;
let sr;
const As = Symbol(""),
    Od = Symbol("");
class Zh {
    constructor(e, n = null, r) {
        this.fn = e, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, ck(this, r)
    }
    run() {
        if (!this.active) return this.fn();
        let e = sr,
            n = Ii;
        for (; e;) {
            if (e === this) return;
            e = e.parent
        }
        try {
            return this.parent = sr, sr = this, Ii = !0, ji = 1 << ++ha, ha <= Cd ? fk(this) : Fm(this), this.fn()
        } finally {
            ha <= Cd && dk(this), ji = 1 << --ha, sr = this.parent, Ii = n, this.parent = void 0, this.deferStop && this.stop()
        }
    }
    stop() {
        sr === this ? this.deferStop = !0 : this.active && (Fm(this), this.onStop && this.onStop(), this.active = !1)
    }
}

function Fm(t) {
    const {
        deps: e
    } = t;
    if (e.length) {
        for (let n = 0; n < e.length; n++) e[n].delete(t);
        e.length = 0
    }
}
let Ii = !0;
const Ky = [];

function Qo() {
    Ky.push(Ii), Ii = !1
}

function Jo() {
    const t = Ky.pop();
    Ii = t === void 0 ? !0 : t
}

function Pn(t, e, n) {
    if (Ii && sr) {
        let r = Qc.get(t);
        r || Qc.set(t, r = new Map);
        let i = r.get(n);
        i || r.set(n, i = Kh()), Zy(i)
    }
}

function Zy(t, e) {
    let n = !1;
    ha <= Cd ? Jy(t) || (t.n |= ji, n = !Qy(t)) : n = !t.has(sr), n && (t.add(sr), sr.deps.push(t))
}

function ei(t, e, n, r, i, s) {
    const o = Qc.get(t);
    if (!o) return;
    let a = [];
    if (e === "clear") a = [...o.values()];
    else if (n === "length" && Me(t)) {
        const c = Number(r);
        o.forEach((l, u) => {
            (u === "length" || !Po(u) && u >= c) && a.push(l)
        })
    } else switch (n !== void 0 && a.push(o.get(n)), e) {
        case "add":
            Me(t) ? Jh(n) && a.push(o.get("length")) : (a.push(o.get(As)), yo(t) && a.push(o.get(Od)));
            break;
        case "delete":
            Me(t) || (a.push(o.get(As)), yo(t) && a.push(o.get(Od)));
            break;
        case "set":
            yo(t) && a.push(o.get(As));
            break
    }
    if (a.length === 1) a[0] && Td(a[0]);
    else {
        const c = [];
        for (const l of a) l && c.push(...l);
        Td(Kh(c))
    }
}

function Td(t, e) {
    const n = Me(t) ? t : [...t];
    for (const r of n) r.computed && Um(r);
    for (const r of n) r.computed || Um(r)
}

function Um(t, e) {
    (t !== sr || t.allowRecurse) && (t.scheduler ? t.scheduler() : t.run())
}

function hk(t, e) {
    var n;
    return (n = Qc.get(t)) == null ? void 0 : n.get(e)
}
const pk = Gh("__proto__,__v_isRef,__isVue"),
    Yy = new Set(Object.getOwnPropertyNames(Symbol).filter(t => t !== "arguments" && t !== "caller").map(t => Symbol[t]).filter(Po)),
    Hm = mk();

function mk() {
    const t = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(e => {
        t[e] = function(...n) {
            const r = at(this);
            for (let s = 0, o = this.length; s < o; s++) Pn(r, "get", s + "");
            const i = r[e](...n);
            return i === -1 || i === !1 ? r[e](...n.map(at)) : i
        }
    }), ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
        t[e] = function(...n) {
            Qo();
            const r = at(this)[e].apply(this, n);
            return Jo(), r
        }
    }), t
}

function gk(t) {
    const e = at(this);
    return Pn(e, "has", t), e.hasOwnProperty(t)
}
class Xy {
    constructor(e = !1, n = !1) {
        this._isReadonly = e, this._shallow = n
    }
    get(e, n, r) {
        const i = this._isReadonly,
            s = this._shallow;
        if (n === "__v_isReactive") return !i;
        if (n === "__v_isReadonly") return i;
        if (n === "__v_isShallow") return s;
        if (n === "__v_raw" && r === (i ? s ? Rk : tv : s ? ev : $y).get(e)) return e;
        const o = Me(e);
        if (!i) {
            if (o && ot(Hm, n)) return Reflect.get(Hm, n, r);
            if (n === "hasOwnProperty") return gk
        }
        const a = Reflect.get(e, n, r);
        return (Po(n) ? Yy.has(n) : pk(n)) || (i || Pn(e, "get", n), s) ? a : pt(a) ? o && Jh(n) ? a : a.value : gt(a) ? i ? Nu(a) : gl(a) : a
    }
}
class qy extends Xy {
    constructor(e = !1) {
        super(!1, e)
    }
    set(e, n, r, i) {
        let s = e[n];
        if (So(s) && pt(s) && !pt(r)) return !1;
        if (!this._shallow && (!Jc(r) && !So(r) && (s = at(s), r = at(r)), !Me(e) && pt(s) && !pt(r))) return s.value = r, !0;
        const o = Me(e) && Jh(n) ? Number(n) < e.length : ot(e, n),
            a = Reflect.set(e, n, r, i);
        return e === at(i) && (o ? Ss(r, s) && ei(e, "set", n, r) : ei(e, "add", n, r)), a
    }
    deleteProperty(e, n) {
        const r = ot(e, n);
        e[n];
        const i = Reflect.deleteProperty(e, n);
        return i && r && ei(e, "delete", n, void 0), i
    }
    has(e, n) {
        const r = Reflect.has(e, n);
        return (!Po(n) || !Yy.has(n)) && Pn(e, "has", n), r
    }
    ownKeys(e) {
        return Pn(e, "iterate", Me(e) ? "length" : As), Reflect.ownKeys(e)
    }
}
class yk extends Xy {
    constructor(e = !1) {
        super(!0, e)
    }
    set(e, n) {
        return !0
    }
    deleteProperty(e, n) {
        return !0
    }
}
const vk = new qy,
    bk = new yk,
    wk = new qy(!0),
    Yh = t => t,
    Su = t => Reflect.getPrototypeOf(t);

function Wl(t, e, n = !1, r = !1) {
    t = t.__v_raw;
    const i = at(t),
        s = at(e);
    n || (Ss(e, s) && Pn(i, "get", e), Pn(i, "get", s));
    const {
        has: o
    } = Su(i), a = r ? Yh : n ? $h : Ma;
    if (o.call(i, e)) return a(t.get(e));
    if (o.call(i, s)) return a(t.get(s));
    t !== i && t.get(e)
}

function Ql(t, e = !1) {
    const n = this.__v_raw,
        r = at(n),
        i = at(t);
    return e || (Ss(t, i) && Pn(r, "has", t), Pn(r, "has", i)), t === i ? n.has(t) : n.has(t) || n.has(i)
}

function Jl(t, e = !1) {
    return t = t.__v_raw, !e && Pn(at(t), "iterate", As), Reflect.get(t, "size", t)
}

function zm(t) {
    t = at(t);
    const e = at(this);
    return Su(e).has.call(e, t) || (e.add(t), ei(e, "add", t, t)), this
}

function jm(t, e) {
    e = at(e);
    const n = at(this),
        {
            has: r,
            get: i
        } = Su(n);
    let s = r.call(n, t);
    s || (t = at(t), s = r.call(n, t));
    const o = i.call(n, t);
    return n.set(t, e), s ? Ss(e, o) && ei(n, "set", t, e) : ei(n, "add", t, e), this
}

function Vm(t) {
    const e = at(this),
        {
            has: n,
            get: r
        } = Su(e);
    let i = n.call(e, t);
    i || (t = at(t), i = n.call(e, t)), r && r.call(e, t);
    const s = e.delete(t);
    return i && ei(e, "delete", t, void 0), s
}

function Gm() {
    const t = at(this),
        e = t.size !== 0,
        n = t.clear();
    return e && ei(t, "clear", void 0, void 0), n
}

function Kl(t, e) {
    return function(r, i) {
        const s = this,
            o = s.__v_raw,
            a = at(o),
            c = e ? Yh : t ? $h : Ma;
        return !t && Pn(a, "iterate", As), o.forEach((l, u) => r.call(i, c(l), c(u), s))
    }
}

function Zl(t, e, n) {
    return function(...r) {
        const i = this.__v_raw,
            s = at(i),
            o = yo(s),
            a = t === "entries" || t === Symbol.iterator && o,
            c = t === "keys" && o,
            l = i[t](...r),
            u = n ? Yh : e ? $h : Ma;
        return !e && Pn(s, "iterate", c ? Od : As), {
            next() {
                const {
                    value: f,
                    done: d
                } = l.next();
                return d ? {
                    value: f,
                    done: d
                } : {
                    value: a ? [u(f[0]), u(f[1])] : u(f),
                    done: d
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}

function mi(t) {
    return function(...e) {
        return t === "delete" ? !1 : this
    }
}

function xk() {
    const t = {
            get(s) {
                return Wl(this, s)
            },
            get size() {
                return Jl(this)
            },
            has: Ql,
            add: zm,
            set: jm,
            delete: Vm,
            clear: Gm,
            forEach: Kl(!1, !1)
        },
        e = {
            get(s) {
                return Wl(this, s, !1, !0)
            },
            get size() {
                return Jl(this)
            },
            has: Ql,
            add: zm,
            set: jm,
            delete: Vm,
            clear: Gm,
            forEach: Kl(!1, !0)
        },
        n = {
            get(s) {
                return Wl(this, s, !0)
            },
            get size() {
                return Jl(this, !0)
            },
            has(s) {
                return Ql.call(this, s, !0)
            },
            add: mi("add"),
            set: mi("set"),
            delete: mi("delete"),
            clear: mi("clear"),
            forEach: Kl(!0, !1)
        },
        r = {
            get(s) {
                return Wl(this, s, !0, !0)
            },
            get size() {
                return Jl(this, !0)
            },
            has(s) {
                return Ql.call(this, s, !0)
            },
            add: mi("add"),
            set: mi("set"),
            delete: mi("delete"),
            clear: mi("clear"),
            forEach: Kl(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(s => {
        t[s] = Zl(s, !1, !1), n[s] = Zl(s, !0, !1), e[s] = Zl(s, !1, !0), r[s] = Zl(s, !0, !0)
    }), [t, n, e, r]
}
const [Ak, kk, _k, Ek] = xk();

function Xh(t, e) {
    const n = e ? t ? Ek : _k : t ? kk : Ak;
    return (r, i, s) => i === "__v_isReactive" ? !t : i === "__v_isReadonly" ? t : i === "__v_raw" ? r : Reflect.get(ot(n, i) && i in r ? n : r, i, s)
}
const Pk = {
        get: Xh(!1, !1)
    },
    Sk = {
        get: Xh(!1, !0)
    },
    Nk = {
        get: Xh(!0, !1)
    },
    $y = new WeakMap,
    ev = new WeakMap,
    tv = new WeakMap,
    Rk = new WeakMap;

function Ck(t) {
    switch (t) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}

function Ok(t) {
    return t.__v_skip || !Object.isExtensible(t) ? 0 : Ck(YA(t))
}

function gl(t) {
    return So(t) ? t : qh(t, !1, vk, Pk, $y)
}

function nv(t) {
    return qh(t, !1, wk, Sk, ev)
}

function Nu(t) {
    return qh(t, !0, bk, Nk, tv)
}

function qh(t, e, n, r, i) {
    if (!gt(t) || t.__v_raw && !(e && t.__v_isReactive)) return t;
    const s = i.get(t);
    if (s) return s;
    const o = Ok(t);
    if (o === 0) return t;
    const a = new Proxy(t, o === 2 ? r : n);
    return i.set(t, a), a
}

function vo(t) {
    return So(t) ? vo(t.__v_raw) : !!(t && t.__v_isReactive)
}

function So(t) {
    return !!(t && t.__v_isReadonly)
}

function Jc(t) {
    return !!(t && t.__v_isShallow)
}

function rv(t) {
    return vo(t) || So(t)
}

function at(t) {
    const e = t && t.__v_raw;
    return e ? at(e) : t
}

function iv(t) {
    return Wc(t, "__v_skip", !0), t
}
const Ma = t => gt(t) ? gl(t) : t,
    $h = t => gt(t) ? Nu(t) : t;

function ep(t) {
    Ii && sr && (t = at(t), Zy(t.dep || (t.dep = Kh())))
}

function tp(t, e) {
    t = at(t);
    const n = t.dep;
    n && Td(n)
}

function pt(t) {
    return !!(t && t.__v_isRef === !0)
}

function Z(t) {
    return ov(t, !1)
}

function sv(t) {
    return ov(t, !0)
}

function ov(t, e) {
    return pt(t) ? t : new Tk(t, e)
}
class Tk {
    constructor(e, n) {
        this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? e : at(e), this._value = n ? e : Ma(e)
    }
    get value() {
        return ep(this), this._value
    }
    set value(e) {
        const n = this.__v_isShallow || Jc(e) || So(e);
        e = n ? e : at(e), Ss(e, this._rawValue) && (this._rawValue = e, this._value = n ? e : Ma(e), tp(this))
    }
}

function J(t) {
    return pt(t) ? t.value : t
}
const Bk = {
    get: (t, e, n) => J(Reflect.get(t, e, n)),
    set: (t, e, n, r) => {
        const i = t[e];
        return pt(i) && !pt(n) ? (i.value = n, !0) : Reflect.set(t, e, n, r)
    }
};

function av(t) {
    return vo(t) ? t : new Proxy(t, Bk)
}
class Ik {
    constructor(e) {
        this.dep = void 0, this.__v_isRef = !0;
        const {
            get: n,
            set: r
        } = e(() => ep(this), () => tp(this));
        this._get = n, this._set = r
    }
    get value() {
        return this._get()
    }
    set value(e) {
        this._set(e)
    }
}

function Dk(t) {
    return new Ik(t)
}

function oo(t) {
    const e = Me(t) ? new Array(t.length) : {};
    for (const n in t) e[n] = lv(t, n);
    return e
}
class Lk {
    constructor(e, n, r) {
        this._object = e, this._key = n, this._defaultValue = r, this.__v_isRef = !0
    }
    get value() {
        const e = this._object[this._key];
        return e === void 0 ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
    get dep() {
        return hk(at(this._object), this._key)
    }
}
class Mk {
    constructor(e) {
        this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0
    }
    get value() {
        return this._getter()
    }
}

function Fk(t, e, n) {
    return pt(t) ? t : We(t) ? new Mk(t) : gt(t) && arguments.length > 1 ? lv(t, e, n) : Z(t)
}

function lv(t, e, n) {
    const r = t[e];
    return pt(r) ? r : new Lk(t, e, n)
}
class Uk {
    constructor(e, n, r, i) {
        this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new Zh(e, () => {
            this._dirty || (this._dirty = !0, tp(this))
        }), this.effect.computed = this, this.effect.active = this._cacheable = !i, this.__v_isReadonly = r
    }
    get value() {
        const e = at(this);
        return ep(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value
    }
    set value(e) {
        this._setter(e)
    }
}

function Hk(t, e, n = !1) {
    let r, i;
    const s = We(t);
    return s ? (r = t, i = Er) : (r = t.get, i = t.set), new Uk(r, i, s || !i, n)
}

function Di(t, e, n, r) {
    let i;
    try {
        i = r ? t(...r) : t()
    } catch (s) {
        Ru(s, e, n)
    }
    return i
}

function Vn(t, e, n, r) {
    if (We(t)) {
        const s = Di(t, e, n, r);
        return s && Uy(s) && s.catch(o => {
            Ru(o, e, n)
        }), s
    }
    const i = [];
    for (let s = 0; s < t.length; s++) i.push(Vn(t[s], e, n, r));
    return i
}

function Ru(t, e, n, r = !0) {
    const i = e ? e.vnode : null;
    if (e) {
        let s = e.parent;
        const o = e.proxy,
            a = n;
        for (; s;) {
            const l = s.ec;
            if (l) {
                for (let u = 0; u < l.length; u++)
                    if (l[u](t, o, a) === !1) return
            }
            s = s.parent
        }
        const c = e.appContext.config.errorHandler;
        if (c) {
            Di(c, null, 10, [t, o, a]);
            return
        }
    }
    zk(t, n, i, r)
}

function zk(t, e, n, r = !0) {
    console.error(t)
}
let Fa = !1,
    Bd = !1;
const ln = [];
let br = 0;
const bo = [];
let Vr = null,
    ls = 0;
const cv = Promise.resolve();
let np = null;

function yl(t) {
    const e = np || cv;
    return t ? e.then(this ? t.bind(this) : t) : e
}

function jk(t) {
    let e = br + 1,
        n = ln.length;
    for (; e < n;) {
        const r = e + n >>> 1,
            i = ln[r],
            s = Ua(i);
        s < t || s === t && i.pre ? e = r + 1 : n = r
    }
    return e
}

function rp(t) {
    (!ln.length || !ln.includes(t, Fa && t.allowRecurse ? br + 1 : br)) && (t.id == null ? ln.push(t) : ln.splice(jk(t.id), 0, t), uv())
}

function uv() {
    !Fa && !Bd && (Bd = !0, np = cv.then(dv))
}

function Vk(t) {
    const e = ln.indexOf(t);
    e > br && ln.splice(e, 1)
}

function Gk(t) {
    Me(t) ? bo.push(...t) : (!Vr || !Vr.includes(t, t.allowRecurse ? ls + 1 : ls)) && bo.push(t), uv()
}

function Wm(t, e = Fa ? br + 1 : 0) {
    for (; e < ln.length; e++) {
        const n = ln[e];
        n && n.pre && (ln.splice(e, 1), e--, n())
    }
}

function fv(t) {
    if (bo.length) {
        const e = [...new Set(bo)];
        if (bo.length = 0, Vr) {
            Vr.push(...e);
            return
        }
        for (Vr = e, Vr.sort((n, r) => Ua(n) - Ua(r)), ls = 0; ls < Vr.length; ls++) Vr[ls]();
        Vr = null, ls = 0
    }
}
const Ua = t => t.id == null ? 1 / 0 : t.id,
    Wk = (t, e) => {
        const n = Ua(t) - Ua(e);
        if (n === 0) {
            if (t.pre && !e.pre) return -1;
            if (e.pre && !t.pre) return 1
        }
        return n
    };

function dv(t) {
    Bd = !1, Fa = !0, ln.sort(Wk);
    try {
        for (br = 0; br < ln.length; br++) {
            const e = ln[br];
            e && e.active !== !1 && Di(e, null, 14)
        }
    } finally {
        br = 0, ln.length = 0, fv(), Fa = !1, np = null, (ln.length || bo.length) && dv()
    }
}

function Qk(t, e, ...n) {
    if (t.isUnmounted) return;
    const r = t.vnode.props || wt;
    let i = n;
    const s = e.startsWith("update:"),
        o = s && e.slice(7);
    if (o && o in r) {
        const u = `${o==="modelValue"?"model":o}Modifiers`,
            {
                number: f,
                trim: d
            } = r[u] || wt;
        d && (i = n.map(h => zt(h) ? h.trim() : h)), f && (i = n.map(jy))
    }
    let a, c = r[a = kf(e)] || r[a = kf(Br(e))];
    !c && s && (c = r[a = kf(Fs(e))]), c && Vn(c, t, 6, i);
    const l = r[a + "Once"];
    if (l) {
        if (!t.emitted) t.emitted = {};
        else if (t.emitted[a]) return;
        t.emitted[a] = !0, Vn(l, t, 6, i)
    }
}

function hv(t, e, n = !1) {
    const r = e.emitsCache,
        i = r.get(t);
    if (i !== void 0) return i;
    const s = t.emits;
    let o = {},
        a = !1;
    if (!We(t)) {
        const c = l => {
            const u = hv(l, e, !0);
            u && (a = !0, Jt(o, u))
        };
        !n && e.mixins.length && e.mixins.forEach(c), t.extends && c(t.extends), t.mixins && t.mixins.forEach(c)
    }
    return !s && !a ? (gt(t) && r.set(t, null), null) : (Me(s) ? s.forEach(c => o[c] = null) : Jt(o, s), gt(t) && r.set(t, o), o)
}

function Cu(t, e) {
    return !t || !xu(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), ot(t, e[0].toLowerCase() + e.slice(1)) || ot(t, Fs(e)) || ot(t, e))
}
let rn = null,
    pv = null;

function Kc(t) {
    const e = rn;
    return rn = t, pv = t && t.type.__scopeId || null, e
}

function Ze(t, e = rn, n) {
    if (!e || t._n) return t;
    const r = (...i) => {
        r._d && i0(-1);
        const s = Kc(e);
        let o;
        try {
            o = t(...i)
        } finally {
            Kc(s), r._d && i0(1)
        }
        return o
    };
    return r._n = !0, r._c = !0, r._d = !0, r
}

function _f(t) {
    const {
        type: e,
        vnode: n,
        proxy: r,
        withProxy: i,
        props: s,
        propsOptions: [o],
        slots: a,
        attrs: c,
        emit: l,
        render: u,
        renderCache: f,
        data: d,
        setupState: h,
        ctx: p,
        inheritAttrs: g
    } = t;
    let b, x;
    const w = Kc(t);
    try {
        if (n.shapeFlag & 4) {
            const N = i || r;
            b = vr(u.call(N, N, f, s, h, d, p)), x = c
        } else {
            const N = e;
            b = vr(N.length > 1 ? N(s, {
                attrs: c,
                slots: a,
                emit: l
            }) : N(s, null)), x = e.props ? c : Jk(c)
        }
    } catch (N) {
        _a.length = 0, Ru(N, t, 1), b = q(Gn)
    }
    let O = b;
    if (x && g !== !1) {
        const N = Object.keys(x),
            {
                shapeFlag: U
            } = O;
        N.length && U & 7 && (o && N.some(Wh) && (x = Kk(x, o)), O = ii(O, x))
    }
    return n.dirs && (O = ii(O), O.dirs = O.dirs ? O.dirs.concat(n.dirs) : n.dirs), n.transition && (O.transition = n.transition), b = O, Kc(w), b
}
const Jk = t => {
        let e;
        for (const n in t)(n === "class" || n === "style" || xu(n)) && ((e || (e = {}))[n] = t[n]);
        return e
    },
    Kk = (t, e) => {
        const n = {};
        for (const r in t)(!Wh(r) || !(r.slice(9) in e)) && (n[r] = t[r]);
        return n
    };

function Zk(t, e, n) {
    const {
        props: r,
        children: i,
        component: s
    } = t, {
        props: o,
        children: a,
        patchFlag: c
    } = e, l = s.emitsOptions;
    if (e.dirs || e.transition) return !0;
    if (n && c >= 0) {
        if (c & 1024) return !0;
        if (c & 16) return r ? Qm(r, o, l) : !!o;
        if (c & 8) {
            const u = e.dynamicProps;
            for (let f = 0; f < u.length; f++) {
                const d = u[f];
                if (o[d] !== r[d] && !Cu(l, d)) return !0
            }
        }
    } else return (i || a) && (!a || !a.$stable) ? !0 : r === o ? !1 : r ? o ? Qm(r, o, l) : !0 : !!o;
    return !1
}

function Qm(t, e, n) {
    const r = Object.keys(e);
    if (r.length !== Object.keys(t).length) return !0;
    for (let i = 0; i < r.length; i++) {
        const s = r[i];
        if (e[s] !== t[s] && !Cu(n, s)) return !0
    }
    return !1
}

function Yk({
    vnode: t,
    parent: e
}, n) {
    for (; e && e.subTree === t;)(t = e.vnode).el = n, e = e.parent
}
const ip = "components",
    Xk = "directives";

function Lr(t, e) {
    return sp(ip, t, !0, e) || t
}
const mv = Symbol.for("v-ndc");

function gv(t) {
    return zt(t) ? sp(ip, t, !1) || t : t || mv
}

function qk(t) {
    return sp(Xk, t)
}

function sp(t, e, n = !0, r = !1) {
    const i = rn || qt;
    if (i) {
        const s = i.type;
        if (t === ip) {
            const a = W_(s, !1);
            if (a && (a === e || a === Br(e) || a === _u(Br(e)))) return s
        }
        const o = Jm(i[t] || s[t], e) || Jm(i.appContext[t], e);
        return !o && r ? s : o
    }
}

function Jm(t, e) {
    return t && (t[e] || t[Br(e)] || t[_u(Br(e))])
}
const $k = t => t.__isSuspense;

function e_(t, e) {
    e && e.pendingBranch ? Me(t) ? e.effects.push(...t) : e.effects.push(t) : Gk(t)
}

function Zc(t, e) {
    return Ou(t, null, e)
}

function t_(t, e) {
    return Ou(t, null, {
        flush: "post"
    })
}
const Yl = {};

function Xe(t, e, n) {
    return Ou(t, e, n)
}

function Ou(t, e, {
    immediate: n,
    deep: r,
    flush: i,
    onTrack: s,
    onTrigger: o
} = wt) {
    var a;
    const c = Wy() === ((a = qt) == null ? void 0 : a.scope) ? qt : null;
    let l, u = !1,
        f = !1;
    if (pt(t) ? (l = () => t.value, u = Jc(t)) : vo(t) ? (l = () => t, r = !0) : Me(t) ? (f = !0, u = t.some(N => vo(N) || Jc(N)), l = () => t.map(N => {
            if (pt(N)) return N.value;
            if (vo(N)) return ds(N);
            if (We(N)) return Di(N, c, 2)
        })) : We(t) ? e ? l = () => Di(t, c, 2) : l = () => {
            if (!(c && c.isUnmounted)) return d && d(), Vn(t, c, 3, [h])
        } : l = Er, e && r) {
        const N = l;
        l = () => ds(N())
    }
    let d, h = N => {
            d = w.onStop = () => {
                Di(N, c, 4)
            }
        },
        p;
    if (za)
        if (h = Er, e ? n && Vn(e, c, 3, [l(), f ? [] : void 0, h]) : l(), i === "sync") {
            const N = K_();
            p = N.__watcherHandles || (N.__watcherHandles = [])
        } else return Er;
    let g = f ? new Array(t.length).fill(Yl) : Yl;
    const b = () => {
        if (w.active)
            if (e) {
                const N = w.run();
                (r || u || (f ? N.some((U, H) => Ss(U, g[H])) : Ss(N, g))) && (d && d(), Vn(e, c, 3, [N, g === Yl ? void 0 : f && g[0] === Yl ? [] : g, h]), g = N)
            } else w.run()
    };
    b.allowRecurse = !!e;
    let x;
    i === "sync" ? x = b : i === "post" ? x = () => bn(b, c && c.suspense) : (b.pre = !0, c && (b.id = c.uid), x = () => rp(b));
    const w = new Zh(l, x);
    e ? n ? b() : g = w.run() : i === "post" ? bn(w.run.bind(w), c && c.suspense) : w.run();
    const O = () => {
        w.stop(), c && c.scope && Qh(c.scope.effects, w)
    };
    return p && p.push(O), O
}

function n_(t, e, n) {
    const r = this.proxy,
        i = zt(t) ? t.includes(".") ? yv(r, t) : () => r[t] : t.bind(r, r);
    let s;
    We(e) ? s = e : (s = e.handler, n = e);
    const o = qt;
    No(this);
    const a = Ou(i, s.bind(r), n);
    return o ? No(o) : ks(), a
}

function yv(t, e) {
    const n = e.split(".");
    return () => {
        let r = t;
        for (let i = 0; i < n.length && r; i++) r = r[n[i]];
        return r
    }
}

function ds(t, e) {
    if (!gt(t) || t.__v_skip || (e = e || new Set, e.has(t))) return t;
    if (e.add(t), pt(t)) ds(t.value, e);
    else if (Me(t))
        for (let n = 0; n < t.length; n++) ds(t[n], e);
    else if (Au(t) || yo(t)) t.forEach(n => {
        ds(n, e)
    });
    else if (zy(t))
        for (const n in t) ds(t[n], e);
    return t
}

function Bt(t, e) {
    const n = rn;
    if (n === null) return t;
    const r = Lu(n) || n.proxy,
        i = t.dirs || (t.dirs = []);
    for (let s = 0; s < e.length; s++) {
        let [o, a, c, l = wt] = e[s];
        o && (We(o) && (o = {
            mounted: o,
            updated: o
        }), o.deep && ds(a), i.push({
            dir: o,
            instance: r,
            value: a,
            oldValue: void 0,
            arg: c,
            modifiers: l
        }))
    }
    return t
}

function qi(t, e, n, r) {
    const i = t.dirs,
        s = e && e.dirs;
    for (let o = 0; o < i.length; o++) {
        const a = i[o];
        s && (a.oldValue = s[o].value);
        let c = a.dir[r];
        c && (Qo(), Vn(c, n, 8, [t.el, a, t, e]), Jo())
    }
}
const Si = Symbol("_leaveCb"),
    Xl = Symbol("_enterCb");

function r_() {
    const t = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return sn(() => {
        t.isMounted = !0
    }), vl(() => {
        t.isUnmounting = !0
    }), t
}
const Dn = [Function, Array],
    vv = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: Dn,
        onEnter: Dn,
        onAfterEnter: Dn,
        onEnterCancelled: Dn,
        onBeforeLeave: Dn,
        onLeave: Dn,
        onAfterLeave: Dn,
        onLeaveCancelled: Dn,
        onBeforeAppear: Dn,
        onAppear: Dn,
        onAfterAppear: Dn,
        onAppearCancelled: Dn
    },
    i_ = {
        name: "BaseTransition",
        props: vv,
        setup(t, {
            slots: e
        }) {
            const n = Zo(),
                r = r_();
            let i;
            return () => {
                const s = e.default && wv(e.default(), !0);
                if (!s || !s.length) return;
                let o = s[0];
                if (s.length > 1) {
                    for (const g of s)
                        if (g.type !== Gn) {
                            o = g;
                            break
                        }
                }
                const a = at(t),
                    {
                        mode: c
                    } = a;
                if (r.isLeaving) return Ef(o);
                const l = Km(o);
                if (!l) return Ef(o);
                const u = Id(l, a, r, n);
                Dd(l, u);
                const f = n.subTree,
                    d = f && Km(f);
                let h = !1;
                const {
                    getTransitionKey: p
                } = l.type;
                if (p) {
                    const g = p();
                    i === void 0 ? i = g : g !== i && (i = g, h = !0)
                }
                if (d && d.type !== Gn && (!cs(l, d) || h)) {
                    const g = Id(d, a, r, n);
                    if (Dd(d, g), c === "out-in") return r.isLeaving = !0, g.afterLeave = () => {
                        r.isLeaving = !1, n.update.active !== !1 && n.update()
                    }, Ef(o);
                    c === "in-out" && l.type !== Gn && (g.delayLeave = (b, x, w) => {
                        const O = bv(r, d);
                        O[String(d.key)] = d, b[Si] = () => {
                            x(), b[Si] = void 0, delete u.delayedLeave
                        }, u.delayedLeave = w
                    })
                }
                return o
            }
        }
    },
    s_ = i_;

function bv(t, e) {
    const {
        leavingVNodes: n
    } = t;
    let r = n.get(e.type);
    return r || (r = Object.create(null), n.set(e.type, r)), r
}

function Id(t, e, n, r) {
    const {
        appear: i,
        mode: s,
        persisted: o = !1,
        onBeforeEnter: a,
        onEnter: c,
        onAfterEnter: l,
        onEnterCancelled: u,
        onBeforeLeave: f,
        onLeave: d,
        onAfterLeave: h,
        onLeaveCancelled: p,
        onBeforeAppear: g,
        onAppear: b,
        onAfterAppear: x,
        onAppearCancelled: w
    } = e, O = String(t.key), N = bv(n, t), U = (y, v) => {
        y && Vn(y, r, 9, v)
    }, H = (y, v) => {
        const A = v[1];
        U(y, v), Me(y) ? y.every(E => E.length <= 1) && A() : y.length <= 1 && A()
    }, M = {
        mode: s,
        persisted: o,
        beforeEnter(y) {
            let v = a;
            if (!n.isMounted)
                if (i) v = g || a;
                else return;
            y[Si] && y[Si](!0);
            const A = N[O];
            A && cs(t, A) && A.el[Si] && A.el[Si](), U(v, [y])
        },
        enter(y) {
            let v = c,
                A = l,
                E = u;
            if (!n.isMounted)
                if (i) v = b || c, A = x || l, E = w || u;
                else return;
            let P = !1;
            const R = y[Xl] = F => {
                P || (P = !0, F ? U(E, [y]) : U(A, [y]), M.delayedLeave && M.delayedLeave(), y[Xl] = void 0)
            };
            v ? H(v, [y, R]) : R()
        },
        leave(y, v) {
            const A = String(t.key);
            if (y[Xl] && y[Xl](!0), n.isUnmounting) return v();
            U(f, [y]);
            let E = !1;
            const P = y[Si] = R => {
                E || (E = !0, v(), R ? U(p, [y]) : U(h, [y]), y[Si] = void 0, N[A] === t && delete N[A])
            };
            N[A] = t, d ? H(d, [y, P]) : P()
        },
        clone(y) {
            return Id(y, e, n, r)
        }
    };
    return M
}

function Ef(t) {
    if (Tu(t)) return t = ii(t), t.children = null, t
}

function Km(t) {
    return Tu(t) ? t.children ? t.children[0] : void 0 : t
}

function Dd(t, e) {
    t.shapeFlag & 6 && t.component ? Dd(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e
}

function wv(t, e = !1, n) {
    let r = [],
        i = 0;
    for (let s = 0; s < t.length; s++) {
        let o = t[s];
        const a = n == null ? o.key : String(n) + String(o.key != null ? o.key : s);
        o.type === Ye ? (o.patchFlag & 128 && i++, r = r.concat(wv(o.children, e, a))) : (e || o.type !== Gn) && r.push(a != null ? ii(o, {
            key: a
        }) : o)
    }
    if (i > 1)
        for (let s = 0; s < r.length; s++) r[s].patchFlag = -2;
    return r
} /*! #__NO_SIDE_EFFECTS__ */
function nt(t, e) {
    return We(t) ? (() => Jt({
        name: t.name
    }, e, {
        setup: t
    }))() : t
}
const xa = t => !!t.type.__asyncLoader,
    Tu = t => t.type.__isKeepAlive;

function o_(t, e) {
    xv(t, "a", e)
}

function a_(t, e) {
    xv(t, "da", e)
}

function xv(t, e, n = qt) {
    const r = t.__wdc || (t.__wdc = () => {
        let i = n;
        for (; i;) {
            if (i.isDeactivated) return;
            i = i.parent
        }
        return t()
    });
    if (Bu(e, r, n), n) {
        let i = n.parent;
        for (; i && i.parent;) Tu(i.parent.vnode) && l_(r, e, n, i), i = i.parent
    }
}

function l_(t, e, n, r) {
    const i = Bu(e, t, r, !0);
    Us(() => {
        Qh(r[e], i)
    }, n)
}

function Bu(t, e, n = qt, r = !1) {
    if (n) {
        const i = n[t] || (n[t] = []),
            s = e.__weh || (e.__weh = (...o) => {
                if (n.isUnmounted) return;
                Qo(), No(n);
                const a = Vn(e, n, t, o);
                return ks(), Jo(), a
            });
        return r ? i.unshift(s) : i.push(s), s
    }
}
const ui = t => (e, n = qt) => (!za || t === "sp") && Bu(t, (...r) => e(...r), n),
    c_ = ui("bm"),
    sn = ui("m"),
    u_ = ui("bu"),
    f_ = ui("u"),
    vl = ui("bum"),
    Us = ui("um"),
    d_ = ui("sp"),
    h_ = ui("rtg"),
    p_ = ui("rtc");

function m_(t, e = qt) {
    Bu("ec", t, e)
}

function xt(t, e, n, r) {
    let i;
    const s = n && n[r];
    if (Me(t) || zt(t)) {
        i = new Array(t.length);
        for (let o = 0, a = t.length; o < a; o++) i[o] = e(t[o], o, void 0, s && s[o])
    } else if (typeof t == "number") {
        i = new Array(t);
        for (let o = 0; o < t; o++) i[o] = e(o + 1, o, void 0, s && s[o])
    } else if (gt(t))
        if (t[Symbol.iterator]) i = Array.from(t, (o, a) => e(o, a, void 0, s && s[a]));
        else {
            const o = Object.keys(t);
            i = new Array(o.length);
            for (let a = 0, c = o.length; a < c; a++) {
                const l = o[a];
                i[a] = e(t[l], l, a, s && s[a])
            }
        }
    else i = [];
    return n && (n[r] = i), i
}

function Zm(t, e, n = {}, r, i) {
    if (rn.isCE || rn.parent && xa(rn.parent) && rn.parent.isCE) return e !== "default" && (n.name = e), q("slot", n, r && r());
    let s = t[e];
    s && s._c && (s._d = !1), fe();
    const o = s && Av(s(n)),
        a = fi(Ye, {
            key: n.key || o && o.key || `_${e}`
        }, o || (r ? r() : []), o && t._ === 1 ? 64 : -2);
    return !i && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), s && s._c && (s._d = !0), a
}

function Av(t) {
    return t.some(e => qc(e) ? !(e.type === Gn || e.type === Ye && !Av(e.children)) : !0) ? t : null
}
const Ld = t => t ? Iv(t) ? Lu(t) || t.proxy : Ld(t.parent) : null,
    Aa = Jt(Object.create(null), {
        $: t => t,
        $el: t => t.vnode.el,
        $data: t => t.data,
        $props: t => t.props,
        $attrs: t => t.attrs,
        $slots: t => t.slots,
        $refs: t => t.refs,
        $parent: t => Ld(t.parent),
        $root: t => Ld(t.root),
        $emit: t => t.emit,
        $options: t => op(t),
        $forceUpdate: t => t.f || (t.f = () => rp(t.update)),
        $nextTick: t => t.n || (t.n = yl.bind(t.proxy)),
        $watch: t => n_.bind(t)
    }),
    Pf = (t, e) => t !== wt && !t.__isScriptSetup && ot(t, e),
    g_ = {
        get({
            _: t
        }, e) {
            const {
                ctx: n,
                setupState: r,
                data: i,
                props: s,
                accessCache: o,
                type: a,
                appContext: c
            } = t;
            let l;
            if (e[0] !== "$") {
                const h = o[e];
                if (h !== void 0) switch (h) {
                    case 1:
                        return r[e];
                    case 2:
                        return i[e];
                    case 4:
                        return n[e];
                    case 3:
                        return s[e]
                } else {
                    if (Pf(r, e)) return o[e] = 1, r[e];
                    if (i !== wt && ot(i, e)) return o[e] = 2, i[e];
                    if ((l = t.propsOptions[0]) && ot(l, e)) return o[e] = 3, s[e];
                    if (n !== wt && ot(n, e)) return o[e] = 4, n[e];
                    Md && (o[e] = 0)
                }
            }
            const u = Aa[e];
            let f, d;
            if (u) return e === "$attrs" && Pn(t, "get", e), u(t);
            if ((f = a.__cssModules) && (f = f[e])) return f;
            if (n !== wt && ot(n, e)) return o[e] = 4, n[e];
            if (d = c.config.globalProperties, ot(d, e)) return d[e]
        },
        set({
            _: t
        }, e, n) {
            const {
                data: r,
                setupState: i,
                ctx: s
            } = t;
            return Pf(i, e) ? (i[e] = n, !0) : r !== wt && ot(r, e) ? (r[e] = n, !0) : ot(t.props, e) || e[0] === "$" && e.slice(1) in t ? !1 : (s[e] = n, !0)
        },
        has({
            _: {
                data: t,
                setupState: e,
                accessCache: n,
                ctx: r,
                appContext: i,
                propsOptions: s
            }
        }, o) {
            let a;
            return !!n[o] || t !== wt && ot(t, o) || Pf(e, o) || (a = s[0]) && ot(a, o) || ot(r, o) || ot(Aa, o) || ot(i.config.globalProperties, o)
        },
        defineProperty(t, e, n) {
            return n.get != null ? t._.accessCache[e] = 0 : ot(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n)
        }
    };

function y_() {
    return v_().slots
}

function v_() {
    const t = Zo();
    return t.setupContext || (t.setupContext = Lv(t))
}

function Ym(t) {
    return Me(t) ? t.reduce((e, n) => (e[n] = null, e), {}) : t
}
let Md = !0;

function b_(t) {
    const e = op(t),
        n = t.proxy,
        r = t.ctx;
    Md = !1, e.beforeCreate && Xm(e.beforeCreate, t, "bc");
    const {
        data: i,
        computed: s,
        methods: o,
        watch: a,
        provide: c,
        inject: l,
        created: u,
        beforeMount: f,
        mounted: d,
        beforeUpdate: h,
        updated: p,
        activated: g,
        deactivated: b,
        beforeDestroy: x,
        beforeUnmount: w,
        destroyed: O,
        unmounted: N,
        render: U,
        renderTracked: H,
        renderTriggered: M,
        errorCaptured: y,
        serverPrefetch: v,
        expose: A,
        inheritAttrs: E,
        components: P,
        directives: R,
        filters: F
    } = e;
    if (l && w_(l, r, null), o)
        for (const I in o) {
            const B = o[I];
            We(B) && (r[I] = B.bind(n))
        }
    if (i) {
        const I = i.call(n, n);
        gt(I) && (t.data = gl(I))
    }
    if (Md = !0, s)
        for (const I in s) {
            const B = s[I],
                j = We(B) ? B.bind(n, n) : We(B.get) ? B.get.bind(n, n) : Er,
                Y = !We(B) && We(B.set) ? B.set.bind(n) : Er,
                te = ze({
                    get: j,
                    set: Y
                });
            Object.defineProperty(r, I, {
                enumerable: !0,
                configurable: !0,
                get: () => te.value,
                set: he => te.value = he
            })
        }
    if (a)
        for (const I in a) kv(a[I], r, n, I);
    if (c) {
        const I = We(c) ? c.call(n) : c;
        Reflect.ownKeys(I).forEach(B => {
            de(B, I[B])
        })
    }
    u && Xm(u, t, "c");

    function S(I, B) {
        Me(B) ? B.forEach(j => I(j.bind(n))) : B && I(B.bind(n))
    }
    if (S(c_, f), S(sn, d), S(u_, h), S(f_, p), S(o_, g), S(a_, b), S(m_, y), S(p_, H), S(h_, M), S(vl, w), S(Us, N), S(d_, v), Me(A))
        if (A.length) {
            const I = t.exposed || (t.exposed = {});
            A.forEach(B => {
                Object.defineProperty(I, B, {
                    get: () => n[B],
                    set: j => n[B] = j
                })
            })
        } else t.exposed || (t.exposed = {});
    U && t.render === Er && (t.render = U), E != null && (t.inheritAttrs = E), P && (t.components = P), R && (t.directives = R)
}

function w_(t, e, n = Er) {
    Me(t) && (t = Fd(t));
    for (const r in t) {
        const i = t[r];
        let s;
        gt(i) ? "default" in i ? s = we(i.from || r, i.default, !0) : s = we(i.from || r) : s = we(i), pt(s) ? Object.defineProperty(e, r, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: o => s.value = o
        }) : e[r] = s
    }
}

function Xm(t, e, n) {
    Vn(Me(t) ? t.map(r => r.bind(e.proxy)) : t.bind(e.proxy), e, n)
}

function kv(t, e, n, r) {
    const i = r.includes(".") ? yv(n, r) : () => n[r];
    if (zt(t)) {
        const s = e[t];
        We(s) && Xe(i, s)
    } else if (We(t)) Xe(i, t.bind(n));
    else if (gt(t))
        if (Me(t)) t.forEach(s => kv(s, e, n, r));
        else {
            const s = We(t.handler) ? t.handler.bind(n) : e[t.handler];
            We(s) && Xe(i, s, t)
        }
}

function op(t) {
    const e = t.type,
        {
            mixins: n,
            extends: r
        } = e,
        {
            mixins: i,
            optionsCache: s,
            config: {
                optionMergeStrategies: o
            }
        } = t.appContext,
        a = s.get(e);
    let c;
    return a ? c = a : !i.length && !n && !r ? c = e : (c = {}, i.length && i.forEach(l => Yc(c, l, o, !0)), Yc(c, e, o)), gt(e) && s.set(e, c), c
}

function Yc(t, e, n, r = !1) {
    const {
        mixins: i,
        extends: s
    } = e;
    s && Yc(t, s, n, !0), i && i.forEach(o => Yc(t, o, n, !0));
    for (const o in e)
        if (!(r && o === "expose")) {
            const a = x_[o] || n && n[o];
            t[o] = a ? a(t[o], e[o]) : e[o]
        }
    return t
}
const x_ = {
    data: qm,
    props: $m,
    emits: $m,
    methods: pa,
    computed: pa,
    beforeCreate: un,
    created: un,
    beforeMount: un,
    mounted: un,
    beforeUpdate: un,
    updated: un,
    beforeDestroy: un,
    beforeUnmount: un,
    destroyed: un,
    unmounted: un,
    activated: un,
    deactivated: un,
    errorCaptured: un,
    serverPrefetch: un,
    components: pa,
    directives: pa,
    watch: k_,
    provide: qm,
    inject: A_
};

function qm(t, e) {
    return e ? t ? function() {
        return Jt(We(t) ? t.call(this, this) : t, We(e) ? e.call(this, this) : e)
    } : e : t
}

function A_(t, e) {
    return pa(Fd(t), Fd(e))
}

function Fd(t) {
    if (Me(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++) e[t[n]] = t[n];
        return e
    }
    return t
}

function un(t, e) {
    return t ? [...new Set([].concat(t, e))] : e
}

function pa(t, e) {
    return t ? Jt(Object.create(null), t, e) : e
}

function $m(t, e) {
    return t ? Me(t) && Me(e) ? [...new Set([...t, ...e])] : Jt(Object.create(null), Ym(t), Ym(e ? ? {})) : e
}

function k_(t, e) {
    if (!t) return e;
    if (!e) return t;
    const n = Jt(Object.create(null), t);
    for (const r in e) n[r] = un(t[r], e[r]);
    return n
}

function _v() {
    return {
        app: null,
        config: {
            isNativeTag: JA,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let __ = 0;

function E_(t, e) {
    return function(r, i = null) {
        We(r) || (r = Jt({}, r)), i != null && !gt(i) && (i = null);
        const s = _v(),
            o = new WeakSet;
        let a = !1;
        const c = s.app = {
            _uid: __++,
            _component: r,
            _props: i,
            _container: null,
            _context: s,
            _instance: null,
            version: Z_,
            get config() {
                return s.config
            },
            set config(l) {},
            use(l, ...u) {
                return o.has(l) || (l && We(l.install) ? (o.add(l), l.install(c, ...u)) : We(l) && (o.add(l), l(c, ...u))), c
            },
            mixin(l) {
                return s.mixins.includes(l) || s.mixins.push(l), c
            },
            component(l, u) {
                return u ? (s.components[l] = u, c) : s.components[l]
            },
            directive(l, u) {
                return u ? (s.directives[l] = u, c) : s.directives[l]
            },
            mount(l, u, f) {
                if (!a) {
                    const d = q(r, i);
                    return d.appContext = s, u && e ? e(d, l) : t(d, l, f), a = !0, c._container = l, l.__vue_app__ = c, Lu(d.component) || d.component.proxy
                }
            },
            unmount() {
                a && (t(null, c._container), delete c._container.__vue_app__)
            },
            provide(l, u) {
                return s.provides[l] = u, c
            },
            runWithContext(l) {
                Xc = c;
                try {
                    return l()
                } finally {
                    Xc = null
                }
            }
        };
        return c
    }
}
let Xc = null;

function de(t, e) {
    if (qt) {
        let n = qt.provides;
        const r = qt.parent && qt.parent.provides;
        r === n && (n = qt.provides = Object.create(r)), n[t] = e
    }
}

function we(t, e, n = !1) {
    const r = qt || rn;
    if (r || Xc) {
        const i = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : Xc._context.provides;
        if (i && t in i) return i[t];
        if (arguments.length > 1) return n && We(e) ? e.call(r && r.proxy) : e
    }
}

function P_(t, e, n, r = !1) {
    const i = {},
        s = {};
    Wc(s, Du, 1), t.propsDefaults = Object.create(null), Ev(t, e, i, s);
    for (const o in t.propsOptions[0]) o in i || (i[o] = void 0);
    n ? t.props = r ? i : nv(i) : t.type.props ? t.props = i : t.props = s, t.attrs = s
}

function S_(t, e, n, r) {
    const {
        props: i,
        attrs: s,
        vnode: {
            patchFlag: o
        }
    } = t, a = at(i), [c] = t.propsOptions;
    let l = !1;
    if ((r || o > 0) && !(o & 16)) {
        if (o & 8) {
            const u = t.vnode.dynamicProps;
            for (let f = 0; f < u.length; f++) {
                let d = u[f];
                if (Cu(t.emitsOptions, d)) continue;
                const h = e[d];
                if (c)
                    if (ot(s, d)) h !== s[d] && (s[d] = h, l = !0);
                    else {
                        const p = Br(d);
                        i[p] = Ud(c, a, p, h, t, !1)
                    }
                else h !== s[d] && (s[d] = h, l = !0)
            }
        }
    } else {
        Ev(t, e, i, s) && (l = !0);
        let u;
        for (const f in a)(!e || !ot(e, f) && ((u = Fs(f)) === f || !ot(e, u))) && (c ? n && (n[f] !== void 0 || n[u] !== void 0) && (i[f] = Ud(c, a, f, void 0, t, !0)) : delete i[f]);
        if (s !== a)
            for (const f in s)(!e || !ot(e, f)) && (delete s[f], l = !0)
    }
    l && ei(t, "set", "$attrs")
}

function Ev(t, e, n, r) {
    const [i, s] = t.propsOptions;
    let o = !1,
        a;
    if (e)
        for (let c in e) {
            if (Rc(c)) continue;
            const l = e[c];
            let u;
            i && ot(i, u = Br(c)) ? !s || !s.includes(u) ? n[u] = l : (a || (a = {}))[u] = l : Cu(t.emitsOptions, c) || (!(c in r) || l !== r[c]) && (r[c] = l, o = !0)
        }
    if (s) {
        const c = at(n),
            l = a || wt;
        for (let u = 0; u < s.length; u++) {
            const f = s[u];
            n[f] = Ud(i, c, f, l[f], t, !ot(l, f))
        }
    }
    return o
}

function Ud(t, e, n, r, i, s) {
    const o = t[n];
    if (o != null) {
        const a = ot(o, "default");
        if (a && r === void 0) {
            const c = o.default;
            if (o.type !== Function && !o.skipFactory && We(c)) {
                const {
                    propsDefaults: l
                } = i;
                n in l ? r = l[n] : (No(i), r = l[n] = c.call(null, e), ks())
            } else r = c
        }
        o[0] && (s && !a ? r = !1 : o[1] && (r === "" || r === Fs(n)) && (r = !0))
    }
    return r
}

function Pv(t, e, n = !1) {
    const r = e.propsCache,
        i = r.get(t);
    if (i) return i;
    const s = t.props,
        o = {},
        a = [];
    let c = !1;
    if (!We(t)) {
        const u = f => {
            c = !0;
            const [d, h] = Pv(f, e, !0);
            Jt(o, d), h && a.push(...h)
        };
        !n && e.mixins.length && e.mixins.forEach(u), t.extends && u(t.extends), t.mixins && t.mixins.forEach(u)
    }
    if (!s && !c) return gt(t) && r.set(t, go), go;
    if (Me(s))
        for (let u = 0; u < s.length; u++) {
            const f = Br(s[u]);
            e0(f) && (o[f] = wt)
        } else if (s)
            for (const u in s) {
                const f = Br(u);
                if (e0(f)) {
                    const d = s[u],
                        h = o[f] = Me(d) || We(d) ? {
                            type: d
                        } : Jt({}, d);
                    if (h) {
                        const p = r0(Boolean, h.type),
                            g = r0(String, h.type);
                        h[0] = p > -1, h[1] = g < 0 || p < g, (p > -1 || ot(h, "default")) && a.push(f)
                    }
                }
            }
    const l = [o, a];
    return gt(t) && r.set(t, l), l
}

function e0(t) {
    return t[0] !== "$"
}

function t0(t) {
    const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
    return e ? e[2] : t === null ? "null" : ""
}

function n0(t, e) {
    return t0(t) === t0(e)
}

function r0(t, e) {
    return Me(e) ? e.findIndex(n => n0(n, t)) : We(e) && n0(e, t) ? 0 : -1
}
const Sv = t => t[0] === "_" || t === "$stable",
    ap = t => Me(t) ? t.map(vr) : [vr(t)],
    N_ = (t, e, n) => {
        if (e._n) return e;
        const r = Ze((...i) => ap(e(...i)), n);
        return r._c = !1, r
    },
    Nv = (t, e, n) => {
        const r = t._ctx;
        for (const i in t) {
            if (Sv(i)) continue;
            const s = t[i];
            if (We(s)) e[i] = N_(i, s, r);
            else if (s != null) {
                const o = ap(s);
                e[i] = () => o
            }
        }
    },
    Rv = (t, e) => {
        const n = ap(e);
        t.slots.default = () => n
    },
    R_ = (t, e) => {
        if (t.vnode.shapeFlag & 32) {
            const n = e._;
            n ? (t.slots = at(e), Wc(e, "_", n)) : Nv(e, t.slots = {})
        } else t.slots = {}, e && Rv(t, e);
        Wc(t.slots, Du, 1)
    },
    C_ = (t, e, n) => {
        const {
            vnode: r,
            slots: i
        } = t;
        let s = !0,
            o = wt;
        if (r.shapeFlag & 32) {
            const a = e._;
            a ? n && a === 1 ? s = !1 : (Jt(i, e), !n && a === 1 && delete i._) : (s = !e.$stable, Nv(e, i)), o = e
        } else e && (Rv(t, e), o = {
            default: 1
        });
        if (s)
            for (const a in i) !Sv(a) && o[a] == null && delete i[a]
    };

function Hd(t, e, n, r, i = !1) {
    if (Me(t)) {
        t.forEach((d, h) => Hd(d, e && (Me(e) ? e[h] : e), n, r, i));
        return
    }
    if (xa(r) && !i) return;
    const s = r.shapeFlag & 4 ? Lu(r.component) || r.component.proxy : r.el,
        o = i ? null : s,
        {
            i: a,
            r: c
        } = t,
        l = e && e.r,
        u = a.refs === wt ? a.refs = {} : a.refs,
        f = a.setupState;
    if (l != null && l !== c && (zt(l) ? (u[l] = null, ot(f, l) && (f[l] = null)) : pt(l) && (l.value = null)), We(c)) Di(c, a, 12, [o, u]);
    else {
        const d = zt(c),
            h = pt(c);
        if (d || h) {
            const p = () => {
                if (t.f) {
                    const g = d ? ot(f, c) ? f[c] : u[c] : c.value;
                    i ? Me(g) && Qh(g, s) : Me(g) ? g.includes(s) || g.push(s) : d ? (u[c] = [s], ot(f, c) && (f[c] = u[c])) : (c.value = [s], t.k && (u[t.k] = c.value))
                } else d ? (u[c] = o, ot(f, c) && (f[c] = o)) : h && (c.value = o, t.k && (u[t.k] = o))
            };
            o ? (p.id = -1, bn(p, n)) : p()
        }
    }
}
const bn = e_;

function O_(t) {
    return T_(t)
}

function T_(t, e) {
    const n = Rd();
    n.__VUE__ = !0;
    const {
        insert: r,
        remove: i,
        patchProp: s,
        createElement: o,
        createText: a,
        createComment: c,
        setText: l,
        setElementText: u,
        parentNode: f,
        nextSibling: d,
        setScopeId: h = Er,
        insertStaticContent: p
    } = t, g = (C, T, z, Q = null, $ = null, ne = null, ge = !1, ce = null, ye = !!T.dynamicChildren) => {
        if (C === T) return;
        C && !cs(C, T) && (Q = V(C), he(C, $, ne, !0), C = null), T.patchFlag === -2 && (ye = !1, T.dynamicChildren = null);
        const {
            type: se,
            ref: Ce,
            shapeFlag: _e
        } = T;
        switch (se) {
            case Iu:
                b(C, T, z, Q);
                break;
            case Gn:
                x(C, T, z, Q);
                break;
            case ka:
                C == null && w(T, z, Q, ge);
                break;
            case Ye:
                P(C, T, z, Q, $, ne, ge, ce, ye);
                break;
            default:
                _e & 1 ? U(C, T, z, Q, $, ne, ge, ce, ye) : _e & 6 ? R(C, T, z, Q, $, ne, ge, ce, ye) : (_e & 64 || _e & 128) && se.process(C, T, z, Q, $, ne, ge, ce, ye, ae)
        }
        Ce != null && $ && Hd(Ce, C && C.ref, ne, T || C, !T)
    }, b = (C, T, z, Q) => {
        if (C == null) r(T.el = a(T.children), z, Q);
        else {
            const $ = T.el = C.el;
            T.children !== C.children && l($, T.children)
        }
    }, x = (C, T, z, Q) => {
        C == null ? r(T.el = c(T.children || ""), z, Q) : T.el = C.el
    }, w = (C, T, z, Q) => {
        [C.el, C.anchor] = p(C.children, T, z, Q, C.el, C.anchor)
    }, O = ({
        el: C,
        anchor: T
    }, z, Q) => {
        let $;
        for (; C && C !== T;) $ = d(C), r(C, z, Q), C = $;
        r(T, z, Q)
    }, N = ({
        el: C,
        anchor: T
    }) => {
        let z;
        for (; C && C !== T;) z = d(C), i(C), C = z;
        i(T)
    }, U = (C, T, z, Q, $, ne, ge, ce, ye) => {
        ge = ge || T.type === "svg", C == null ? H(T, z, Q, $, ne, ge, ce, ye) : v(C, T, $, ne, ge, ce, ye)
    }, H = (C, T, z, Q, $, ne, ge, ce) => {
        let ye, se;
        const {
            type: Ce,
            props: _e,
            shapeFlag: Oe,
            transition: He,
            dirs: Qe
        } = C;
        if (ye = C.el = o(C.type, ne, _e && _e.is, _e), Oe & 8 ? u(ye, C.children) : Oe & 16 && y(C.children, ye, null, Q, $, ne && Ce !== "foreignObject", ge, ce), Qe && qi(C, null, Q, "created"), M(ye, C, C.scopeId, ge, Q), _e) {
            for (const rt in _e) rt !== "value" && !Rc(rt) && s(ye, rt, null, _e[rt], ne, C.children, Q, $, X);
            "value" in _e && s(ye, "value", null, _e.value), (se = _e.onVnodeBeforeMount) && pr(se, Q, C)
        }
        Qe && qi(C, null, Q, "beforeMount");
        const st = B_($, He);
        st && He.beforeEnter(ye), r(ye, T, z), ((se = _e && _e.onVnodeMounted) || st || Qe) && bn(() => {
            se && pr(se, Q, C), st && He.enter(ye), Qe && qi(C, null, Q, "mounted")
        }, $)
    }, M = (C, T, z, Q, $) => {
        if (z && h(C, z), Q)
            for (let ne = 0; ne < Q.length; ne++) h(C, Q[ne]);
        if ($) {
            let ne = $.subTree;
            if (T === ne) {
                const ge = $.vnode;
                M(C, ge, ge.scopeId, ge.slotScopeIds, $.parent)
            }
        }
    }, y = (C, T, z, Q, $, ne, ge, ce, ye = 0) => {
        for (let se = ye; se < C.length; se++) {
            const Ce = C[se] = ce ? Ni(C[se]) : vr(C[se]);
            g(null, Ce, T, z, Q, $, ne, ge, ce)
        }
    }, v = (C, T, z, Q, $, ne, ge) => {
        const ce = T.el = C.el;
        let {
            patchFlag: ye,
            dynamicChildren: se,
            dirs: Ce
        } = T;
        ye |= C.patchFlag & 16;
        const _e = C.props || wt,
            Oe = T.props || wt;
        let He;
        z && $i(z, !1), (He = Oe.onVnodeBeforeUpdate) && pr(He, z, T, C), Ce && qi(T, C, z, "beforeUpdate"), z && $i(z, !0);
        const Qe = $ && T.type !== "foreignObject";
        if (se ? A(C.dynamicChildren, se, ce, z, Q, Qe, ne) : ge || B(C, T, ce, null, z, Q, Qe, ne, !1), ye > 0) {
            if (ye & 16) E(ce, T, _e, Oe, z, Q, $);
            else if (ye & 2 && _e.class !== Oe.class && s(ce, "class", null, Oe.class, $), ye & 4 && s(ce, "style", _e.style, Oe.style, $), ye & 8) {
                const st = T.dynamicProps;
                for (let rt = 0; rt < st.length; rt++) {
                    const D = st[rt],
                        k = _e[D],
                        le = Oe[D];
                    (le !== k || D === "value") && s(ce, D, k, le, $, C.children, z, Q, X)
                }
            }
            ye & 1 && C.children !== T.children && u(ce, T.children)
        } else !ge && se == null && E(ce, T, _e, Oe, z, Q, $);
        ((He = Oe.onVnodeUpdated) || Ce) && bn(() => {
            He && pr(He, z, T, C), Ce && qi(T, C, z, "updated")
        }, Q)
    }, A = (C, T, z, Q, $, ne, ge) => {
        for (let ce = 0; ce < T.length; ce++) {
            const ye = C[ce],
                se = T[ce],
                Ce = ye.el && (ye.type === Ye || !cs(ye, se) || ye.shapeFlag & 70) ? f(ye.el) : z;
            g(ye, se, Ce, null, Q, $, ne, ge, !0)
        }
    }, E = (C, T, z, Q, $, ne, ge) => {
        if (z !== Q) {
            if (z !== wt)
                for (const ce in z) !Rc(ce) && !(ce in Q) && s(C, ce, z[ce], null, ge, T.children, $, ne, X);
            for (const ce in Q) {
                if (Rc(ce)) continue;
                const ye = Q[ce],
                    se = z[ce];
                ye !== se && ce !== "value" && s(C, ce, se, ye, ge, T.children, $, ne, X)
            }
            "value" in Q && s(C, "value", z.value, Q.value)
        }
    }, P = (C, T, z, Q, $, ne, ge, ce, ye) => {
        const se = T.el = C ? C.el : a(""),
            Ce = T.anchor = C ? C.anchor : a("");
        let {
            patchFlag: _e,
            dynamicChildren: Oe,
            slotScopeIds: He
        } = T;
        He && (ce = ce ? ce.concat(He) : He), C == null ? (r(se, z, Q), r(Ce, z, Q), y(T.children, z, Ce, $, ne, ge, ce, ye)) : _e > 0 && _e & 64 && Oe && C.dynamicChildren ? (A(C.dynamicChildren, Oe, z, $, ne, ge, ce), (T.key != null || $ && T === $.subTree) && Cv(C, T, !0)) : B(C, T, z, Ce, $, ne, ge, ce, ye)
    }, R = (C, T, z, Q, $, ne, ge, ce, ye) => {
        T.slotScopeIds = ce, C == null ? T.shapeFlag & 512 ? $.ctx.activate(T, z, Q, ge, ye) : F(T, z, Q, $, ne, ge, ye) : _(C, T, ye)
    }, F = (C, T, z, Q, $, ne, ge) => {
        const ce = C.component = z_(C, Q, $);
        if (Tu(C) && (ce.ctx.renderer = ae), j_(ce), ce.asyncDep) {
            if ($ && $.registerDep(ce, S), !C.el) {
                const ye = ce.subTree = q(Gn);
                x(null, ye, T, z)
            }
            return
        }
        S(ce, C, T, z, $, ne, ge)
    }, _ = (C, T, z) => {
        const Q = T.component = C.component;
        if (Zk(C, T, z))
            if (Q.asyncDep && !Q.asyncResolved) {
                I(Q, T, z);
                return
            } else Q.next = T, Vk(Q.update), Q.update();
        else T.el = C.el, Q.vnode = T
    }, S = (C, T, z, Q, $, ne, ge) => {
        const ce = () => {
                if (C.isMounted) {
                    let {
                        next: Ce,
                        bu: _e,
                        u: Oe,
                        parent: He,
                        vnode: Qe
                    } = C, st = Ce, rt;
                    $i(C, !1), Ce ? (Ce.el = Qe.el, I(C, Ce, ge)) : Ce = Qe, _e && Cc(_e), (rt = Ce.props && Ce.props.onVnodeBeforeUpdate) && pr(rt, He, Ce, Qe), $i(C, !0);
                    const D = _f(C),
                        k = C.subTree;
                    C.subTree = D, g(k, D, f(k.el), V(k), C, $, ne), Ce.el = D.el, st === null && Yk(C, D.el), Oe && bn(Oe, $), (rt = Ce.props && Ce.props.onVnodeUpdated) && bn(() => pr(rt, He, Ce, Qe), $)
                } else {
                    let Ce;
                    const {
                        el: _e,
                        props: Oe
                    } = T, {
                        bm: He,
                        m: Qe,
                        parent: st
                    } = C, rt = xa(T);
                    if ($i(C, !1), He && Cc(He), !rt && (Ce = Oe && Oe.onVnodeBeforeMount) && pr(Ce, st, T), $i(C, !0), _e && Fe) {
                        const D = () => {
                            C.subTree = _f(C), Fe(_e, C.subTree, C, $, null)
                        };
                        rt ? T.type.__asyncLoader().then(() => !C.isUnmounted && D()) : D()
                    } else {
                        const D = C.subTree = _f(C);
                        g(null, D, z, Q, C, $, ne), T.el = D.el
                    }
                    if (Qe && bn(Qe, $), !rt && (Ce = Oe && Oe.onVnodeMounted)) {
                        const D = T;
                        bn(() => pr(Ce, st, D), $)
                    }(T.shapeFlag & 256 || st && xa(st.vnode) && st.vnode.shapeFlag & 256) && C.a && bn(C.a, $), C.isMounted = !0, T = z = Q = null
                }
            },
            ye = C.effect = new Zh(ce, () => rp(se), C.scope),
            se = C.update = () => ye.run();
        se.id = C.uid, $i(C, !0), se()
    }, I = (C, T, z) => {
        T.component = C;
        const Q = C.vnode.props;
        C.vnode = T, C.next = null, S_(C, T.props, Q, z), C_(C, T.children, z), Qo(), Wm(), Jo()
    }, B = (C, T, z, Q, $, ne, ge, ce, ye = !1) => {
        const se = C && C.children,
            Ce = C ? C.shapeFlag : 0,
            _e = T.children,
            {
                patchFlag: Oe,
                shapeFlag: He
            } = T;
        if (Oe > 0) {
            if (Oe & 128) {
                Y(se, _e, z, Q, $, ne, ge, ce, ye);
                return
            } else if (Oe & 256) {
                j(se, _e, z, Q, $, ne, ge, ce, ye);
                return
            }
        }
        He & 8 ? (Ce & 16 && X(se, $, ne), _e !== se && u(z, _e)) : Ce & 16 ? He & 16 ? Y(se, _e, z, Q, $, ne, ge, ce, ye) : X(se, $, ne, !0) : (Ce & 8 && u(z, ""), He & 16 && y(_e, z, Q, $, ne, ge, ce, ye))
    }, j = (C, T, z, Q, $, ne, ge, ce, ye) => {
        C = C || go, T = T || go;
        const se = C.length,
            Ce = T.length,
            _e = Math.min(se, Ce);
        let Oe;
        for (Oe = 0; Oe < _e; Oe++) {
            const He = T[Oe] = ye ? Ni(T[Oe]) : vr(T[Oe]);
            g(C[Oe], He, z, null, $, ne, ge, ce, ye)
        }
        se > Ce ? X(C, $, ne, !0, !1, _e) : y(T, z, Q, $, ne, ge, ce, ye, _e)
    }, Y = (C, T, z, Q, $, ne, ge, ce, ye) => {
        let se = 0;
        const Ce = T.length;
        let _e = C.length - 1,
            Oe = Ce - 1;
        for (; se <= _e && se <= Oe;) {
            const He = C[se],
                Qe = T[se] = ye ? Ni(T[se]) : vr(T[se]);
            if (cs(He, Qe)) g(He, Qe, z, null, $, ne, ge, ce, ye);
            else break;
            se++
        }
        for (; se <= _e && se <= Oe;) {
            const He = C[_e],
                Qe = T[Oe] = ye ? Ni(T[Oe]) : vr(T[Oe]);
            if (cs(He, Qe)) g(He, Qe, z, null, $, ne, ge, ce, ye);
            else break;
            _e--, Oe--
        }
        if (se > _e) {
            if (se <= Oe) {
                const He = Oe + 1,
                    Qe = He < Ce ? T[He].el : Q;
                for (; se <= Oe;) g(null, T[se] = ye ? Ni(T[se]) : vr(T[se]), z, Qe, $, ne, ge, ce, ye), se++
            }
        } else if (se > Oe)
            for (; se <= _e;) he(C[se], $, ne, !0), se++;
        else {
            const He = se,
                Qe = se,
                st = new Map;
            for (se = Qe; se <= Oe; se++) {
                const je = T[se] = ye ? Ni(T[se]) : vr(T[se]);
                je.key != null && st.set(je.key, se)
            }
            let rt, D = 0;
            const k = Oe - Qe + 1;
            let le = !1,
                Ee = 0;
            const pe = new Array(k);
            for (se = 0; se < k; se++) pe[se] = 0;
            for (se = He; se <= _e; se++) {
                const je = C[se];
                if (D >= k) {
                    he(je, $, ne, !0);
                    continue
                }
                let et;
                if (je.key != null) et = st.get(je.key);
                else
                    for (rt = Qe; rt <= Oe; rt++)
                        if (pe[rt - Qe] === 0 && cs(je, T[rt])) {
                            et = rt;
                            break
                        }
                et === void 0 ? he(je, $, ne, !0) : (pe[et - Qe] = se + 1, et >= Ee ? Ee = et : le = !0, g(je, T[et], z, null, $, ne, ge, ce, ye), D++)
            }
            const Ie = le ? I_(pe) : go;
            for (rt = Ie.length - 1, se = k - 1; se >= 0; se--) {
                const je = Qe + se,
                    et = T[je],
                    mt = je + 1 < Ce ? T[je + 1].el : Q;
                pe[se] === 0 ? g(null, et, z, mt, $, ne, ge, ce, ye) : le && (rt < 0 || se !== Ie[rt] ? te(et, z, mt, 2) : rt--)
            }
        }
    }, te = (C, T, z, Q, $ = null) => {
        const {
            el: ne,
            type: ge,
            transition: ce,
            children: ye,
            shapeFlag: se
        } = C;
        if (se & 6) {
            te(C.component.subTree, T, z, Q);
            return
        }
        if (se & 128) {
            C.suspense.move(T, z, Q);
            return
        }
        if (se & 64) {
            ge.move(C, T, z, ae);
            return
        }
        if (ge === Ye) {
            r(ne, T, z);
            for (let _e = 0; _e < ye.length; _e++) te(ye[_e], T, z, Q);
            r(C.anchor, T, z);
            return
        }
        if (ge === ka) {
            O(C, T, z);
            return
        }
        if (Q !== 2 && se & 1 && ce)
            if (Q === 0) ce.beforeEnter(ne), r(ne, T, z), bn(() => ce.enter(ne), $);
            else {
                const {
                    leave: _e,
                    delayLeave: Oe,
                    afterLeave: He
                } = ce, Qe = () => r(ne, T, z), st = () => {
                    _e(ne, () => {
                        Qe(), He && He()
                    })
                };
                Oe ? Oe(ne, Qe, st) : st()
            }
        else r(ne, T, z)
    }, he = (C, T, z, Q = !1, $ = !1) => {
        const {
            type: ne,
            props: ge,
            ref: ce,
            children: ye,
            dynamicChildren: se,
            shapeFlag: Ce,
            patchFlag: _e,
            dirs: Oe
        } = C;
        if (ce != null && Hd(ce, null, z, C, !0), Ce & 256) {
            T.ctx.deactivate(C);
            return
        }
        const He = Ce & 1 && Oe,
            Qe = !xa(C);
        let st;
        if (Qe && (st = ge && ge.onVnodeBeforeUnmount) && pr(st, T, C), Ce & 6) ve(C.component, z, Q);
        else {
            if (Ce & 128) {
                C.suspense.unmount(z, Q);
                return
            }
            He && qi(C, null, T, "beforeUnmount"), Ce & 64 ? C.type.remove(C, T, z, $, ae, Q) : se && (ne !== Ye || _e > 0 && _e & 64) ? X(se, T, z, !1, !0) : (ne === Ye && _e & 384 || !$ && Ce & 16) && X(ye, T, z), Q && Te(C)
        }(Qe && (st = ge && ge.onVnodeUnmounted) || He) && bn(() => {
            st && pr(st, T, C), He && qi(C, null, T, "unmounted")
        }, z)
    }, Te = C => {
        const {
            type: T,
            el: z,
            anchor: Q,
            transition: $
        } = C;
        if (T === Ye) {
            Be(z, Q);
            return
        }
        if (T === ka) {
            N(C);
            return
        }
        const ne = () => {
            i(z), $ && !$.persisted && $.afterLeave && $.afterLeave()
        };
        if (C.shapeFlag & 1 && $ && !$.persisted) {
            const {
                leave: ge,
                delayLeave: ce
            } = $, ye = () => ge(z, ne);
            ce ? ce(C.el, ne, ye) : ye()
        } else ne()
    }, Be = (C, T) => {
        let z;
        for (; C !== T;) z = d(C), i(C), C = z;
        i(T)
    }, ve = (C, T, z) => {
        const {
            bum: Q,
            scope: $,
            update: ne,
            subTree: ge,
            um: ce
        } = C;
        Q && Cc(Q), $.stop(), ne && (ne.active = !1, he(ge, C, T, z)), ce && bn(ce, T), bn(() => {
            C.isUnmounted = !0
        }, T), T && T.pendingBranch && !T.isUnmounted && C.asyncDep && !C.asyncResolved && C.suspenseId === T.pendingId && (T.deps--, T.deps === 0 && T.resolve())
    }, X = (C, T, z, Q = !1, $ = !1, ne = 0) => {
        for (let ge = ne; ge < C.length; ge++) he(C[ge], T, z, Q, $)
    }, V = C => C.shapeFlag & 6 ? V(C.component.subTree) : C.shapeFlag & 128 ? C.suspense.next() : d(C.anchor || C.el), oe = (C, T, z) => {
        C == null ? T._vnode && he(T._vnode, null, null, !0) : g(T._vnode || null, C, T, null, null, null, z), Wm(), fv(), T._vnode = C
    }, ae = {
        p: g,
        um: he,
        m: te,
        r: Te,
        mt: F,
        mc: y,
        pc: B,
        pbc: A,
        n: V,
        o: t
    };
    let Ae, Fe;
    return e && ([Ae, Fe] = e(ae)), {
        render: oe,
        hydrate: Ae,
        createApp: E_(oe, Ae)
    }
}

function $i({
    effect: t,
    update: e
}, n) {
    t.allowRecurse = e.allowRecurse = n
}

function B_(t, e) {
    return (!t || t && !t.pendingBranch) && e && !e.persisted
}

function Cv(t, e, n = !1) {
    const r = t.children,
        i = e.children;
    if (Me(r) && Me(i))
        for (let s = 0; s < r.length; s++) {
            const o = r[s];
            let a = i[s];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = i[s] = Ni(i[s]), a.el = o.el), n || Cv(o, a)), a.type === Iu && (a.el = o.el)
        }
}

function I_(t) {
    const e = t.slice(),
        n = [0];
    let r, i, s, o, a;
    const c = t.length;
    for (r = 0; r < c; r++) {
        const l = t[r];
        if (l !== 0) {
            if (i = n[n.length - 1], t[i] < l) {
                e[r] = i, n.push(r);
                continue
            }
            for (s = 0, o = n.length - 1; s < o;) a = s + o >> 1, t[n[a]] < l ? s = a + 1 : o = a;
            l < t[n[s]] && (s > 0 && (e[r] = n[s - 1]), n[s] = r)
        }
    }
    for (s = n.length, o = n[s - 1]; s-- > 0;) n[s] = o, o = e[o];
    return n
}
const D_ = t => t.__isTeleport,
    Ye = Symbol.for("v-fgt"),
    Iu = Symbol.for("v-txt"),
    Gn = Symbol.for("v-cmt"),
    ka = Symbol.for("v-stc"),
    _a = [];
let ar = null;

function fe(t = !1) {
    _a.push(ar = t ? null : [])
}

function L_() {
    _a.pop(), ar = _a[_a.length - 1] || null
}
let Ha = 1;

function i0(t) {
    Ha += t
}

function Ov(t) {
    return t.dynamicChildren = Ha > 0 ? ar || go : null, L_(), Ha > 0 && ar && ar.push(t), t
}

function be(t, e, n, r, i, s) {
    return Ov(m(t, e, n, r, i, s, !0))
}

function fi(t, e, n, r, i) {
    return Ov(q(t, e, n, r, i, !0))
}

function qc(t) {
    return t ? t.__v_isVNode === !0 : !1
}

function cs(t, e) {
    return t.type === e.type && t.key === e.key
}
const Du = "__vInternal",
    Tv = ({
        key: t
    }) => t ? ? null,
    Oc = ({
        ref: t,
        ref_key: e,
        ref_for: n
    }) => (typeof t == "number" && (t = "" + t), t != null ? zt(t) || pt(t) || We(t) ? {
        i: rn,
        r: t,
        k: e,
        f: !!n
    } : t : null);

function m(t, e = null, n = null, r = 0, i = null, s = t === Ye ? 0 : 1, o = !1, a = !1) {
    const c = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t,
        props: e,
        key: e && Tv(e),
        ref: e && Oc(e),
        scopeId: pv,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: r,
        dynamicProps: i,
        dynamicChildren: null,
        appContext: null,
        ctx: rn
    };
    return a ? (lp(c, n), s & 128 && t.normalize(c)) : n && (c.shapeFlag |= zt(n) ? 8 : 16), Ha > 0 && !o && ar && (c.patchFlag > 0 || s & 6) && c.patchFlag !== 32 && ar.push(c), c
}
const q = M_;

function M_(t, e = null, n = null, r = 0, i = null, s = !1) {
    if ((!t || t === mv) && (t = Gn), qc(t)) {
        const a = ii(t, e, !0);
        return n && lp(a, n), Ha > 0 && !s && ar && (a.shapeFlag & 6 ? ar[ar.indexOf(t)] = a : ar.push(a)), a.patchFlag |= -2, a
    }
    if (Q_(t) && (t = t.__vccOpts), e) {
        e = F_(e);
        let {
            class: a,
            style: c
        } = e;
        a && !zt(a) && (e.class = Rt(a)), gt(c) && (rv(c) && !Me(c) && (c = Jt({}, c)), e.style = Eu(c))
    }
    const o = zt(t) ? 1 : $k(t) ? 128 : D_(t) ? 64 : gt(t) ? 4 : We(t) ? 2 : 0;
    return m(t, e, n, r, i, o, s, !0)
}

function F_(t) {
    return t ? rv(t) || Du in t ? Jt({}, t) : t : null
}

function ii(t, e, n = !1) {
    const {
        props: r,
        ref: i,
        patchFlag: s,
        children: o
    } = t, a = e ? Bv(r || {}, e) : r;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t.type,
        props: a,
        key: a && Tv(a),
        ref: e && e.ref ? n && i ? Me(i) ? i.concat(Oc(e)) : [i, Oc(e)] : Oc(e) : i,
        scopeId: t.scopeId,
        slotScopeIds: t.slotScopeIds,
        children: o,
        target: t.target,
        targetAnchor: t.targetAnchor,
        staticCount: t.staticCount,
        shapeFlag: t.shapeFlag,
        patchFlag: e && t.type !== Ye ? s === -1 ? 16 : s | 16 : s,
        dynamicProps: t.dynamicProps,
        dynamicChildren: t.dynamicChildren,
        appContext: t.appContext,
        dirs: t.dirs,
        transition: t.transition,
        component: t.component,
        suspense: t.suspense,
        ssContent: t.ssContent && ii(t.ssContent),
        ssFallback: t.ssFallback && ii(t.ssFallback),
        el: t.el,
        anchor: t.anchor,
        ctx: t.ctx,
        ce: t.ce
    }
}

function Ke(t = " ", e = 0) {
    return q(Iu, null, t, e)
}

function Ko(t, e) {
    const n = q(ka, null, t);
    return n.staticCount = e, n
}

function Ea(t = "", e = !1) {
    return e ? (fe(), fi(Gn, null, t)) : q(Gn, null, t)
}

function vr(t) {
    return t == null || typeof t == "boolean" ? q(Gn) : Me(t) ? q(Ye, null, t.slice()) : typeof t == "object" ? Ni(t) : q(Iu, null, String(t))
}

function Ni(t) {
    return t.el === null && t.patchFlag !== -1 || t.memo ? t : ii(t)
}

function lp(t, e) {
    let n = 0;
    const {
        shapeFlag: r
    } = t;
    if (e == null) e = null;
    else if (Me(e)) n = 16;
    else if (typeof e == "object")
        if (r & 65) {
            const i = e.default;
            i && (i._c && (i._d = !1), lp(t, i()), i._c && (i._d = !0));
            return
        } else {
            n = 32;
            const i = e._;
            !i && !(Du in e) ? e._ctx = rn : i === 3 && rn && (rn.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024))
        }
    else We(e) ? (e = {
        default: e,
        _ctx: rn
    }, n = 32) : (e = String(e), r & 64 ? (n = 16, e = [Ke(e)]) : n = 8);
    t.children = e, t.shapeFlag |= n
}

function Bv(...t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        for (const i in r)
            if (i === "class") e.class !== r.class && (e.class = Rt([e.class, r.class]));
            else if (i === "style") e.style = Eu([e.style, r.style]);
        else if (xu(i)) {
            const s = e[i],
                o = r[i];
            o && s !== o && !(Me(s) && s.includes(o)) && (e[i] = s ? [].concat(s, o) : o)
        } else i !== "" && (e[i] = r[i])
    }
    return e
}

function pr(t, e, n, r = null) {
    Vn(t, e, 7, [n, r])
}
const U_ = _v();
let H_ = 0;

function z_(t, e, n) {
    const r = t.type,
        i = (e ? e.appContext : t.appContext) || U_,
        s = {
            uid: H_++,
            vnode: t,
            type: r,
            parent: e,
            appContext: i,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new lk(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: e ? e.provides : Object.create(i.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: Pv(r, i),
            emitsOptions: hv(r, i),
            emit: null,
            emitted: null,
            propsDefaults: wt,
            inheritAttrs: r.inheritAttrs,
            ctx: wt,
            data: wt,
            props: wt,
            attrs: wt,
            slots: wt,
            refs: wt,
            setupState: wt,
            setupContext: null,
            attrsProxy: null,
            slotsProxy: null,
            suspense: n,
            suspenseId: n ? n.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return s.ctx = {
        _: s
    }, s.root = e ? e.root : s, s.emit = Qk.bind(null, s), t.ce && t.ce(s), s
}
let qt = null;
const Zo = () => qt || rn;
let cp, Xs, s0 = "__VUE_INSTANCE_SETTERS__";
(Xs = Rd()[s0]) || (Xs = Rd()[s0] = []), Xs.push(t => qt = t), cp = t => {
    Xs.length > 1 ? Xs.forEach(e => e(t)) : Xs[0](t)
};
const No = t => {
        cp(t), t.scope.on()
    },
    ks = () => {
        qt && qt.scope.off(), cp(null)
    };

function Iv(t) {
    return t.vnode.shapeFlag & 4
}
let za = !1;

function j_(t, e = !1) {
    za = e;
    const {
        props: n,
        children: r
    } = t.vnode, i = Iv(t);
    P_(t, n, i, e), R_(t, r);
    const s = i ? V_(t, e) : void 0;
    return za = !1, s
}

function V_(t, e) {
    const n = t.type;
    t.accessCache = Object.create(null), t.proxy = iv(new Proxy(t.ctx, g_));
    const {
        setup: r
    } = n;
    if (r) {
        const i = t.setupContext = r.length > 1 ? Lv(t) : null;
        No(t), Qo();
        const s = Di(r, t, 0, [t.props, i]);
        if (Jo(), ks(), Uy(s)) {
            if (s.then(ks, ks), e) return s.then(o => {
                o0(t, o, e)
            }).catch(o => {
                Ru(o, t, 0)
            });
            t.asyncDep = s
        } else o0(t, s, e)
    } else Dv(t, e)
}

function o0(t, e, n) {
    We(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : gt(e) && (t.setupState = av(e)), Dv(t, n)
}
let a0;

function Dv(t, e, n) {
    const r = t.type;
    if (!t.render) {
        if (!e && a0 && !r.render) {
            const i = r.template || op(t).template;
            if (i) {
                const {
                    isCustomElement: s,
                    compilerOptions: o
                } = t.appContext.config, {
                    delimiters: a,
                    compilerOptions: c
                } = r, l = Jt(Jt({
                    isCustomElement: s,
                    delimiters: a
                }, o), c);
                r.render = a0(i, l)
            }
        }
        t.render = r.render || Er
    } {
        No(t), Qo();
        try {
            b_(t)
        } finally {
            Jo(), ks()
        }
    }
}

function G_(t) {
    return t.attrsProxy || (t.attrsProxy = new Proxy(t.attrs, {
        get(e, n) {
            return Pn(t, "get", "$attrs"), e[n]
        }
    }))
}

function Lv(t) {
    const e = n => {
        t.exposed = n || {}
    };
    return {
        get attrs() {
            return G_(t)
        },
        slots: t.slots,
        emit: t.emit,
        expose: e
    }
}

function Lu(t) {
    if (t.exposed) return t.exposeProxy || (t.exposeProxy = new Proxy(av(iv(t.exposed)), {
        get(e, n) {
            if (n in e) return e[n];
            if (n in Aa) return Aa[n](t)
        },
        has(e, n) {
            return n in e || n in Aa
        }
    }))
}

function W_(t, e = !0) {
    return We(t) ? t.displayName || t.name : t.name || e && t.__name
}

function Q_(t) {
    return We(t) && "__vccOpts" in t
}
const ze = (t, e) => Hk(t, e, za);

function Ns(t, e, n) {
    const r = arguments.length;
    return r === 2 ? gt(e) && !Me(e) ? qc(e) ? q(t, null, [e]) : q(t, e) : q(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && qc(n) && (n = [n]), q(t, e, n))
}
const J_ = Symbol.for("v-scx"),
    K_ = () => we(J_),
    Z_ = "3.3.8",
    Y_ = "http://www.w3.org/2000/svg",
    us = typeof document < "u" ? document : null,
    l0 = us && us.createElement("template"),
    X_ = {
        insert: (t, e, n) => {
            e.insertBefore(t, n || null)
        },
        remove: t => {
            const e = t.parentNode;
            e && e.removeChild(t)
        },
        createElement: (t, e, n, r) => {
            const i = e ? us.createElementNS(Y_, t) : us.createElement(t, n ? {
                is: n
            } : void 0);
            return t === "select" && r && r.multiple != null && i.setAttribute("multiple", r.multiple), i
        },
        createText: t => us.createTextNode(t),
        createComment: t => us.createComment(t),
        setText: (t, e) => {
            t.nodeValue = e
        },
        setElementText: (t, e) => {
            t.textContent = e
        },
        parentNode: t => t.parentNode,
        nextSibling: t => t.nextSibling,
        querySelector: t => us.querySelector(t),
        setScopeId(t, e) {
            t.setAttribute(e, "")
        },
        insertStaticContent(t, e, n, r, i, s) {
            const o = n ? n.previousSibling : e.lastChild;
            if (i && (i === s || i.nextSibling))
                for (; e.insertBefore(i.cloneNode(!0), n), !(i === s || !(i = i.nextSibling)););
            else {
                l0.innerHTML = r ? `<svg>${t}</svg>` : t;
                const a = l0.content;
                if (r) {
                    const c = a.firstChild;
                    for (; c.firstChild;) a.appendChild(c.firstChild);
                    a.removeChild(c)
                }
                e.insertBefore(a, n)
            }
            return [o ? o.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild]
        }
    },
    gi = "transition",
    ia = "animation",
    ja = Symbol("_vtc"),
    up = (t, {
        slots: e
    }) => Ns(s_, q_(t), e);
up.displayName = "Transition";
const Mv = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
up.props = Jt({}, vv, Mv);
const es = (t, e = []) => {
        Me(t) ? t.forEach(n => n(...e)) : t && t(...e)
    },
    c0 = t => t ? Me(t) ? t.some(e => e.length > 1) : t.length > 1 : !1;

function q_(t) {
    const e = {};
    for (const P in t) P in Mv || (e[P] = t[P]);
    if (t.css === !1) return e;
    const {
        name: n = "v",
        type: r,
        duration: i,
        enterFromClass: s = `${n}-enter-from`,
        enterActiveClass: o = `${n}-enter-active`,
        enterToClass: a = `${n}-enter-to`,
        appearFromClass: c = s,
        appearActiveClass: l = o,
        appearToClass: u = a,
        leaveFromClass: f = `${n}-leave-from`,
        leaveActiveClass: d = `${n}-leave-active`,
        leaveToClass: h = `${n}-leave-to`
    } = t, p = $_(i), g = p && p[0], b = p && p[1], {
        onBeforeEnter: x,
        onEnter: w,
        onEnterCancelled: O,
        onLeave: N,
        onLeaveCancelled: U,
        onBeforeAppear: H = x,
        onAppear: M = w,
        onAppearCancelled: y = O
    } = e, v = (P, R, F) => {
        ts(P, R ? u : a), ts(P, R ? l : o), F && F()
    }, A = (P, R) => {
        P._isLeaving = !1, ts(P, f), ts(P, h), ts(P, d), R && R()
    }, E = P => (R, F) => {
        const _ = P ? M : w,
            S = () => v(R, P, F);
        es(_, [R, S]), u0(() => {
            ts(R, P ? c : s), yi(R, P ? u : a), c0(_) || f0(R, r, g, S)
        })
    };
    return Jt(e, {
        onBeforeEnter(P) {
            es(x, [P]), yi(P, s), yi(P, o)
        },
        onBeforeAppear(P) {
            es(H, [P]), yi(P, c), yi(P, l)
        },
        onEnter: E(!1),
        onAppear: E(!0),
        onLeave(P, R) {
            P._isLeaving = !0;
            const F = () => A(P, R);
            yi(P, f), n4(), yi(P, d), u0(() => {
                P._isLeaving && (ts(P, f), yi(P, h), c0(N) || f0(P, r, b, F))
            }), es(N, [P, F])
        },
        onEnterCancelled(P) {
            v(P, !1), es(O, [P])
        },
        onAppearCancelled(P) {
            v(P, !0), es(y, [P])
        },
        onLeaveCancelled(P) {
            A(P), es(U, [P])
        }
    })
}

function $_(t) {
    if (t == null) return null;
    if (gt(t)) return [Sf(t.enter), Sf(t.leave)]; {
        const e = Sf(t);
        return [e, e]
    }
}

function Sf(t) {
    return $A(t)
}

function yi(t, e) {
    e.split(/\s+/).forEach(n => n && t.classList.add(n)), (t[ja] || (t[ja] = new Set)).add(e)
}

function ts(t, e) {
    e.split(/\s+/).forEach(r => r && t.classList.remove(r));
    const n = t[ja];
    n && (n.delete(e), n.size || (t[ja] = void 0))
}

function u0(t) {
    requestAnimationFrame(() => {
        requestAnimationFrame(t)
    })
}
let e4 = 0;

function f0(t, e, n, r) {
    const i = t._endId = ++e4,
        s = () => {
            i === t._endId && r()
        };
    if (n) return setTimeout(s, n);
    const {
        type: o,
        timeout: a,
        propCount: c
    } = t4(t, e);
    if (!o) return r();
    const l = o + "end";
    let u = 0;
    const f = () => {
            t.removeEventListener(l, d), s()
        },
        d = h => {
            h.target === t && ++u >= c && f()
        };
    setTimeout(() => {
        u < c && f()
    }, a + 1), t.addEventListener(l, d)
}

function t4(t, e) {
    const n = window.getComputedStyle(t),
        r = p => (n[p] || "").split(", "),
        i = r(`${gi}Delay`),
        s = r(`${gi}Duration`),
        o = d0(i, s),
        a = r(`${ia}Delay`),
        c = r(`${ia}Duration`),
        l = d0(a, c);
    let u = null,
        f = 0,
        d = 0;
    e === gi ? o > 0 && (u = gi, f = o, d = s.length) : e === ia ? l > 0 && (u = ia, f = l, d = c.length) : (f = Math.max(o, l), u = f > 0 ? o > l ? gi : ia : null, d = u ? u === gi ? s.length : c.length : 0);
    const h = u === gi && /\b(transform|all)(,|$)/.test(r(`${gi}Property`).toString());
    return {
        type: u,
        timeout: f,
        propCount: d,
        hasTransform: h
    }
}

function d0(t, e) {
    for (; t.length < e.length;) t = t.concat(t);
    return Math.max(...e.map((n, r) => h0(n) + h0(t[r])))
}

function h0(t) {
    return t === "auto" ? 0 : Number(t.slice(0, -1).replace(",", ".")) * 1e3
}

function n4() {
    return document.body.offsetHeight
}

function r4(t, e, n) {
    const r = t[ja];
    r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e
}
const fp = Symbol("_vod"),
    i4 = {
        beforeMount(t, {
            value: e
        }, {
            transition: n
        }) {
            t[fp] = t.style.display === "none" ? "" : t.style.display, n && e ? n.beforeEnter(t) : sa(t, e)
        },
        mounted(t, {
            value: e
        }, {
            transition: n
        }) {
            n && e && n.enter(t)
        },
        updated(t, {
            value: e,
            oldValue: n
        }, {
            transition: r
        }) {
            !e != !n && (r ? e ? (r.beforeEnter(t), sa(t, !0), r.enter(t)) : r.leave(t, () => {
                sa(t, !1)
            }) : sa(t, e))
        },
        beforeUnmount(t, {
            value: e
        }) {
            sa(t, e)
        }
    };

function sa(t, e) {
    t.style.display = e ? t[fp] : "none"
}

function s4(t, e, n) {
    const r = t.style,
        i = zt(n);
    if (n && !i) {
        if (e && !zt(e))
            for (const s in e) n[s] == null && zd(r, s, "");
        for (const s in n) zd(r, s, n[s])
    } else {
        const s = r.display;
        i ? e !== n && (r.cssText = n) : e && t.removeAttribute("style"), fp in t && (r.display = s)
    }
}
const p0 = /\s*!important$/;

function zd(t, e, n) {
    if (Me(n)) n.forEach(r => zd(t, e, r));
    else if (n == null && (n = ""), e.startsWith("--")) t.setProperty(e, n);
    else {
        const r = o4(t, e);
        p0.test(n) ? t.setProperty(Fs(r), n.replace(p0, ""), "important") : t[r] = n
    }
}
const m0 = ["Webkit", "Moz", "ms"],
    Nf = {};

function o4(t, e) {
    const n = Nf[e];
    if (n) return n;
    let r = Br(e);
    if (r !== "filter" && r in t) return Nf[e] = r;
    r = _u(r);
    for (let i = 0; i < m0.length; i++) {
        const s = m0[i] + r;
        if (s in t) return Nf[e] = s
    }
    return e
}
const g0 = "http://www.w3.org/1999/xlink";

function a4(t, e, n, r, i) {
    if (r && e.startsWith("xlink:")) n == null ? t.removeAttributeNS(g0, e.slice(6, e.length)) : t.setAttributeNS(g0, e, n);
    else {
        const s = sk(e);
        n == null || s && !Vy(n) ? t.removeAttribute(e) : t.setAttribute(e, s ? "" : n)
    }
}

function l4(t, e, n, r, i, s, o) {
    if (e === "innerHTML" || e === "textContent") {
        r && o(r, i, s), t[e] = n ? ? "";
        return
    }
    const a = t.tagName;
    if (e === "value" && a !== "PROGRESS" && !a.includes("-")) {
        t._value = n;
        const l = a === "OPTION" ? t.getAttribute("value") : t.value,
            u = n ? ? "";
        l !== u && (t.value = u), n == null && t.removeAttribute(e);
        return
    }
    let c = !1;
    if (n === "" || n == null) {
        const l = typeof t[e];
        l === "boolean" ? n = Vy(n) : n == null && l === "string" ? (n = "", c = !0) : l === "number" && (n = 0, c = !0)
    }
    try {
        t[e] = n
    } catch {}
    c && t.removeAttribute(e)
}

function Fv(t, e, n, r) {
    t.addEventListener(e, n, r)
}

function c4(t, e, n, r) {
    t.removeEventListener(e, n, r)
}
const y0 = Symbol("_vei");

function u4(t, e, n, r, i = null) {
    const s = t[y0] || (t[y0] = {}),
        o = s[e];
    if (r && o) o.value = r;
    else {
        const [a, c] = f4(e);
        if (r) {
            const l = s[e] = p4(r, i);
            Fv(t, a, l, c)
        } else o && (c4(t, a, o, c), s[e] = void 0)
    }
}
const v0 = /(?:Once|Passive|Capture)$/;

function f4(t) {
    let e;
    if (v0.test(t)) {
        e = {};
        let r;
        for (; r = t.match(v0);) t = t.slice(0, t.length - r[0].length), e[r[0].toLowerCase()] = !0
    }
    return [t[2] === ":" ? t.slice(3) : Fs(t.slice(2)), e]
}
let Rf = 0;
const d4 = Promise.resolve(),
    h4 = () => Rf || (d4.then(() => Rf = 0), Rf = Date.now());

function p4(t, e) {
    const n = r => {
        if (!r._vts) r._vts = Date.now();
        else if (r._vts <= n.attached) return;
        Vn(m4(r, n.value), e, 5, [r])
    };
    return n.value = t, n.attached = h4(), n
}

function m4(t, e) {
    if (Me(e)) {
        const n = t.stopImmediatePropagation;
        return t.stopImmediatePropagation = () => {
            n.call(t), t._stopped = !0
        }, e.map(r => i => !i._stopped && r && r(i))
    } else return e
}
const b0 = /^on[a-z]/,
    g4 = (t, e, n, r, i = !1, s, o, a, c) => {
        e === "class" ? r4(t, r, i) : e === "style" ? s4(t, n, r) : xu(e) ? Wh(e) || u4(t, e, n, r, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : y4(t, e, r, i)) ? l4(t, e, r, s, o, a, c) : (e === "true-value" ? t._trueValue = r : e === "false-value" && (t._falseValue = r), a4(t, e, r, i))
    };

function y4(t, e, n, r) {
    return r ? !!(e === "innerHTML" || e === "textContent" || e in t && b0.test(e) && We(n)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || b0.test(e) && zt(n) ? !1 : e in t
}

function v4(t) {
    const e = Zo();
    if (!e) return;
    const n = e.ut = (i = t(e.proxy)) => {
            Array.from(document.querySelectorAll(`[data-v-owner="${e.uid}"]`)).forEach(s => Vd(s, i))
        },
        r = () => {
            const i = t(e.proxy);
            jd(e.subTree, i), n(i)
        };
    t_(r), sn(() => {
        const i = new MutationObserver(r);
        i.observe(e.subTree.el.parentNode, {
            childList: !0
        }), Us(() => i.disconnect())
    })
}

function jd(t, e) {
    if (t.shapeFlag & 128) {
        const n = t.suspense;
        t = n.activeBranch, n.pendingBranch && !n.isHydrating && n.effects.push(() => {
            jd(n.activeBranch, e)
        })
    }
    for (; t.component;) t = t.component.subTree;
    if (t.shapeFlag & 1 && t.el) Vd(t.el, e);
    else if (t.type === Ye) t.children.forEach(n => jd(n, e));
    else if (t.type === ka) {
        let {
            el: n,
            anchor: r
        } = t;
        for (; n && (Vd(n, e), n !== r);) n = n.nextSibling
    }
}

function Vd(t, e) {
    if (t.nodeType === 1) {
        const n = t.style;
        for (const r in e) n.setProperty(`--${r}`, e[r])
    }
}
const w0 = t => {
        const e = t.props["onUpdate:modelValue"] || !1;
        return Me(e) ? n => Cc(e, n) : e
    },
    Cf = Symbol("_assign"),
    b4 = {
        deep: !0,
        created(t, {
            value: e,
            modifiers: {
                number: n
            }
        }, r) {
            const i = Au(e);
            Fv(t, "change", () => {
                const s = Array.prototype.filter.call(t.options, o => o.selected).map(o => n ? jy($c(o)) : $c(o));
                t[Cf](t.multiple ? i ? new Set(s) : s : s[0])
            }), t[Cf] = w0(r)
        },
        mounted(t, {
            value: e
        }) {
            x0(t, e)
        },
        beforeUpdate(t, e, n) {
            t[Cf] = w0(n)
        },
        updated(t, {
            value: e
        }) {
            x0(t, e)
        }
    };

function x0(t, e) {
    const n = t.multiple;
    if (!(n && !Me(e) && !Au(e))) {
        for (let r = 0, i = t.options.length; r < i; r++) {
            const s = t.options[r],
                o = $c(s);
            if (n) Me(e) ? s.selected = ak(e, o) > -1 : s.selected = e.has(o);
            else if (Pu($c(s), e)) {
                t.selectedIndex !== r && (t.selectedIndex = r);
                return
            }
        }!n && t.selectedIndex !== -1 && (t.selectedIndex = -1)
    }
}

function $c(t) {
    return "_value" in t ? t._value : t.value
}
const w4 = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
    },
    x4 = (t, e) => n => {
        if (!("key" in n)) return;
        const r = Fs(n.key);
        if (e.some(i => i === r || w4[i] === r)) return t(n)
    },
    A4 = Jt({
        patchProp: g4
    }, X_);
let A0;

function k4() {
    return A0 || (A0 = O_(A4))
}
const _4 = (...t) => {
    const e = k4().createApp(...t),
        {
            mount: n
        } = e;
    return e.mount = r => {
        const i = E4(r);
        if (!i) return;
        const s = e._component;
        !We(s) && !s.render && !s.template && (s.template = i.innerHTML), i.innerHTML = "";
        const o = n(i, !1, i instanceof SVGElement);
        return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), o
    }, e
};

function E4(t) {
    return zt(t) ? document.querySelector(t) : t
}

function bl(t) {
    return Wy() ? (uk(t), !0) : !1
}

function Pr(t) {
    return typeof t == "function" ? t() : J(t)
}
const dp = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const Uv = t => t != null,
    P4 = Object.prototype.toString,
    Hv = t => P4.call(t) === "[object Object]",
    ti = () => {},
    k0 = S4();

function S4() {
    var t;
    return dp && ((t = window ? .navigator) == null ? void 0 : t.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent)
}

function N4(t, e) {
    function n(...r) {
        return new Promise((i, s) => {
            Promise.resolve(t(() => e.apply(this, r), {
                fn: e,
                thisArg: this,
                args: r
            })).then(i).catch(s)
        })
    }
    return n
}
const zv = t => t();

function R4(t = zv) {
    const e = Z(!0);

    function n() {
        e.value = !1
    }

    function r() {
        e.value = !0
    }
    const i = (...s) => {
        e.value && t(...s)
    };
    return {
        isActive: Nu(e),
        pause: n,
        resume: r,
        eventFilter: i
    }
}
const C4 = {
    mounted: "mounted",
    updated: "updated",
    unmounted: "unmounted"
};

function O4(...t) {
    if (t.length !== 1) return Fk(...t);
    const e = t[0];
    return typeof e == "function" ? Nu(Dk(() => ({
        get: e,
        set: ti
    }))) : Z(e)
}

function T4(t, e, n = {}) {
    const {
        eventFilter: r = zv,
        ...i
    } = n;
    return Xe(t, N4(r, e), i)
}

function B4(t, e, n = {}) {
    const {
        eventFilter: r,
        ...i
    } = n, {
        eventFilter: s,
        pause: o,
        resume: a,
        isActive: c
    } = R4(r);
    return {
        stop: T4(t, e, { ...i,
            eventFilter: s
        }),
        pause: o,
        resume: a,
        isActive: c
    }
}

function I4(t, e = !0) {
    Zo() ? sn(t) : e ? t() : yl(t)
}

function Tc(t) {
    var e;
    const n = Pr(t);
    return (e = n ? .$el) != null ? e : n
}
const eu = dp ? window : void 0;

function _0(...t) {
    let e, n, r, i;
    if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([n, r, i] = t, e = eu) : [e, n, r, i] = t, !e) return ti;
    Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
    const s = [],
        o = () => {
            s.forEach(u => u()), s.length = 0
        },
        a = (u, f, d, h) => (u.addEventListener(f, d, h), () => u.removeEventListener(f, d, h)),
        c = Xe(() => [Tc(e), Pr(i)], ([u, f]) => {
            if (o(), !u) return;
            const d = Hv(f) ? { ...f
            } : f;
            s.push(...n.flatMap(h => r.map(p => a(u, h, p, d))))
        }, {
            immediate: !0,
            flush: "post"
        }),
        l = () => {
            c(), o()
        };
    return bl(l), l
}

function D4() {
    const t = Z(!1);
    return Zo() && sn(() => {
        t.value = !0
    }), t
}

function L4(t) {
    const e = D4();
    return ze(() => (e.value, !!t()))
}
const ql = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
    $l = "__vueuse_ssr_handlers__",
    M4 = F4();

function F4() {
    return $l in ql || (ql[$l] = ql[$l] || {}), ql[$l]
}

function U4(t, e) {
    return M4[t] || e
}

function H4(t) {
    return t == null ? "any" : t instanceof Set ? "set" : t instanceof Map ? "map" : t instanceof Date ? "date" : typeof t == "boolean" ? "boolean" : typeof t == "string" ? "string" : typeof t == "object" ? "object" : Number.isNaN(t) ? "any" : "number"
}
const z4 = {
        boolean: {
            read: t => t === "true",
            write: t => String(t)
        },
        object: {
            read: t => JSON.parse(t),
            write: t => JSON.stringify(t)
        },
        number: {
            read: t => Number.parseFloat(t),
            write: t => String(t)
        },
        any: {
            read: t => t,
            write: t => String(t)
        },
        string: {
            read: t => t,
            write: t => String(t)
        },
        map: {
            read: t => new Map(JSON.parse(t)),
            write: t => JSON.stringify(Array.from(t.entries()))
        },
        set: {
            read: t => new Set(JSON.parse(t)),
            write: t => JSON.stringify(Array.from(t))
        },
        date: {
            read: t => new Date(t),
            write: t => t.toISOString()
        }
    },
    E0 = "vueuse-storage";

function j4(t, e, n, r = {}) {
    var i;
    const {
        flush: s = "pre",
        deep: o = !0,
        listenToStorageChanges: a = !0,
        writeDefaults: c = !0,
        mergeDefaults: l = !1,
        shallow: u,
        window: f = eu,
        eventFilter: d,
        onError: h = v => {
            console.error(v)
        },
        initOnMounted: p
    } = r, g = (u ? sv : Z)(typeof e == "function" ? e() : e);
    if (!n) try {
        n = U4("getDefaultStorage", () => {
            var v;
            return (v = eu) == null ? void 0 : v.localStorage
        })()
    } catch (v) {
        h(v)
    }
    if (!n) return g;
    const b = Pr(e),
        x = H4(b),
        w = (i = r.serializer) != null ? i : z4[x],
        {
            pause: O,
            resume: N
        } = B4(g, () => U(g.value), {
            flush: s,
            deep: o,
            eventFilter: d
        });
    return f && a && I4(() => {
        _0(f, "storage", y), _0(f, E0, M), p && y()
    }), p || y(), g;

    function U(v) {
        try {
            if (v == null) n.removeItem(t);
            else {
                const A = w.write(v),
                    E = n.getItem(t);
                E !== A && (n.setItem(t, A), f && f.dispatchEvent(new CustomEvent(E0, {
                    detail: {
                        key: t,
                        oldValue: E,
                        newValue: A,
                        storageArea: n
                    }
                })))
            }
        } catch (A) {
            h(A)
        }
    }

    function H(v) {
        const A = v ? v.newValue : n.getItem(t);
        if (A == null) return c && b !== null && n.setItem(t, w.write(b)), b;
        if (!v && l) {
            const E = w.read(A);
            return typeof l == "function" ? l(E, b) : x === "object" && !Array.isArray(E) ? { ...b,
                ...E
            } : E
        } else return typeof A != "string" ? A : w.read(A)
    }

    function M(v) {
        y(v.detail)
    }

    function y(v) {
        if (!(v && v.storageArea !== n)) {
            if (v && v.key == null) {
                g.value = b;
                return
            }
            if (!(v && v.key !== t)) {
                O();
                try {
                    v ? .newValue !== w.write(g.value) && (g.value = H(v))
                } catch (A) {
                    h(A)
                } finally {
                    v ? yl(N) : N()
                }
            }
        }
    }
}

function V4(t, e, n = {}) {
    const {
        root: r,
        rootMargin: i = "0px",
        threshold: s = .1,
        window: o = eu,
        immediate: a = !0
    } = n, c = L4(() => o && "IntersectionObserver" in o), l = ze(() => {
        const p = Pr(t);
        return (Array.isArray(p) ? p : [p]).map(Tc).filter(Uv)
    });
    let u = ti;
    const f = Z(a),
        d = c.value ? Xe(() => [l.value, Tc(r), f.value], ([p, g]) => {
            if (u(), !f.value || !p.length) return;
            const b = new IntersectionObserver(e, {
                root: Tc(g),
                rootMargin: i,
                threshold: s
            });
            p.forEach(x => x && b.observe(x)), u = () => {
                b.disconnect(), u = ti
            }
        }, {
            immediate: a,
            flush: "post"
        }) : ti,
        h = () => {
            u(), d(), f.value = !1
        };
    return bl(h), {
        isSupported: c,
        isActive: f,
        pause() {
            u(), f.value = !1
        },
        resume() {
            f.value = !0
        },
        stop: h
    }
}
/*!
 * vue-router v4.2.5
 * (c) 2023 Eduardo San Martin Morote
 * @license MIT
 */
const io = typeof window < "u";

function G4(t) {
    return t.__esModule || t[Symbol.toStringTag] === "Module"
}
const ht = Object.assign;

function Of(t, e) {
    const n = {};
    for (const r in e) {
        const i = e[r];
        n[r] = cr(i) ? i.map(t) : t(i)
    }
    return n
}
const Pa = () => {},
    cr = Array.isArray,
    W4 = /\/$/,
    Q4 = t => t.replace(W4, "");

function Tf(t, e, n = "/") {
    let r, i = {},
        s = "",
        o = "";
    const a = e.indexOf("#");
    let c = e.indexOf("?");
    return a < c && a >= 0 && (c = -1), c > -1 && (r = e.slice(0, c), s = e.slice(c + 1, a > -1 ? a : e.length), i = t(s)), a > -1 && (r = r || e.slice(0, a), o = e.slice(a, e.length)), r = Y4(r ? ? e, n), {
        fullPath: r + (s && "?") + s + o,
        path: r,
        query: i,
        hash: o
    }
}

function J4(t, e) {
    const n = e.query ? t(e.query) : "";
    return e.path + (n && "?") + n + (e.hash || "")
}

function P0(t, e) {
    return !e || !t.toLowerCase().startsWith(e.toLowerCase()) ? t : t.slice(e.length) || "/"
}

function K4(t, e, n) {
    const r = e.matched.length - 1,
        i = n.matched.length - 1;
    return r > -1 && r === i && Ro(e.matched[r], n.matched[i]) && jv(e.params, n.params) && t(e.query) === t(n.query) && e.hash === n.hash
}

function Ro(t, e) {
    return (t.aliasOf || t) === (e.aliasOf || e)
}

function jv(t, e) {
    if (Object.keys(t).length !== Object.keys(e).length) return !1;
    for (const n in t)
        if (!Z4(t[n], e[n])) return !1;
    return !0
}

function Z4(t, e) {
    return cr(t) ? S0(t, e) : cr(e) ? S0(e, t) : t === e
}

function S0(t, e) {
    return cr(e) ? t.length === e.length && t.every((n, r) => n === e[r]) : t.length === 1 && t[0] === e
}

function Y4(t, e) {
    if (t.startsWith("/")) return t;
    if (!t) return e;
    const n = e.split("/"),
        r = t.split("/"),
        i = r[r.length - 1];
    (i === ".." || i === ".") && r.push("");
    let s = n.length - 1,
        o, a;
    for (o = 0; o < r.length; o++)
        if (a = r[o], a !== ".")
            if (a === "..") s > 1 && s--;
            else break;
    return n.slice(0, s).join("/") + "/" + r.slice(o - (o === r.length ? 1 : 0)).join("/")
}
var Va;
(function(t) {
    t.pop = "pop", t.push = "push"
})(Va || (Va = {}));
var Sa;
(function(t) {
    t.back = "back", t.forward = "forward", t.unknown = ""
})(Sa || (Sa = {}));

function X4(t) {
    if (!t)
        if (io) {
            const e = document.querySelector("base");
            t = e && e.getAttribute("href") || "/", t = t.replace(/^\w+:\/\/[^\/]+/, "")
        } else t = "/";
    return t[0] !== "/" && t[0] !== "#" && (t = "/" + t), Q4(t)
}
const q4 = /^[^#]+#/;

function $4(t, e) {
    return t.replace(q4, "#") + e
}

function e3(t, e) {
    const n = document.documentElement.getBoundingClientRect(),
        r = t.getBoundingClientRect();
    return {
        behavior: e.behavior,
        left: r.left - n.left - (e.left || 0),
        top: r.top - n.top - (e.top || 0)
    }
}
const Mu = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset
});

function t3(t) {
    let e;
    if ("el" in t) {
        const n = t.el,
            r = typeof n == "string" && n.startsWith("#"),
            i = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!i) return;
        e = e3(i, t)
    } else e = t;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.pageXOffset, e.top != null ? e.top : window.pageYOffset)
}

function N0(t, e) {
    return (history.state ? history.state.position - e : -1) + t
}
const Gd = new Map;

function n3(t, e) {
    Gd.set(t, e)
}

function r3(t) {
    const e = Gd.get(t);
    return Gd.delete(t), e
}
let i3 = () => location.protocol + "//" + location.host;

function Vv(t, e) {
    const {
        pathname: n,
        search: r,
        hash: i
    } = e, s = t.indexOf("#");
    if (s > -1) {
        let a = i.includes(t.slice(s)) ? t.slice(s).length : 1,
            c = i.slice(a);
        return c[0] !== "/" && (c = "/" + c), P0(c, "")
    }
    return P0(n, t) + r + i
}

function s3(t, e, n, r) {
    let i = [],
        s = [],
        o = null;
    const a = ({
        state: d
    }) => {
        const h = Vv(t, location),
            p = n.value,
            g = e.value;
        let b = 0;
        if (d) {
            if (n.value = h, e.value = d, o && o === p) {
                o = null;
                return
            }
            b = g ? d.position - g.position : 0
        } else r(h);
        i.forEach(x => {
            x(n.value, p, {
                delta: b,
                type: Va.pop,
                direction: b ? b > 0 ? Sa.forward : Sa.back : Sa.unknown
            })
        })
    };

    function c() {
        o = n.value
    }

    function l(d) {
        i.push(d);
        const h = () => {
            const p = i.indexOf(d);
            p > -1 && i.splice(p, 1)
        };
        return s.push(h), h
    }

    function u() {
        const {
            history: d
        } = window;
        d.state && d.replaceState(ht({}, d.state, {
            scroll: Mu()
        }), "")
    }

    function f() {
        for (const d of s) d();
        s = [], window.removeEventListener("popstate", a), window.removeEventListener("beforeunload", u)
    }
    return window.addEventListener("popstate", a), window.addEventListener("beforeunload", u, {
        passive: !0
    }), {
        pauseListeners: c,
        listen: l,
        destroy: f
    }
}

function R0(t, e, n, r = !1, i = !1) {
    return {
        back: t,
        current: e,
        forward: n,
        replaced: r,
        position: window.history.length,
        scroll: i ? Mu() : null
    }
}

function o3(t) {
    const {
        history: e,
        location: n
    } = window, r = {
        value: Vv(t, n)
    }, i = {
        value: e.state
    };
    i.value || s(r.value, {
        back: null,
        current: r.value,
        forward: null,
        position: e.length - 1,
        replaced: !0,
        scroll: null
    }, !0);

    function s(c, l, u) {
        const f = t.indexOf("#"),
            d = f > -1 ? (n.host && document.querySelector("base") ? t : t.slice(f)) + c : i3() + t + c;
        try {
            e[u ? "replaceState" : "pushState"](l, "", d), i.value = l
        } catch (h) {
            console.error(h), n[u ? "replace" : "assign"](d)
        }
    }

    function o(c, l) {
        const u = ht({}, e.state, R0(i.value.back, c, i.value.forward, !0), l, {
            position: i.value.position
        });
        s(c, u, !0), r.value = c
    }

    function a(c, l) {
        const u = ht({}, i.value, e.state, {
            forward: c,
            scroll: Mu()
        });
        s(u.current, u, !0);
        const f = ht({}, R0(r.value, c, null), {
            position: u.position + 1
        }, l);
        s(c, f, !1), r.value = c
    }
    return {
        location: r,
        state: i,
        push: a,
        replace: o
    }
}

function a3(t) {
    t = X4(t);
    const e = o3(t),
        n = s3(t, e.state, e.location, e.replace);

    function r(s, o = !0) {
        o || n.pauseListeners(), history.go(s)
    }
    const i = ht({
        location: "",
        base: t,
        go: r,
        createHref: $4.bind(null, t)
    }, e, n);
    return Object.defineProperty(i, "location", {
        enumerable: !0,
        get: () => e.location.value
    }), Object.defineProperty(i, "state", {
        enumerable: !0,
        get: () => e.state.value
    }), i
}

function l3(t) {
    return typeof t == "string" || t && typeof t == "object"
}

function Gv(t) {
    return typeof t == "string" || typeof t == "symbol"
}
const vi = {
        path: "/",
        name: void 0,
        params: {},
        query: {},
        hash: "",
        fullPath: "/",
        matched: [],
        meta: {},
        redirectedFrom: void 0
    },
    Wv = Symbol("");
var C0;
(function(t) {
    t[t.aborted = 4] = "aborted", t[t.cancelled = 8] = "cancelled", t[t.duplicated = 16] = "duplicated"
})(C0 || (C0 = {}));

function Co(t, e) {
    return ht(new Error, {
        type: t,
        [Wv]: !0
    }, e)
}

function Hr(t, e) {
    return t instanceof Error && Wv in t && (e == null || !!(t.type & e))
}
const O0 = "[^/]+?",
    c3 = {
        sensitive: !1,
        strict: !1,
        start: !0,
        end: !0
    },
    u3 = /[.+*?^${}()[\]/\\]/g;

function f3(t, e) {
    const n = ht({}, c3, e),
        r = [];
    let i = n.start ? "^" : "";
    const s = [];
    for (const l of t) {
        const u = l.length ? [] : [90];
        n.strict && !l.length && (i += "/");
        for (let f = 0; f < l.length; f++) {
            const d = l[f];
            let h = 40 + (n.sensitive ? .25 : 0);
            if (d.type === 0) f || (i += "/"), i += d.value.replace(u3, "\\$&"), h += 40;
            else if (d.type === 1) {
                const {
                    value: p,
                    repeatable: g,
                    optional: b,
                    regexp: x
                } = d;
                s.push({
                    name: p,
                    repeatable: g,
                    optional: b
                });
                const w = x || O0;
                if (w !== O0) {
                    h += 10;
                    try {
                        new RegExp(`(${w})`)
                    } catch (N) {
                        throw new Error(`Invalid custom RegExp for param "${p}" (${w}): ` + N.message)
                    }
                }
                let O = g ? `((?:${w})(?:/(?:${w}))*)` : `(${w})`;
                f || (O = b && l.length < 2 ? `(?:/${O})` : "/" + O), b && (O += "?"), i += O, h += 20, b && (h += -8), g && (h += -20), w === ".*" && (h += -50)
            }
            u.push(h)
        }
        r.push(u)
    }
    if (n.strict && n.end) {
        const l = r.length - 1;
        r[l][r[l].length - 1] += .7000000000000001
    }
    n.strict || (i += "/?"), n.end ? i += "$" : n.strict && (i += "(?:/|$)");
    const o = new RegExp(i, n.sensitive ? "" : "i");

    function a(l) {
        const u = l.match(o),
            f = {};
        if (!u) return null;
        for (let d = 1; d < u.length; d++) {
            const h = u[d] || "",
                p = s[d - 1];
            f[p.name] = h && p.repeatable ? h.split("/") : h
        }
        return f
    }

    function c(l) {
        let u = "",
            f = !1;
        for (const d of t) {
            (!f || !u.endsWith("/")) && (u += "/"), f = !1;
            for (const h of d)
                if (h.type === 0) u += h.value;
                else if (h.type === 1) {
                const {
                    value: p,
                    repeatable: g,
                    optional: b
                } = h, x = p in l ? l[p] : "";
                if (cr(x) && !g) throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`);
                const w = cr(x) ? x.join("/") : x;
                if (!w)
                    if (b) d.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : f = !0);
                    else throw new Error(`Missing required param "${p}"`);
                u += w
            }
        }
        return u || "/"
    }
    return {
        re: o,
        score: r,
        keys: s,
        parse: a,
        stringify: c
    }
}

function d3(t, e) {
    let n = 0;
    for (; n < t.length && n < e.length;) {
        const r = e[n] - t[n];
        if (r) return r;
        n++
    }
    return t.length < e.length ? t.length === 1 && t[0] === 40 + 40 ? -1 : 1 : t.length > e.length ? e.length === 1 && e[0] === 40 + 40 ? 1 : -1 : 0
}

function h3(t, e) {
    let n = 0;
    const r = t.score,
        i = e.score;
    for (; n < r.length && n < i.length;) {
        const s = d3(r[n], i[n]);
        if (s) return s;
        n++
    }
    if (Math.abs(i.length - r.length) === 1) {
        if (T0(r)) return 1;
        if (T0(i)) return -1
    }
    return i.length - r.length
}

function T0(t) {
    const e = t[t.length - 1];
    return t.length > 0 && e[e.length - 1] < 0
}
const p3 = {
        type: 0,
        value: ""
    },
    m3 = /[a-zA-Z0-9_]/;

function g3(t) {
    if (!t) return [
        []
    ];
    if (t === "/") return [
        [p3]
    ];
    if (!t.startsWith("/")) throw new Error(`Invalid path "${t}"`);

    function e(h) {
        throw new Error(`ERR (${n})/"${l}": ${h}`)
    }
    let n = 0,
        r = n;
    const i = [];
    let s;

    function o() {
        s && i.push(s), s = []
    }
    let a = 0,
        c, l = "",
        u = "";

    function f() {
        l && (n === 0 ? s.push({
            type: 0,
            value: l
        }) : n === 1 || n === 2 || n === 3 ? (s.length > 1 && (c === "*" || c === "+") && e(`A repeatable param (${l}) must be alone in its segment. eg: '/:ids+.`), s.push({
            type: 1,
            value: l,
            regexp: u,
            repeatable: c === "*" || c === "+",
            optional: c === "*" || c === "?"
        })) : e("Invalid state to consume buffer"), l = "")
    }

    function d() {
        l += c
    }
    for (; a < t.length;) {
        if (c = t[a++], c === "\\" && n !== 2) {
            r = n, n = 4;
            continue
        }
        switch (n) {
            case 0:
                c === "/" ? (l && f(), o()) : c === ":" ? (f(), n = 1) : d();
                break;
            case 4:
                d(), n = r;
                break;
            case 1:
                c === "(" ? n = 2 : m3.test(c) ? d() : (f(), n = 0, c !== "*" && c !== "?" && c !== "+" && a--);
                break;
            case 2:
                c === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + c : n = 3 : u += c;
                break;
            case 3:
                f(), n = 0, c !== "*" && c !== "?" && c !== "+" && a--, u = "";
                break;
            default:
                e("Unknown state");
                break
        }
    }
    return n === 2 && e(`Unfinished custom RegExp for param "${l}"`), f(), o(), i
}

function y3(t, e, n) {
    const r = f3(g3(t.path), n),
        i = ht(r, {
            record: t,
            parent: e,
            children: [],
            alias: []
        });
    return e && !i.record.aliasOf == !e.record.aliasOf && e.children.push(i), i
}

function v3(t, e) {
    const n = [],
        r = new Map;
    e = D0({
        strict: !1,
        end: !0,
        sensitive: !1
    }, e);

    function i(u) {
        return r.get(u)
    }

    function s(u, f, d) {
        const h = !d,
            p = b3(u);
        p.aliasOf = d && d.record;
        const g = D0(e, u),
            b = [p];
        if ("alias" in u) {
            const O = typeof u.alias == "string" ? [u.alias] : u.alias;
            for (const N of O) b.push(ht({}, p, {
                components: d ? d.record.components : p.components,
                path: N,
                aliasOf: d ? d.record : p
            }))
        }
        let x, w;
        for (const O of b) {
            const {
                path: N
            } = O;
            if (f && N[0] !== "/") {
                const U = f.record.path,
                    H = U[U.length - 1] === "/" ? "" : "/";
                O.path = f.record.path + (N && H + N)
            }
            if (x = y3(O, f, g), d ? d.alias.push(x) : (w = w || x, w !== x && w.alias.push(x), h && u.name && !I0(x) && o(u.name)), p.children) {
                const U = p.children;
                for (let H = 0; H < U.length; H++) s(U[H], x, d && d.children[H])
            }
            d = d || x, (x.record.components && Object.keys(x.record.components).length || x.record.name || x.record.redirect) && c(x)
        }
        return w ? () => {
            o(w)
        } : Pa
    }

    function o(u) {
        if (Gv(u)) {
            const f = r.get(u);
            f && (r.delete(u), n.splice(n.indexOf(f), 1), f.children.forEach(o), f.alias.forEach(o))
        } else {
            const f = n.indexOf(u);
            f > -1 && (n.splice(f, 1), u.record.name && r.delete(u.record.name), u.children.forEach(o), u.alias.forEach(o))
        }
    }

    function a() {
        return n
    }

    function c(u) {
        let f = 0;
        for (; f < n.length && h3(u, n[f]) >= 0 && (u.record.path !== n[f].record.path || !Qv(u, n[f]));) f++;
        n.splice(f, 0, u), u.record.name && !I0(u) && r.set(u.record.name, u)
    }

    function l(u, f) {
        let d, h = {},
            p, g;
        if ("name" in u && u.name) {
            if (d = r.get(u.name), !d) throw Co(1, {
                location: u
            });
            g = d.record.name, h = ht(B0(f.params, d.keys.filter(w => !w.optional).map(w => w.name)), u.params && B0(u.params, d.keys.map(w => w.name))), p = d.stringify(h)
        } else if ("path" in u) p = u.path, d = n.find(w => w.re.test(p)), d && (h = d.parse(p), g = d.record.name);
        else {
            if (d = f.name ? r.get(f.name) : n.find(w => w.re.test(f.path)), !d) throw Co(1, {
                location: u,
                currentLocation: f
            });
            g = d.record.name, h = ht({}, f.params, u.params), p = d.stringify(h)
        }
        const b = [];
        let x = d;
        for (; x;) b.unshift(x.record), x = x.parent;
        return {
            name: g,
            path: p,
            params: h,
            matched: b,
            meta: x3(b)
        }
    }
    return t.forEach(u => s(u)), {
        addRoute: s,
        resolve: l,
        removeRoute: o,
        getRoutes: a,
        getRecordMatcher: i
    }
}

function B0(t, e) {
    const n = {};
    for (const r of e) r in t && (n[r] = t[r]);
    return n
}

function b3(t) {
    return {
        path: t.path,
        redirect: t.redirect,
        name: t.name,
        meta: t.meta || {},
        aliasOf: void 0,
        beforeEnter: t.beforeEnter,
        props: w3(t),
        children: t.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components" in t ? t.components || null : t.component && {
            default: t.component
        }
    }
}

function w3(t) {
    const e = {},
        n = t.props || !1;
    if ("component" in t) e.default = n;
    else
        for (const r in t.components) e[r] = typeof n == "object" ? n[r] : n;
    return e
}

function I0(t) {
    for (; t;) {
        if (t.record.aliasOf) return !0;
        t = t.parent
    }
    return !1
}

function x3(t) {
    return t.reduce((e, n) => ht(e, n.meta), {})
}

function D0(t, e) {
    const n = {};
    for (const r in t) n[r] = r in e ? e[r] : t[r];
    return n
}

function Qv(t, e) {
    return e.children.some(n => n === t || Qv(t, n))
}
const Jv = /#/g,
    A3 = /&/g,
    k3 = /\//g,
    _3 = /=/g,
    E3 = /\?/g,
    Kv = /\+/g,
    P3 = /%5B/g,
    S3 = /%5D/g,
    Zv = /%5E/g,
    N3 = /%60/g,
    Yv = /%7B/g,
    R3 = /%7C/g,
    Xv = /%7D/g,
    C3 = /%20/g;

function hp(t) {
    return encodeURI("" + t).replace(R3, "|").replace(P3, "[").replace(S3, "]")
}

function O3(t) {
    return hp(t).replace(Yv, "{").replace(Xv, "}").replace(Zv, "^")
}

function Wd(t) {
    return hp(t).replace(Kv, "%2B").replace(C3, "+").replace(Jv, "%23").replace(A3, "%26").replace(N3, "`").replace(Yv, "{").replace(Xv, "}").replace(Zv, "^")
}

function T3(t) {
    return Wd(t).replace(_3, "%3D")
}

function B3(t) {
    return hp(t).replace(Jv, "%23").replace(E3, "%3F")
}

function I3(t) {
    return t == null ? "" : B3(t).replace(k3, "%2F")
}

function tu(t) {
    try {
        return decodeURIComponent("" + t)
    } catch {}
    return "" + t
}

function D3(t) {
    const e = {};
    if (t === "" || t === "?") return e;
    const r = (t[0] === "?" ? t.slice(1) : t).split("&");
    for (let i = 0; i < r.length; ++i) {
        const s = r[i].replace(Kv, " "),
            o = s.indexOf("="),
            a = tu(o < 0 ? s : s.slice(0, o)),
            c = o < 0 ? null : tu(s.slice(o + 1));
        if (a in e) {
            let l = e[a];
            cr(l) || (l = e[a] = [l]), l.push(c)
        } else e[a] = c
    }
    return e
}

function L0(t) {
    let e = "";
    for (let n in t) {
        const r = t[n];
        if (n = T3(n), r == null) {
            r !== void 0 && (e += (e.length ? "&" : "") + n);
            continue
        }(cr(r) ? r.map(s => s && Wd(s)) : [r && Wd(r)]).forEach(s => {
            s !== void 0 && (e += (e.length ? "&" : "") + n, s != null && (e += "=" + s))
        })
    }
    return e
}

function L3(t) {
    const e = {};
    for (const n in t) {
        const r = t[n];
        r !== void 0 && (e[n] = cr(r) ? r.map(i => i == null ? null : "" + i) : r == null ? r : "" + r)
    }
    return e
}
const M3 = Symbol(""),
    M0 = Symbol(""),
    pp = Symbol(""),
    mp = Symbol(""),
    Qd = Symbol("");

function oa() {
    let t = [];

    function e(r) {
        return t.push(r), () => {
            const i = t.indexOf(r);
            i > -1 && t.splice(i, 1)
        }
    }

    function n() {
        t = []
    }
    return {
        add: e,
        list: () => t.slice(),
        reset: n
    }
}

function Ri(t, e, n, r, i) {
    const s = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || []);
    return () => new Promise((o, a) => {
        const c = f => {
                f === !1 ? a(Co(4, {
                    from: n,
                    to: e
                })) : f instanceof Error ? a(f) : l3(f) ? a(Co(2, {
                    from: e,
                    to: f
                })) : (s && r.enterCallbacks[i] === s && typeof f == "function" && s.push(f), o())
            },
            l = t.call(r && r.instances[i], e, n, c);
        let u = Promise.resolve(l);
        t.length < 3 && (u = u.then(c)), u.catch(f => a(f))
    })
}

function Bf(t, e, n, r) {
    const i = [];
    for (const s of t)
        for (const o in s.components) {
            let a = s.components[o];
            if (!(e !== "beforeRouteEnter" && !s.instances[o]))
                if (F3(a)) {
                    const l = (a.__vccOpts || a)[e];
                    l && i.push(Ri(l, n, r, s, o))
                } else {
                    let c = a();
                    i.push(() => c.then(l => {
                        if (!l) return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${s.path}"`));
                        const u = G4(l) ? l.default : l;
                        s.components[o] = u;
                        const d = (u.__vccOpts || u)[e];
                        return d && Ri(d, n, r, s, o)()
                    }))
                }
        }
    return i
}

function F3(t) {
    return typeof t == "object" || "displayName" in t || "props" in t || "__vccOpts" in t
}

function F0(t) {
    const e = we(pp),
        n = we(mp),
        r = ze(() => e.resolve(J(t.to))),
        i = ze(() => {
            const {
                matched: c
            } = r.value, {
                length: l
            } = c, u = c[l - 1], f = n.matched;
            if (!u || !f.length) return -1;
            const d = f.findIndex(Ro.bind(null, u));
            if (d > -1) return d;
            const h = U0(c[l - 2]);
            return l > 1 && U0(u) === h && f[f.length - 1].path !== h ? f.findIndex(Ro.bind(null, c[l - 2])) : d
        }),
        s = ze(() => i.value > -1 && j3(n.params, r.value.params)),
        o = ze(() => i.value > -1 && i.value === n.matched.length - 1 && jv(n.params, r.value.params));

    function a(c = {}) {
        return z3(c) ? e[J(t.replace) ? "replace" : "push"](J(t.to)).catch(Pa) : Promise.resolve()
    }
    return {
        route: r,
        href: ze(() => r.value.href),
        isActive: s,
        isExactActive: o,
        navigate: a
    }
}
const U3 = nt({
        name: "RouterLink",
        compatConfig: {
            MODE: 3
        },
        props: {
            to: {
                type: [String, Object],
                required: !0
            },
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            custom: Boolean,
            ariaCurrentValue: {
                type: String,
                default: "page"
            }
        },
        useLink: F0,
        setup(t, {
            slots: e
        }) {
            const n = gl(F0(t)),
                {
                    options: r
                } = we(pp),
                i = ze(() => ({
                    [H0(t.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
                    [H0(t.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
                }));
            return () => {
                const s = e.default && e.default(n);
                return t.custom ? s : Ns("a", {
                    "aria-current": n.isExactActive ? t.ariaCurrentValue : null,
                    href: n.href,
                    onClick: n.navigate,
                    class: i.value
                }, s)
            }
        }
    }),
    H3 = U3;

function z3(t) {
    if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && !(t.button !== void 0 && t.button !== 0)) {
        if (t.currentTarget && t.currentTarget.getAttribute) {
            const e = t.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e)) return
        }
        return t.preventDefault && t.preventDefault(), !0
    }
}

function j3(t, e) {
    for (const n in e) {
        const r = e[n],
            i = t[n];
        if (typeof r == "string") {
            if (r !== i) return !1
        } else if (!cr(i) || i.length !== r.length || r.some((s, o) => s !== i[o])) return !1
    }
    return !0
}

function U0(t) {
    return t ? t.aliasOf ? t.aliasOf.path : t.path : ""
}
const H0 = (t, e, n) => t ? ? e ? ? n,
    V3 = nt({
        name: "RouterView",
        inheritAttrs: !1,
        props: {
            name: {
                type: String,
                default: "default"
            },
            route: Object
        },
        compatConfig: {
            MODE: 3
        },
        setup(t, {
            attrs: e,
            slots: n
        }) {
            const r = we(Qd),
                i = ze(() => t.route || r.value),
                s = we(M0, 0),
                o = ze(() => {
                    let l = J(s);
                    const {
                        matched: u
                    } = i.value;
                    let f;
                    for (;
                        (f = u[l]) && !f.components;) l++;
                    return l
                }),
                a = ze(() => i.value.matched[o.value]);
            de(M0, ze(() => o.value + 1)), de(M3, a), de(Qd, i);
            const c = Z();
            return Xe(() => [c.value, a.value, t.name], ([l, u, f], [d, h, p]) => {
                u && (u.instances[f] = l, h && h !== u && l && l === d && (u.leaveGuards.size || (u.leaveGuards = h.leaveGuards), u.updateGuards.size || (u.updateGuards = h.updateGuards))), l && u && (!h || !Ro(u, h) || !d) && (u.enterCallbacks[f] || []).forEach(g => g(l))
            }, {
                flush: "post"
            }), () => {
                const l = i.value,
                    u = t.name,
                    f = a.value,
                    d = f && f.components[u];
                if (!d) return z0(n.default, {
                    Component: d,
                    route: l
                });
                const h = f.props[u],
                    p = h ? h === !0 ? l.params : typeof h == "function" ? h(l) : h : null,
                    b = Ns(d, ht({}, p, e, {
                        onVnodeUnmounted: x => {
                            x.component.isUnmounted && (f.instances[u] = null)
                        },
                        ref: c
                    }));
                return z0(n.default, {
                    Component: b,
                    route: l
                }) || b
            }
        }
    });

function z0(t, e) {
    if (!t) return null;
    const n = t(e);
    return n.length === 1 ? n[0] : n
}
const G3 = V3;

function W3(t) {
    const e = v3(t.routes, t),
        n = t.parseQuery || D3,
        r = t.stringifyQuery || L0,
        i = t.history,
        s = oa(),
        o = oa(),
        a = oa(),
        c = sv(vi);
    let l = vi;
    io && t.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const u = Of.bind(null, V => "" + V),
        f = Of.bind(null, I3),
        d = Of.bind(null, tu);

    function h(V, oe) {
        let ae, Ae;
        return Gv(V) ? (ae = e.getRecordMatcher(V), Ae = oe) : Ae = V, e.addRoute(Ae, ae)
    }

    function p(V) {
        const oe = e.getRecordMatcher(V);
        oe && e.removeRoute(oe)
    }

    function g() {
        return e.getRoutes().map(V => V.record)
    }

    function b(V) {
        return !!e.getRecordMatcher(V)
    }

    function x(V, oe) {
        if (oe = ht({}, oe || c.value), typeof V == "string") {
            const z = Tf(n, V, oe.path),
                Q = e.resolve({
                    path: z.path
                }, oe),
                $ = i.createHref(z.fullPath);
            return ht(z, Q, {
                params: d(Q.params),
                hash: tu(z.hash),
                redirectedFrom: void 0,
                href: $
            })
        }
        let ae;
        if ("path" in V) ae = ht({}, V, {
            path: Tf(n, V.path, oe.path).path
        });
        else {
            const z = ht({}, V.params);
            for (const Q in z) z[Q] == null && delete z[Q];
            ae = ht({}, V, {
                params: f(z)
            }), oe.params = f(oe.params)
        }
        const Ae = e.resolve(ae, oe),
            Fe = V.hash || "";
        Ae.params = u(d(Ae.params));
        const C = J4(r, ht({}, V, {
                hash: O3(Fe),
                path: Ae.path
            })),
            T = i.createHref(C);
        return ht({
            fullPath: C,
            hash: Fe,
            query: r === L0 ? L3(V.query) : V.query || {}
        }, Ae, {
            redirectedFrom: void 0,
            href: T
        })
    }

    function w(V) {
        return typeof V == "string" ? Tf(n, V, c.value.path) : ht({}, V)
    }

    function O(V, oe) {
        if (l !== V) return Co(8, {
            from: oe,
            to: V
        })
    }

    function N(V) {
        return M(V)
    }

    function U(V) {
        return N(ht(w(V), {
            replace: !0
        }))
    }

    function H(V) {
        const oe = V.matched[V.matched.length - 1];
        if (oe && oe.redirect) {
            const {
                redirect: ae
            } = oe;
            let Ae = typeof ae == "function" ? ae(V) : ae;
            return typeof Ae == "string" && (Ae = Ae.includes("?") || Ae.includes("#") ? Ae = w(Ae) : {
                path: Ae
            }, Ae.params = {}), ht({
                query: V.query,
                hash: V.hash,
                params: "path" in Ae ? {} : V.params
            }, Ae)
        }
    }

    function M(V, oe) {
        const ae = l = x(V),
            Ae = c.value,
            Fe = V.state,
            C = V.force,
            T = V.replace === !0,
            z = H(ae);
        if (z) return M(ht(w(z), {
            state: typeof z == "object" ? ht({}, Fe, z.state) : Fe,
            force: C,
            replace: T
        }), oe || ae);
        const Q = ae;
        Q.redirectedFrom = oe;
        let $;
        return !C && K4(r, Ae, ae) && ($ = Co(16, {
            to: Q,
            from: Ae
        }), te(Ae, Ae, !0, !1)), ($ ? Promise.resolve($) : A(Q, Ae)).catch(ne => Hr(ne) ? Hr(ne, 2) ? ne : Y(ne) : B(ne, Q, Ae)).then(ne => {
            if (ne) {
                if (Hr(ne, 2)) return M(ht({
                    replace: T
                }, w(ne.to), {
                    state: typeof ne.to == "object" ? ht({}, Fe, ne.to.state) : Fe,
                    force: C
                }), oe || Q)
            } else ne = P(Q, Ae, !0, T, Fe);
            return E(Q, Ae, ne), ne
        })
    }

    function y(V, oe) {
        const ae = O(V, oe);
        return ae ? Promise.reject(ae) : Promise.resolve()
    }

    function v(V) {
        const oe = Be.values().next().value;
        return oe && typeof oe.runWithContext == "function" ? oe.runWithContext(V) : V()
    }

    function A(V, oe) {
        let ae;
        const [Ae, Fe, C] = Q3(V, oe);
        ae = Bf(Ae.reverse(), "beforeRouteLeave", V, oe);
        for (const z of Ae) z.leaveGuards.forEach(Q => {
            ae.push(Ri(Q, V, oe))
        });
        const T = y.bind(null, V, oe);
        return ae.push(T), X(ae).then(() => {
            ae = [];
            for (const z of s.list()) ae.push(Ri(z, V, oe));
            return ae.push(T), X(ae)
        }).then(() => {
            ae = Bf(Fe, "beforeRouteUpdate", V, oe);
            for (const z of Fe) z.updateGuards.forEach(Q => {
                ae.push(Ri(Q, V, oe))
            });
            return ae.push(T), X(ae)
        }).then(() => {
            ae = [];
            for (const z of C)
                if (z.beforeEnter)
                    if (cr(z.beforeEnter))
                        for (const Q of z.beforeEnter) ae.push(Ri(Q, V, oe));
                    else ae.push(Ri(z.beforeEnter, V, oe));
            return ae.push(T), X(ae)
        }).then(() => (V.matched.forEach(z => z.enterCallbacks = {}), ae = Bf(C, "beforeRouteEnter", V, oe), ae.push(T), X(ae))).then(() => {
            ae = [];
            for (const z of o.list()) ae.push(Ri(z, V, oe));
            return ae.push(T), X(ae)
        }).catch(z => Hr(z, 8) ? z : Promise.reject(z))
    }

    function E(V, oe, ae) {
        a.list().forEach(Ae => v(() => Ae(V, oe, ae)))
    }

    function P(V, oe, ae, Ae, Fe) {
        const C = O(V, oe);
        if (C) return C;
        const T = oe === vi,
            z = io ? history.state : {};
        ae && (Ae || T ? i.replace(V.fullPath, ht({
            scroll: T && z && z.scroll
        }, Fe)) : i.push(V.fullPath, Fe)), c.value = V, te(V, oe, ae, T), Y()
    }
    let R;

    function F() {
        R || (R = i.listen((V, oe, ae) => {
            if (!ve.listening) return;
            const Ae = x(V),
                Fe = H(Ae);
            if (Fe) {
                M(ht(Fe, {
                    replace: !0
                }), Ae).catch(Pa);
                return
            }
            l = Ae;
            const C = c.value;
            io && n3(N0(C.fullPath, ae.delta), Mu()), A(Ae, C).catch(T => Hr(T, 12) ? T : Hr(T, 2) ? (M(T.to, Ae).then(z => {
                Hr(z, 20) && !ae.delta && ae.type === Va.pop && i.go(-1, !1)
            }).catch(Pa), Promise.reject()) : (ae.delta && i.go(-ae.delta, !1), B(T, Ae, C))).then(T => {
                T = T || P(Ae, C, !1), T && (ae.delta && !Hr(T, 8) ? i.go(-ae.delta, !1) : ae.type === Va.pop && Hr(T, 20) && i.go(-1, !1)), E(Ae, C, T)
            }).catch(Pa)
        }))
    }
    let _ = oa(),
        S = oa(),
        I;

    function B(V, oe, ae) {
        Y(V);
        const Ae = S.list();
        return Ae.length ? Ae.forEach(Fe => Fe(V, oe, ae)) : console.error(V), Promise.reject(V)
    }

    function j() {
        return I && c.value !== vi ? Promise.resolve() : new Promise((V, oe) => {
            _.add([V, oe])
        })
    }

    function Y(V) {
        return I || (I = !V, F(), _.list().forEach(([oe, ae]) => V ? ae(V) : oe()), _.reset()), V
    }

    function te(V, oe, ae, Ae) {
        const {
            scrollBehavior: Fe
        } = t;
        if (!io || !Fe) return Promise.resolve();
        const C = !ae && r3(N0(V.fullPath, 0)) || (Ae || !ae) && history.state && history.state.scroll || null;
        return yl().then(() => Fe(V, oe, C)).then(T => T && t3(T)).catch(T => B(T, V, oe))
    }
    const he = V => i.go(V);
    let Te;
    const Be = new Set,
        ve = {
            currentRoute: c,
            listening: !0,
            addRoute: h,
            removeRoute: p,
            hasRoute: b,
            getRoutes: g,
            resolve: x,
            options: t,
            push: N,
            replace: U,
            go: he,
            back: () => he(-1),
            forward: () => he(1),
            beforeEach: s.add,
            beforeResolve: o.add,
            afterEach: a.add,
            onError: S.add,
            isReady: j,
            install(V) {
                const oe = this;
                V.component("RouterLink", H3), V.component("RouterView", G3), V.config.globalProperties.$router = oe, Object.defineProperty(V.config.globalProperties, "$route", {
                    enumerable: !0,
                    get: () => J(c)
                }), io && !Te && c.value === vi && (Te = !0, N(i.location).catch(Fe => {}));
                const ae = {};
                for (const Fe in vi) Object.defineProperty(ae, Fe, {
                    get: () => c.value[Fe],
                    enumerable: !0
                });
                V.provide(pp, oe), V.provide(mp, nv(ae)), V.provide(Qd, c);
                const Ae = V.unmount;
                Be.add(V), V.unmount = function() {
                    Be.delete(V), Be.size < 1 && (l = vi, R && R(), R = null, c.value = vi, Te = !1, I = !1), Ae()
                }
            }
        };

    function X(V) {
        return V.reduce((oe, ae) => oe.then(() => v(ae)), Promise.resolve())
    }
    return ve
}

function Q3(t, e) {
    const n = [],
        r = [],
        i = [],
        s = Math.max(e.matched.length, t.matched.length);
    for (let o = 0; o < s; o++) {
        const a = e.matched[o];
        a && (t.matched.find(l => Ro(l, a)) ? r.push(a) : n.push(a));
        const c = t.matched[o];
        c && (e.matched.find(l => Ro(l, c)) || i.push(c))
    }
    return [n, r, i]
}

function J3() {
    return we(mp)
}
var K3 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    If = Math.ceil,
    Fn = Math.floor,
    yn = "[BigNumber Error] ",
    j0 = yn + "Number primitive has more than 15 significant digits: ",
    nr = 1e14,
    Ge = 14,
    Df = 9007199254740991,
    Lf = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    bi = 1e7,
    Yt = 1e9;

function qv(t) {
    var e, n, r, i = w.prototype = {
            constructor: w,
            toString: null,
            valueOf: null
        },
        s = new w(1),
        o = 20,
        a = 4,
        c = -7,
        l = 21,
        u = -1e7,
        f = 1e7,
        d = !1,
        h = 1,
        p = 0,
        g = {
            prefix: "",
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ",",
            decimalSeparator: ".",
            fractionGroupSize: 0,
            fractionGroupSeparator: "",
            suffix: ""
        },
        b = "0123456789abcdefghijklmnopqrstuvwxyz",
        x = !0;

    function w(y, v) {
        var A, E, P, R, F, _, S, I, B = this;
        if (!(B instanceof w)) return new w(y, v);
        if (v == null) {
            if (y && y._isBigNumber === !0) {
                B.s = y.s, !y.c || y.e > f ? B.c = B.e = null : y.e < u ? B.c = [B.e = 0] : (B.e = y.e, B.c = y.c.slice());
                return
            }
            if ((_ = typeof y == "number") && y * 0 == 0) {
                if (B.s = 1 / y < 0 ? (y = -y, -1) : 1, y === ~~y) {
                    for (R = 0, F = y; F >= 10; F /= 10, R++);
                    R > f ? B.c = B.e = null : (B.e = R, B.c = [y]);
                    return
                }
                I = String(y)
            } else {
                if (!K3.test(I = String(y))) return r(B, I, _);
                B.s = I.charCodeAt(0) == 45 ? (I = I.slice(1), -1) : 1
            }(R = I.indexOf(".")) > -1 && (I = I.replace(".", "")), (F = I.search(/e/i)) > 0 ? (R < 0 && (R = F), R += +I.slice(F + 1), I = I.substring(0, F)) : R < 0 && (R = I.length)
        } else {
            if (St(v, 2, b.length, "Base"), v == 10 && x) return B = new w(y), H(B, o + B.e + 1, a);
            if (I = String(y), _ = typeof y == "number") {
                if (y * 0 != 0) return r(B, I, _, v);
                if (B.s = 1 / y < 0 ? (I = I.slice(1), -1) : 1, w.DEBUG && I.replace(/^0\.0*|\./, "").length > 15) throw Error(j0 + y)
            } else B.s = I.charCodeAt(0) === 45 ? (I = I.slice(1), -1) : 1;
            for (A = b.slice(0, v), R = F = 0, S = I.length; F < S; F++)
                if (A.indexOf(E = I.charAt(F)) < 0) {
                    if (E == ".") {
                        if (F > R) {
                            R = S;
                            continue
                        }
                    } else if (!P && (I == I.toUpperCase() && (I = I.toLowerCase()) || I == I.toLowerCase() && (I = I.toUpperCase()))) {
                        P = !0, F = -1, R = 0;
                        continue
                    }
                    return r(B, String(y), _, v)
                }
            _ = !1, I = n(I, v, 10, B.s), (R = I.indexOf(".")) > -1 ? I = I.replace(".", "") : R = I.length
        }
        for (F = 0; I.charCodeAt(F) === 48; F++);
        for (S = I.length; I.charCodeAt(--S) === 48;);
        if (I = I.slice(F, ++S)) {
            if (S -= F, _ && w.DEBUG && S > 15 && (y > Df || y !== Fn(y))) throw Error(j0 + B.s * y);
            if ((R = R - F - 1) > f) B.c = B.e = null;
            else if (R < u) B.c = [B.e = 0];
            else {
                if (B.e = R, B.c = [], F = (R + 1) % Ge, R < 0 && (F += Ge), F < S) {
                    for (F && B.c.push(+I.slice(0, F)), S -= Ge; F < S;) B.c.push(+I.slice(F, F += Ge));
                    F = Ge - (I = I.slice(F)).length
                } else F -= S;
                for (; F--; I += "0");
                B.c.push(+I)
            }
        } else B.c = [B.e = 0]
    }
    w.clone = qv, w.ROUND_UP = 0, w.ROUND_DOWN = 1, w.ROUND_CEIL = 2, w.ROUND_FLOOR = 3, w.ROUND_HALF_UP = 4, w.ROUND_HALF_DOWN = 5, w.ROUND_HALF_EVEN = 6, w.ROUND_HALF_CEIL = 7, w.ROUND_HALF_FLOOR = 8, w.EUCLID = 9, w.config = w.set = function(y) {
        var v, A;
        if (y != null)
            if (typeof y == "object") {
                if (y.hasOwnProperty(v = "DECIMAL_PLACES") && (A = y[v], St(A, 0, Yt, v), o = A), y.hasOwnProperty(v = "ROUNDING_MODE") && (A = y[v], St(A, 0, 8, v), a = A), y.hasOwnProperty(v = "EXPONENTIAL_AT") && (A = y[v], A && A.pop ? (St(A[0], -Yt, 0, v), St(A[1], 0, Yt, v), c = A[0], l = A[1]) : (St(A, -Yt, Yt, v), c = -(l = A < 0 ? -A : A))), y.hasOwnProperty(v = "RANGE"))
                    if (A = y[v], A && A.pop) St(A[0], -Yt, -1, v), St(A[1], 1, Yt, v), u = A[0], f = A[1];
                    else if (St(A, -Yt, Yt, v), A) u = -(f = A < 0 ? -A : A);
                else throw Error(yn + v + " cannot be zero: " + A);
                if (y.hasOwnProperty(v = "CRYPTO"))
                    if (A = y[v], A === !!A)
                        if (A)
                            if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) d = A;
                            else throw d = !A, Error(yn + "crypto unavailable");
                else d = A;
                else throw Error(yn + v + " not true or false: " + A);
                if (y.hasOwnProperty(v = "MODULO_MODE") && (A = y[v], St(A, 0, 9, v), h = A), y.hasOwnProperty(v = "POW_PRECISION") && (A = y[v], St(A, 0, Yt, v), p = A), y.hasOwnProperty(v = "FORMAT"))
                    if (A = y[v], typeof A == "object") g = A;
                    else throw Error(yn + v + " not an object: " + A);
                if (y.hasOwnProperty(v = "ALPHABET"))
                    if (A = y[v], typeof A == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(A)) x = A.slice(0, 10) == "0123456789", b = A;
                    else throw Error(yn + v + " invalid: " + A)
            } else throw Error(yn + "Object expected: " + y);
        return {
            DECIMAL_PLACES: o,
            ROUNDING_MODE: a,
            EXPONENTIAL_AT: [c, l],
            RANGE: [u, f],
            CRYPTO: d,
            MODULO_MODE: h,
            POW_PRECISION: p,
            FORMAT: g,
            ALPHABET: b
        }
    }, w.isBigNumber = function(y) {
        if (!y || y._isBigNumber !== !0) return !1;
        if (!w.DEBUG) return !0;
        var v, A, E = y.c,
            P = y.e,
            R = y.s;
        e: if ({}.toString.call(E) == "[object Array]") {
            if ((R === 1 || R === -1) && P >= -Yt && P <= Yt && P === Fn(P)) {
                if (E[0] === 0) {
                    if (P === 0 && E.length === 1) return !0;
                    break e
                }
                if (v = (P + 1) % Ge, v < 1 && (v += Ge), String(E[0]).length == v) {
                    for (v = 0; v < E.length; v++)
                        if (A = E[v], A < 0 || A >= nr || A !== Fn(A)) break e;
                    if (A !== 0) return !0
                }
            }
        } else
        if (E === null && P === null && (R === null || R === 1 || R === -1)) return !0;
        throw Error(yn + "Invalid BigNumber: " + y)
    }, w.maximum = w.max = function() {
        return N(arguments, -1)
    }, w.minimum = w.min = function() {
        return N(arguments, 1)
    }, w.random = function() {
        var y = 9007199254740992,
            v = Math.random() * y & 2097151 ? function() {
                return Fn(Math.random() * y)
            } : function() {
                return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0)
            };
        return function(A) {
            var E, P, R, F, _, S = 0,
                I = [],
                B = new w(s);
            if (A == null ? A = o : St(A, 0, Yt), F = If(A / Ge), d)
                if (crypto.getRandomValues) {
                    for (E = crypto.getRandomValues(new Uint32Array(F *= 2)); S < F;) _ = E[S] * 131072 + (E[S + 1] >>> 11), _ >= 9e15 ? (P = crypto.getRandomValues(new Uint32Array(2)), E[S] = P[0], E[S + 1] = P[1]) : (I.push(_ % 1e14), S += 2);
                    S = F / 2
                } else if (crypto.randomBytes) {
                for (E = crypto.randomBytes(F *= 7); S < F;) _ = (E[S] & 31) * 281474976710656 + E[S + 1] * 1099511627776 + E[S + 2] * 4294967296 + E[S + 3] * 16777216 + (E[S + 4] << 16) + (E[S + 5] << 8) + E[S + 6], _ >= 9e15 ? crypto.randomBytes(7).copy(E, S) : (I.push(_ % 1e14), S += 7);
                S = F / 7
            } else throw d = !1, Error(yn + "crypto unavailable");
            if (!d)
                for (; S < F;) _ = v(), _ < 9e15 && (I[S++] = _ % 1e14);
            for (F = I[--S], A %= Ge, F && A && (_ = Lf[Ge - A], I[S] = Fn(F / _) * _); I[S] === 0; I.pop(), S--);
            if (S < 0) I = [R = 0];
            else {
                for (R = -1; I[0] === 0; I.splice(0, 1), R -= Ge);
                for (S = 1, _ = I[0]; _ >= 10; _ /= 10, S++);
                S < Ge && (R -= Ge - S)
            }
            return B.e = R, B.c = I, B
        }
    }(), w.sum = function() {
        for (var y = 1, v = arguments, A = new w(v[0]); y < v.length;) A = A.plus(v[y++]);
        return A
    }, n = function() {
        var y = "0123456789";

        function v(A, E, P, R) {
            for (var F, _ = [0], S, I = 0, B = A.length; I < B;) {
                for (S = _.length; S--; _[S] *= E);
                for (_[0] += R.indexOf(A.charAt(I++)), F = 0; F < _.length; F++) _[F] > P - 1 && (_[F + 1] == null && (_[F + 1] = 0), _[F + 1] += _[F] / P | 0, _[F] %= P)
            }
            return _.reverse()
        }
        return function(A, E, P, R, F) {
            var _, S, I, B, j, Y, te, he, Te = A.indexOf("."),
                Be = o,
                ve = a;
            for (Te >= 0 && (B = p, p = 0, A = A.replace(".", ""), he = new w(E), Y = he.pow(A.length - Te), p = B, he.c = v(zr(Ln(Y.c), Y.e, "0"), 10, P, y), he.e = he.c.length), te = v(A, E, P, F ? (_ = b, y) : (_ = y, b)), I = B = te.length; te[--B] == 0; te.pop());
            if (!te[0]) return _.charAt(0);
            if (Te < 0 ? --I : (Y.c = te, Y.e = I, Y.s = R, Y = e(Y, he, Be, ve, P), te = Y.c, j = Y.r, I = Y.e), S = I + Be + 1, Te = te[S], B = P / 2, j = j || S < 0 || te[S + 1] != null, j = ve < 4 ? (Te != null || j) && (ve == 0 || ve == (Y.s < 0 ? 3 : 2)) : Te > B || Te == B && (ve == 4 || j || ve == 6 && te[S - 1] & 1 || ve == (Y.s < 0 ? 8 : 7)), S < 1 || !te[0]) A = j ? zr(_.charAt(1), -Be, _.charAt(0)) : _.charAt(0);
            else {
                if (te.length = S, j)
                    for (--P; ++te[--S] > P;) te[S] = 0, S || (++I, te = [1].concat(te));
                for (B = te.length; !te[--B];);
                for (Te = 0, A = ""; Te <= B; A += _.charAt(te[Te++]));
                A = zr(A, I, _.charAt(0))
            }
            return A
        }
    }(), e = function() {
        function y(E, P, R) {
            var F, _, S, I, B = 0,
                j = E.length,
                Y = P % bi,
                te = P / bi | 0;
            for (E = E.slice(); j--;) S = E[j] % bi, I = E[j] / bi | 0, F = te * S + I * Y, _ = Y * S + F % bi * bi + B, B = (_ / R | 0) + (F / bi | 0) + te * I, E[j] = _ % R;
            return B && (E = [B].concat(E)), E
        }

        function v(E, P, R, F) {
            var _, S;
            if (R != F) S = R > F ? 1 : -1;
            else
                for (_ = S = 0; _ < R; _++)
                    if (E[_] != P[_]) {
                        S = E[_] > P[_] ? 1 : -1;
                        break
                    } return S
        }

        function A(E, P, R, F) {
            for (var _ = 0; R--;) E[R] -= _, _ = E[R] < P[R] ? 1 : 0, E[R] = _ * F + E[R] - P[R];
            for (; !E[0] && E.length > 1; E.splice(0, 1));
        }
        return function(E, P, R, F, _) {
            var S, I, B, j, Y, te, he, Te, Be, ve, X, V, oe, ae, Ae, Fe, C, T = E.s == P.s ? 1 : -1,
                z = E.c,
                Q = P.c;
            if (!z || !z[0] || !Q || !Q[0]) return new w(!E.s || !P.s || (z ? Q && z[0] == Q[0] : !Q) ? NaN : z && z[0] == 0 || !Q ? T * 0 : T / 0);
            for (Te = new w(T), Be = Te.c = [], I = E.e - P.e, T = R + I + 1, _ || (_ = nr, I = Un(E.e / Ge) - Un(P.e / Ge), T = T / Ge | 0), B = 0; Q[B] == (z[B] || 0); B++);
            if (Q[B] > (z[B] || 0) && I--, T < 0) Be.push(1), j = !0;
            else {
                for (ae = z.length, Fe = Q.length, B = 0, T += 2, Y = Fn(_ / (Q[0] + 1)), Y > 1 && (Q = y(Q, Y, _), z = y(z, Y, _), Fe = Q.length, ae = z.length), oe = Fe, ve = z.slice(0, Fe), X = ve.length; X < Fe; ve[X++] = 0);
                C = Q.slice(), C = [0].concat(C), Ae = Q[0], Q[1] >= _ / 2 && Ae++;
                do {
                    if (Y = 0, S = v(Q, ve, Fe, X), S < 0) {
                        if (V = ve[0], Fe != X && (V = V * _ + (ve[1] || 0)), Y = Fn(V / Ae), Y > 1)
                            for (Y >= _ && (Y = _ - 1), te = y(Q, Y, _), he = te.length, X = ve.length; v(te, ve, he, X) == 1;) Y--, A(te, Fe < he ? C : Q, he, _), he = te.length, S = 1;
                        else Y == 0 && (S = Y = 1), te = Q.slice(), he = te.length;
                        if (he < X && (te = [0].concat(te)), A(ve, te, X, _), X = ve.length, S == -1)
                            for (; v(Q, ve, Fe, X) < 1;) Y++, A(ve, Fe < X ? C : Q, X, _), X = ve.length
                    } else S === 0 && (Y++, ve = [0]);
                    Be[B++] = Y, ve[0] ? ve[X++] = z[oe] || 0 : (ve = [z[oe]], X = 1)
                } while ((oe++ < ae || ve[0] != null) && T--);
                j = ve[0] != null, Be[0] || Be.splice(0, 1)
            }
            if (_ == nr) {
                for (B = 1, T = Be[0]; T >= 10; T /= 10, B++);
                H(Te, R + (Te.e = B + I * Ge - 1) + 1, F, j)
            } else Te.e = I, Te.r = +j;
            return Te
        }
    }();

    function O(y, v, A, E) {
        var P, R, F, _, S;
        if (A == null ? A = a : St(A, 0, 8), !y.c) return y.toString();
        if (P = y.c[0], F = y.e, v == null) S = Ln(y.c), S = E == 1 || E == 2 && (F <= c || F >= l) ? tc(S, F) : zr(S, F, "0");
        else if (y = H(new w(y), v, A), R = y.e, S = Ln(y.c), _ = S.length, E == 1 || E == 2 && (v <= R || R <= c)) {
            for (; _ < v; S += "0", _++);
            S = tc(S, R)
        } else if (v -= F, S = zr(S, R, "0"), R + 1 > _) {
            if (--v > 0)
                for (S += "."; v--; S += "0");
        } else if (v += R - _, v > 0)
            for (R + 1 == _ && (S += "."); v--; S += "0");
        return y.s < 0 && P ? "-" + S : S
    }

    function N(y, v) {
        for (var A, E, P = 1, R = new w(y[0]); P < y.length; P++) E = new w(y[P]), (!E.s || (A = ns(R, E)) === v || A === 0 && R.s === v) && (R = E);
        return R
    }

    function U(y, v, A) {
        for (var E = 1, P = v.length; !v[--P]; v.pop());
        for (P = v[0]; P >= 10; P /= 10, E++);
        return (A = E + A * Ge - 1) > f ? y.c = y.e = null : A < u ? y.c = [y.e = 0] : (y.e = A, y.c = v), y
    }
    r = function() {
        var y = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
            v = /^([^.]+)\.$/,
            A = /^\.([^.]+)$/,
            E = /^-?(Infinity|NaN)$/,
            P = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(R, F, _, S) {
            var I, B = _ ? F : F.replace(P, "");
            if (E.test(B)) R.s = isNaN(B) ? null : B < 0 ? -1 : 1;
            else {
                if (!_ && (B = B.replace(y, function(j, Y, te) {
                        return I = (te = te.toLowerCase()) == "x" ? 16 : te == "b" ? 2 : 8, !S || S == I ? Y : j
                    }), S && (I = S, B = B.replace(v, "$1").replace(A, "0.$1")), F != B)) return new w(B, I);
                if (w.DEBUG) throw Error(yn + "Not a" + (S ? " base " + S : "") + " number: " + F);
                R.s = null
            }
            R.c = R.e = null
        }
    }();

    function H(y, v, A, E) {
        var P, R, F, _, S, I, B, j = y.c,
            Y = Lf;
        if (j) {
            e: {
                for (P = 1, _ = j[0]; _ >= 10; _ /= 10, P++);
                if (R = v - P, R < 0) R += Ge,
                F = v,
                S = j[I = 0],
                B = Fn(S / Y[P - F - 1] % 10);
                else if (I = If((R + 1) / Ge), I >= j.length)
                    if (E) {
                        for (; j.length <= I; j.push(0));
                        S = B = 0, P = 1, R %= Ge, F = R - Ge + 1
                    } else break e;
                else {
                    for (S = _ = j[I], P = 1; _ >= 10; _ /= 10, P++);
                    R %= Ge, F = R - Ge + P, B = F < 0 ? 0 : Fn(S / Y[P - F - 1] % 10)
                }
                if (E = E || v < 0 || j[I + 1] != null || (F < 0 ? S : S % Y[P - F - 1]), E = A < 4 ? (B || E) && (A == 0 || A == (y.s < 0 ? 3 : 2)) : B > 5 || B == 5 && (A == 4 || E || A == 6 && (R > 0 ? F > 0 ? S / Y[P - F] : 0 : j[I - 1]) % 10 & 1 || A == (y.s < 0 ? 8 : 7)), v < 1 || !j[0]) return j.length = 0, E ? (v -= y.e + 1, j[0] = Y[(Ge - v % Ge) % Ge], y.e = -v || 0) : j[0] = y.e = 0, y;
                if (R == 0 ? (j.length = I, _ = 1, I--) : (j.length = I + 1, _ = Y[Ge - R], j[I] = F > 0 ? Fn(S / Y[P - F] % Y[F]) * _ : 0), E)
                    for (;;)
                        if (I == 0) {
                            for (R = 1, F = j[0]; F >= 10; F /= 10, R++);
                            for (F = j[0] += _, _ = 1; F >= 10; F /= 10, _++);
                            R != _ && (y.e++, j[0] == nr && (j[0] = 1));
                            break
                        } else {
                            if (j[I] += _, j[I] != nr) break;
                            j[I--] = 0, _ = 1
                        }
                for (R = j.length; j[--R] === 0; j.pop());
            }
            y.e > f ? y.c = y.e = null : y.e < u && (y.c = [y.e = 0])
        }
        return y
    }

    function M(y) {
        var v, A = y.e;
        return A === null ? y.toString() : (v = Ln(y.c), v = A <= c || A >= l ? tc(v, A) : zr(v, A, "0"), y.s < 0 ? "-" + v : v)
    }
    return i.absoluteValue = i.abs = function() {
        var y = new w(this);
        return y.s < 0 && (y.s = 1), y
    }, i.comparedTo = function(y, v) {
        return ns(this, new w(y, v))
    }, i.decimalPlaces = i.dp = function(y, v) {
        var A, E, P, R = this;
        if (y != null) return St(y, 0, Yt), v == null ? v = a : St(v, 0, 8), H(new w(R), y + R.e + 1, v);
        if (!(A = R.c)) return null;
        if (E = ((P = A.length - 1) - Un(this.e / Ge)) * Ge, P = A[P])
            for (; P % 10 == 0; P /= 10, E--);
        return E < 0 && (E = 0), E
    }, i.dividedBy = i.div = function(y, v) {
        return e(this, new w(y, v), o, a)
    }, i.dividedToIntegerBy = i.idiv = function(y, v) {
        return e(this, new w(y, v), 0, 1)
    }, i.exponentiatedBy = i.pow = function(y, v) {
        var A, E, P, R, F, _, S, I, B, j = this;
        if (y = new w(y), y.c && !y.isInteger()) throw Error(yn + "Exponent not an integer: " + M(y));
        if (v != null && (v = new w(v)), _ = y.e > 14, !j.c || !j.c[0] || j.c[0] == 1 && !j.e && j.c.length == 1 || !y.c || !y.c[0]) return B = new w(Math.pow(+M(j), _ ? y.s * (2 - ec(y)) : +M(y))), v ? B.mod(v) : B;
        if (S = y.s < 0, v) {
            if (v.c ? !v.c[0] : !v.s) return new w(NaN);
            E = !S && j.isInteger() && v.isInteger(), E && (j = j.mod(v))
        } else {
            if (y.e > 9 && (j.e > 0 || j.e < -1 || (j.e == 0 ? j.c[0] > 1 || _ && j.c[1] >= 24e7 : j.c[0] < 8e13 || _ && j.c[0] <= 9999975e7))) return R = j.s < 0 && ec(y) ? -0 : 0, j.e > -1 && (R = 1 / R), new w(S ? 1 / R : R);
            p && (R = If(p / Ge + 2))
        }
        for (_ ? (A = new w(.5), S && (y.s = 1), I = ec(y)) : (P = Math.abs(+M(y)), I = P % 2), B = new w(s);;) {
            if (I) {
                if (B = B.times(j), !B.c) break;
                R ? B.c.length > R && (B.c.length = R) : E && (B = B.mod(v))
            }
            if (P) {
                if (P = Fn(P / 2), P === 0) break;
                I = P % 2
            } else if (y = y.times(A), H(y, y.e + 1, 1), y.e > 14) I = ec(y);
            else {
                if (P = +M(y), P === 0) break;
                I = P % 2
            }
            j = j.times(j), R ? j.c && j.c.length > R && (j.c.length = R) : E && (j = j.mod(v))
        }
        return E ? B : (S && (B = s.div(B)), v ? B.mod(v) : R ? H(B, p, a, F) : B)
    }, i.integerValue = function(y) {
        var v = new w(this);
        return y == null ? y = a : St(y, 0, 8), H(v, v.e + 1, y)
    }, i.isEqualTo = i.eq = function(y, v) {
        return ns(this, new w(y, v)) === 0
    }, i.isFinite = function() {
        return !!this.c
    }, i.isGreaterThan = i.gt = function(y, v) {
        return ns(this, new w(y, v)) > 0
    }, i.isGreaterThanOrEqualTo = i.gte = function(y, v) {
        return (v = ns(this, new w(y, v))) === 1 || v === 0
    }, i.isInteger = function() {
        return !!this.c && Un(this.e / Ge) > this.c.length - 2
    }, i.isLessThan = i.lt = function(y, v) {
        return ns(this, new w(y, v)) < 0
    }, i.isLessThanOrEqualTo = i.lte = function(y, v) {
        return (v = ns(this, new w(y, v))) === -1 || v === 0
    }, i.isNaN = function() {
        return !this.s
    }, i.isNegative = function() {
        return this.s < 0
    }, i.isPositive = function() {
        return this.s > 0
    }, i.isZero = function() {
        return !!this.c && this.c[0] == 0
    }, i.minus = function(y, v) {
        var A, E, P, R, F = this,
            _ = F.s;
        if (y = new w(y, v), v = y.s, !_ || !v) return new w(NaN);
        if (_ != v) return y.s = -v, F.plus(y);
        var S = F.e / Ge,
            I = y.e / Ge,
            B = F.c,
            j = y.c;
        if (!S || !I) {
            if (!B || !j) return B ? (y.s = -v, y) : new w(j ? F : NaN);
            if (!B[0] || !j[0]) return j[0] ? (y.s = -v, y) : new w(B[0] ? F : a == 3 ? -0 : 0)
        }
        if (S = Un(S), I = Un(I), B = B.slice(), _ = S - I) {
            for ((R = _ < 0) ? (_ = -_, P = B) : (I = S, P = j), P.reverse(), v = _; v--; P.push(0));
            P.reverse()
        } else
            for (E = (R = (_ = B.length) < (v = j.length)) ? _ : v, _ = v = 0; v < E; v++)
                if (B[v] != j[v]) {
                    R = B[v] < j[v];
                    break
                } if (R && (P = B, B = j, j = P, y.s = -y.s), v = (E = j.length) - (A = B.length), v > 0)
            for (; v--; B[A++] = 0);
        for (v = nr - 1; E > _;) {
            if (B[--E] < j[E]) {
                for (A = E; A && !B[--A]; B[A] = v);
                --B[A], B[E] += nr
            }
            B[E] -= j[E]
        }
        for (; B[0] == 0; B.splice(0, 1), --I);
        return B[0] ? U(y, B, I) : (y.s = a == 3 ? -1 : 1, y.c = [y.e = 0], y)
    }, i.modulo = i.mod = function(y, v) {
        var A, E, P = this;
        return y = new w(y, v), !P.c || !y.s || y.c && !y.c[0] ? new w(NaN) : !y.c || P.c && !P.c[0] ? new w(P) : (h == 9 ? (E = y.s, y.s = 1, A = e(P, y, 0, 3), y.s = E, A.s *= E) : A = e(P, y, 0, h), y = P.minus(A.times(y)), !y.c[0] && h == 1 && (y.s = P.s), y)
    }, i.multipliedBy = i.times = function(y, v) {
        var A, E, P, R, F, _, S, I, B, j, Y, te, he, Te, Be, ve = this,
            X = ve.c,
            V = (y = new w(y, v)).c;
        if (!X || !V || !X[0] || !V[0]) return !ve.s || !y.s || X && !X[0] && !V || V && !V[0] && !X ? y.c = y.e = y.s = null : (y.s *= ve.s, !X || !V ? y.c = y.e = null : (y.c = [0], y.e = 0)), y;
        for (E = Un(ve.e / Ge) + Un(y.e / Ge), y.s *= ve.s, S = X.length, j = V.length, S < j && (he = X, X = V, V = he, P = S, S = j, j = P), P = S + j, he = []; P--; he.push(0));
        for (Te = nr, Be = bi, P = j; --P >= 0;) {
            for (A = 0, Y = V[P] % Be, te = V[P] / Be | 0, F = S, R = P + F; R > P;) I = X[--F] % Be, B = X[F] / Be | 0, _ = te * I + B * Y, I = Y * I + _ % Be * Be + he[R] + A, A = (I / Te | 0) + (_ / Be | 0) + te * B, he[R--] = I % Te;
            he[R] = A
        }
        return A ? ++E : he.splice(0, 1), U(y, he, E)
    }, i.negated = function() {
        var y = new w(this);
        return y.s = -y.s || null, y
    }, i.plus = function(y, v) {
        var A, E = this,
            P = E.s;
        if (y = new w(y, v), v = y.s, !P || !v) return new w(NaN);
        if (P != v) return y.s = -v, E.minus(y);
        var R = E.e / Ge,
            F = y.e / Ge,
            _ = E.c,
            S = y.c;
        if (!R || !F) {
            if (!_ || !S) return new w(P / 0);
            if (!_[0] || !S[0]) return S[0] ? y : new w(_[0] ? E : P * 0)
        }
        if (R = Un(R), F = Un(F), _ = _.slice(), P = R - F) {
            for (P > 0 ? (F = R, A = S) : (P = -P, A = _), A.reverse(); P--; A.push(0));
            A.reverse()
        }
        for (P = _.length, v = S.length, P - v < 0 && (A = S, S = _, _ = A, v = P), P = 0; v;) P = (_[--v] = _[v] + S[v] + P) / nr | 0, _[v] = nr === _[v] ? 0 : _[v] % nr;
        return P && (_ = [P].concat(_), ++F), U(y, _, F)
    }, i.precision = i.sd = function(y, v) {
        var A, E, P, R = this;
        if (y != null && y !== !!y) return St(y, 1, Yt), v == null ? v = a : St(v, 0, 8), H(new w(R), y, v);
        if (!(A = R.c)) return null;
        if (P = A.length - 1, E = P * Ge + 1, P = A[P]) {
            for (; P % 10 == 0; P /= 10, E--);
            for (P = A[0]; P >= 10; P /= 10, E++);
        }
        return y && R.e + 1 > E && (E = R.e + 1), E
    }, i.shiftedBy = function(y) {
        return St(y, -Df, Df), this.times("1e" + y)
    }, i.squareRoot = i.sqrt = function() {
        var y, v, A, E, P, R = this,
            F = R.c,
            _ = R.s,
            S = R.e,
            I = o + 4,
            B = new w("0.5");
        if (_ !== 1 || !F || !F[0]) return new w(!_ || _ < 0 && (!F || F[0]) ? NaN : F ? R : 1 / 0);
        if (_ = Math.sqrt(+M(R)), _ == 0 || _ == 1 / 0 ? (v = Ln(F), (v.length + S) % 2 == 0 && (v += "0"), _ = Math.sqrt(+v), S = Un((S + 1) / 2) - (S < 0 || S % 2), _ == 1 / 0 ? v = "5e" + S : (v = _.toExponential(), v = v.slice(0, v.indexOf("e") + 1) + S), A = new w(v)) : A = new w(_ + ""), A.c[0]) {
            for (S = A.e, _ = S + I, _ < 3 && (_ = 0);;)
                if (P = A, A = B.times(P.plus(e(R, P, I, 1))), Ln(P.c).slice(0, _) === (v = Ln(A.c)).slice(0, _))
                    if (A.e < S && --_, v = v.slice(_ - 3, _ + 1), v == "9999" || !E && v == "4999") {
                        if (!E && (H(P, P.e + o + 2, 0), P.times(P).eq(R))) {
                            A = P;
                            break
                        }
                        I += 4, _ += 4, E = 1
                    } else {
                        (!+v || !+v.slice(1) && v.charAt(0) == "5") && (H(A, A.e + o + 2, 1), y = !A.times(A).eq(R));
                        break
                    }
        }
        return H(A, A.e + o + 1, a, y)
    }, i.toExponential = function(y, v) {
        return y != null && (St(y, 0, Yt), y++), O(this, y, v, 1)
    }, i.toFixed = function(y, v) {
        return y != null && (St(y, 0, Yt), y = y + this.e + 1), O(this, y, v)
    }, i.toFormat = function(y, v, A) {
        var E, P = this;
        if (A == null) y != null && v && typeof v == "object" ? (A = v, v = null) : y && typeof y == "object" ? (A = y, y = v = null) : A = g;
        else if (typeof A != "object") throw Error(yn + "Argument not an object: " + A);
        if (E = P.toFixed(y, v), P.c) {
            var R, F = E.split("."),
                _ = +A.groupSize,
                S = +A.secondaryGroupSize,
                I = A.groupSeparator || "",
                B = F[0],
                j = F[1],
                Y = P.s < 0,
                te = Y ? B.slice(1) : B,
                he = te.length;
            if (S && (R = _, _ = S, S = R, he -= R), _ > 0 && he > 0) {
                for (R = he % _ || _, B = te.substr(0, R); R < he; R += _) B += I + te.substr(R, _);
                S > 0 && (B += I + te.slice(R)), Y && (B = "-" + B)
            }
            E = j ? B + (A.decimalSeparator || "") + ((S = +A.fractionGroupSize) ? j.replace(new RegExp("\\d{" + S + "}\\B", "g"), "$&" + (A.fractionGroupSeparator || "")) : j) : B
        }
        return (A.prefix || "") + E + (A.suffix || "")
    }, i.toFraction = function(y) {
        var v, A, E, P, R, F, _, S, I, B, j, Y, te = this,
            he = te.c;
        if (y != null && (_ = new w(y), !_.isInteger() && (_.c || _.s !== 1) || _.lt(s))) throw Error(yn + "Argument " + (_.isInteger() ? "out of range: " : "not an integer: ") + M(_));
        if (!he) return new w(te);
        for (v = new w(s), I = A = new w(s), E = S = new w(s), Y = Ln(he), R = v.e = Y.length - te.e - 1, v.c[0] = Lf[(F = R % Ge) < 0 ? Ge + F : F], y = !y || _.comparedTo(v) > 0 ? R > 0 ? v : I : _, F = f, f = 1 / 0, _ = new w(Y), S.c[0] = 0; B = e(_, v, 0, 1), P = A.plus(B.times(E)), P.comparedTo(y) != 1;) A = E, E = P, I = S.plus(B.times(P = I)), S = P, v = _.minus(B.times(P = v)), _ = P;
        return P = e(y.minus(A), E, 0, 1), S = S.plus(P.times(I)), A = A.plus(P.times(E)), S.s = I.s = te.s, R = R * 2, j = e(I, E, R, a).minus(te).abs().comparedTo(e(S, A, R, a).minus(te).abs()) < 1 ? [I, E] : [S, A], f = F, j
    }, i.toNumber = function() {
        return +M(this)
    }, i.toPrecision = function(y, v) {
        return y != null && St(y, 1, Yt), O(this, y, v, 2)
    }, i.toString = function(y) {
        var v, A = this,
            E = A.s,
            P = A.e;
        return P === null ? E ? (v = "Infinity", E < 0 && (v = "-" + v)) : v = "NaN" : (y == null ? v = P <= c || P >= l ? tc(Ln(A.c), P) : zr(Ln(A.c), P, "0") : y === 10 && x ? (A = H(new w(A), o + P + 1, a), v = zr(Ln(A.c), A.e, "0")) : (St(y, 2, b.length, "Base"), v = n(zr(Ln(A.c), P, "0"), 10, y, E, !0)), E < 0 && A.c[0] && (v = "-" + v)), v
    }, i.valueOf = i.toJSON = function() {
        return M(this)
    }, i._isBigNumber = !0, i[Symbol.toStringTag] = "BigNumber", i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf, t != null && w.set(t), w
}

function Un(t) {
    var e = t | 0;
    return t > 0 || t === e ? e : e - 1
}

function Ln(t) {
    for (var e, n, r = 1, i = t.length, s = t[0] + ""; r < i;) {
        for (e = t[r++] + "", n = Ge - e.length; n--; e = "0" + e);
        s += e
    }
    for (i = s.length; s.charCodeAt(--i) === 48;);
    return s.slice(0, i + 1 || 1)
}

function ns(t, e) {
    var n, r, i = t.c,
        s = e.c,
        o = t.s,
        a = e.s,
        c = t.e,
        l = e.e;
    if (!o || !a) return null;
    if (n = i && !i[0], r = s && !s[0], n || r) return n ? r ? 0 : -a : o;
    if (o != a) return o;
    if (n = o < 0, r = c == l, !i || !s) return r ? 0 : !i ^ n ? 1 : -1;
    if (!r) return c > l ^ n ? 1 : -1;
    for (a = (c = i.length) < (l = s.length) ? c : l, o = 0; o < a; o++)
        if (i[o] != s[o]) return i[o] > s[o] ^ n ? 1 : -1;
    return c == l ? 0 : c > l ^ n ? 1 : -1
}

function St(t, e, n, r) {
    if (t < e || t > n || t !== Fn(t)) throw Error(yn + (r || "Argument") + (typeof t == "number" ? t < e || t > n ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(t))
}

function ec(t) {
    var e = t.c.length - 1;
    return Un(t.e / Ge) == e && t.c[e] % 2 != 0
}

function tc(t, e) {
    return (t.length > 1 ? t.charAt(0) + "." + t.slice(1) : t) + (e < 0 ? "e" : "e+") + e
}

function zr(t, e, n) {
    var r, i;
    if (e < 0) {
        for (i = n + "."; ++e; i += n);
        t = i + t
    } else if (r = t.length, ++e > r) {
        for (i = n, e -= r; --e; i += n);
        t += i
    } else e < r && (t = t.slice(0, e) + "." + t.slice(e));
    return t
}
var me = qv();
const Z3 = "6.8.1";

function Y3(t, e, n) {
    const r = e.split("|").map(s => s.trim());
    for (let s = 0; s < r.length; s++) switch (e) {
        case "any":
            return;
        case "bigint":
        case "boolean":
        case "number":
        case "string":
            if (typeof t === e) return
    }
    const i = new Error(`invalid value for type ${e}`);
    throw i.code = "INVALID_ARGUMENT", i.argument = `value.${n}`, i.value = t, i
}
async function fn(t) {
    const e = Object.keys(t);
    return (await Promise.all(e.map(r => Promise.resolve(t[r])))).reduce((r, i, s) => (r[e[s]] = i, r), {})
}

function Ue(t, e, n) {
    for (let r in e) {
        let i = e[r];
        const s = n ? n[r] : null;
        s && Y3(i, s, r), Object.defineProperty(t, r, {
            enumerable: !0,
            value: i,
            writable: !1
        })
    }
}

function ao(t) {
    if (t == null) return "null";
    if (Array.isArray(t)) return "[ " + t.map(ao).join(", ") + " ]";
    if (t instanceof Uint8Array) {
        const e = "0123456789abcdef";
        let n = "0x";
        for (let r = 0; r < t.length; r++) n += e[t[r] >> 4], n += e[t[r] & 15];
        return n
    }
    if (typeof t == "object" && typeof t.toJSON == "function") return ao(t.toJSON());
    switch (typeof t) {
        case "boolean":
        case "symbol":
            return t.toString();
        case "bigint":
            return BigInt(t).toString();
        case "number":
            return t.toString();
        case "string":
            return JSON.stringify(t);
        case "object":
            {
                const e = Object.keys(t);
                return e.sort(),
                "{ " + e.map(n => `${ao(n)}: ${ao(t[n])}`).join(", ") + " }"
            }
    }
    return "[ COULD NOT SERIALIZE ]"
}

function Wn(t, e) {
    return t && t.code === e
}

function gp(t) {
    return Wn(t, "CALL_EXCEPTION")
}

function Wt(t, e, n) {
    let r = t; {
        const s = [];
        if (n) {
            if ("message" in n || "code" in n || "name" in n) throw new Error(`value will overwrite populated values: ${ao(n)}`);
            for (const o in n) {
                if (o === "shortMessage") continue;
                const a = n[o];
                s.push(o + "=" + ao(a))
            }
        }
        s.push(`code=${e}`), s.push(`version=${Z3}`), s.length && (t += " (" + s.join(", ") + ")")
    }
    let i;
    switch (e) {
        case "INVALID_ARGUMENT":
            i = new TypeError(t);
            break;
        case "NUMERIC_FAULT":
        case "BUFFER_OVERRUN":
            i = new RangeError(t);
            break;
        default:
            i = new Error(t)
    }
    return Ue(i, {
        code: e
    }), n && Object.assign(i, n), i.shortMessage == null && Ue(i, {
        shortMessage: r
    }), i
}

function re(t, e, n, r) {
    if (!t) throw Wt(e, n, r)
}

function W(t, e, n, r) {
    re(t, e, "INVALID_ARGUMENT", {
        argument: n,
        value: r
    })
}

function $v(t, e, n) {
    n == null && (n = ""), n && (n = ": " + n), re(t >= e, "missing arguemnt" + n, "MISSING_ARGUMENT", {
        count: t,
        expectedCount: e
    }), re(t <= e, "too many arguemnts" + n, "UNEXPECTED_ARGUMENT", {
        count: t,
        expectedCount: e
    })
}
const X3 = ["NFD", "NFC", "NFKD", "NFKC"].reduce((t, e) => {
    try {
        if ("test".normalize(e) !== "test") throw new Error("bad");
        if (e === "NFD") {
            const n = String.fromCharCode(233).normalize("NFD"),
                r = String.fromCharCode(101, 769);
            if (n !== r) throw new Error("broken")
        }
        t.push(e)
    } catch {}
    return t
}, []);

function q3(t) {
    re(X3.indexOf(t) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
        operation: "String.prototype.normalize",
        info: {
            form: t
        }
    })
}

function wl(t, e, n) {
    if (n == null && (n = ""), t !== e) {
        let r = n,
            i = "new";
        n && (r += ".", i += " " + n), re(!1, `private constructor; use ${r}from* methods`, "UNSUPPORTED_OPERATION", {
            operation: i
        })
    }
}

function eb(t, e, n) {
    if (t instanceof Uint8Array) return n ? new Uint8Array(t) : t;
    if (typeof t == "string" && t.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
        const r = new Uint8Array((t.length - 2) / 2);
        let i = 2;
        for (let s = 0; s < r.length; s++) r[s] = parseInt(t.substring(i, i + 2), 16), i += 2;
        return r
    }
    W(!1, "invalid BytesLike value", e || "value", t)
}

function qe(t, e) {
    return eb(t, e, !1)
}

function kn(t, e) {
    return eb(t, e, !0)
}

function Ot(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && t.length !== 2 + 2 * e || e === !0 && t.length % 2 !== 0)
}

function $3(t) {
    return Ot(t, !0) || t instanceof Uint8Array
}
const V0 = "0123456789abcdef";

function De(t) {
    const e = qe(t);
    let n = "0x";
    for (let r = 0; r < e.length; r++) {
        const i = e[r];
        n += V0[(i & 240) >> 4] + V0[i & 15]
    }
    return n
}

function Ht(t) {
    return "0x" + t.map(e => De(e).substring(2)).join("")
}

function _s(t) {
    return Ot(t, !0) ? (t.length - 2) / 2 : qe(t).length
}

function It(t, e, n) {
    const r = qe(t);
    return n != null && n > r.length && re(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
        buffer: r,
        length: r.length,
        offset: n
    }), De(r.slice(e ? ? 0, n ? ? r.length))
}

function tb(t, e, n) {
    const r = qe(t);
    re(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
        buffer: new Uint8Array(r),
        length: e,
        offset: e + 1
    });
    const i = new Uint8Array(e);
    return i.fill(0), n ? i.set(r, e - r.length) : i.set(r, 0), De(i)
}

function Sr(t, e) {
    return tb(t, e, !0)
}

function nb(t, e) {
    return tb(t, e, !1)
}
const Fu = BigInt(0),
    or = BigInt(1),
    lo = 9007199254740991;

function nu(t, e) {
    const n = Uu(t, "value"),
        r = BigInt($e(e, "width"));
    if (re(n >> r === Fu, "overflow", "NUMERIC_FAULT", {
            operation: "fromTwos",
            fault: "overflow",
            value: t
        }), n >> r - or) {
        const i = (or << r) - or;
        return -((~n & i) + or)
    }
    return n
}

function yp(t, e) {
    let n = Le(t, "value");
    const r = BigInt($e(e, "width")),
        i = or << r - or;
    if (n < Fu) {
        n = -n, re(n <= i, "too low", "NUMERIC_FAULT", {
            operation: "toTwos",
            fault: "overflow",
            value: t
        });
        const s = (or << r) - or;
        return (~n & s) + or
    } else re(n < i, "too high", "NUMERIC_FAULT", {
        operation: "toTwos",
        fault: "overflow",
        value: t
    });
    return n
}

function hs(t, e) {
    const n = Uu(t, "value"),
        r = BigInt($e(e, "bits"));
    return n & (or << r) - or
}

function Le(t, e) {
    switch (typeof t) {
        case "bigint":
            return t;
        case "number":
            return W(Number.isInteger(t), "underflow", e || "value", t), W(t >= -lo && t <= lo, "overflow", e || "value", t), BigInt(t);
        case "string":
            try {
                if (t === "") throw new Error("empty string");
                return t[0] === "-" && t[1] !== "-" ? -BigInt(t.substring(1)) : BigInt(t)
            } catch (n) {
                W(!1, `invalid BigNumberish string: ${n.message}`, e || "value", t)
            }
    }
    W(!1, "invalid BigNumberish value", e || "value", t)
}

function Uu(t, e) {
    const n = Le(t, e);
    return re(n >= Fu, "unsigned value cannot be negative", "NUMERIC_FAULT", {
        fault: "overflow",
        operation: "getUint",
        value: t
    }), n
}
const G0 = "0123456789abcdef";

function Hu(t) {
    if (t instanceof Uint8Array) {
        let e = "0x0";
        for (const n of t) e += G0[n >> 4], e += G0[n & 15];
        return BigInt(e)
    }
    return Le(t)
}

function $e(t, e) {
    switch (typeof t) {
        case "bigint":
            return W(t >= -lo && t <= lo, "overflow", e || "value", t), Number(t);
        case "number":
            return W(Number.isInteger(t), "underflow", e || "value", t), W(t >= -lo && t <= lo, "overflow", e || "value", t), t;
        case "string":
            try {
                if (t === "") throw new Error("empty string");
                return $e(BigInt(t), e)
            } catch (n) {
                W(!1, `invalid numeric string: ${n.message}`, e || "value", t)
            }
    }
    W(!1, "invalid numeric value", e || "value", t)
}

function eE(t) {
    return $e(Hu(t))
}

function Vi(t, e) {
    let r = Uu(t, "value").toString(16);
    if (e == null) r.length % 2 && (r = "0" + r);
    else {
        const i = $e(e, "width");
        for (re(i * 2 >= r.length, `value exceeds width (${i} bytes)`, "NUMERIC_FAULT", {
                operation: "toBeHex",
                fault: "overflow",
                value: t
            }); r.length < i * 2;) r = "0" + r
    }
    return "0x" + r
}

function _n(t) {
    const e = Uu(t, "value");
    if (e === Fu) return new Uint8Array([]);
    let n = e.toString(16);
    n.length % 2 && (n = "0" + n);
    const r = new Uint8Array(n.length / 2);
    for (let i = 0; i < r.length; i++) {
        const s = i * 2;
        r[i] = parseInt(n.substring(s, s + 2), 16)
    }
    return r
}

function co(t) {
    let e = De($3(t) ? t : _n(t)).substring(2);
    for (; e.startsWith("0");) e = e.substring(1);
    return e === "" && (e = "0"), "0x" + e
}
const tE = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
BigInt(0);
const W0 = BigInt(58);

function nE(t) {
    let e = Hu(qe(t)),
        n = "";
    for (; e;) n = tE[Number(e % W0)] + n, e /= W0;
    return n
}

function rb(t) {
    t = atob(t);
    const e = new Uint8Array(t.length);
    for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
    return qe(e)
}

function rE(t) {
    const e = qe(t);
    let n = "";
    for (let r = 0; r < e.length; r++) n += String.fromCharCode(e[r]);
    return btoa(n)
}
class ib {
    filter;
    emitter;#
    e;
    constructor(e, n, r) {
        this.#e = n, Ue(this, {
            emitter: e,
            filter: r
        })
    }
    async removeListener() {
        this.#e != null && await this.emitter.off(this.filter, this.#e)
    }
}

function iE(t, e, n, r, i) {
    W(!1, `invalid codepoint at offset ${e}; ${t}`, "bytes", n)
}

function sb(t, e, n, r, i) {
    if (t === "BAD_PREFIX" || t === "UNEXPECTED_CONTINUE") {
        let s = 0;
        for (let o = e + 1; o < n.length && n[o] >> 6 === 2; o++) s++;
        return s
    }
    return t === "OVERRUN" ? n.length - e - 1 : 0
}

function sE(t, e, n, r, i) {
    return t === "OVERLONG" ? (W(typeof i == "number", "invalid bad code point for replacement", "badCodepoint", i), r.push(i), 0) : (r.push(65533), sb(t, e, n))
}
const oE = Object.freeze({
    error: iE,
    ignore: sb,
    replace: sE
});

function aE(t, e) {
    e == null && (e = oE.error);
    const n = qe(t, "bytes"),
        r = [];
    let i = 0;
    for (; i < n.length;) {
        const s = n[i++];
        if (!(s >> 7)) {
            r.push(s);
            continue
        }
        let o = null,
            a = null;
        if ((s & 224) === 192) o = 1, a = 127;
        else if ((s & 240) === 224) o = 2, a = 2047;
        else if ((s & 248) === 240) o = 3, a = 65535;
        else {
            (s & 192) === 128 ? i += e("UNEXPECTED_CONTINUE", i - 1, n, r) : i += e("BAD_PREFIX", i - 1, n, r);
            continue
        }
        if (i - 1 + o >= n.length) {
            i += e("OVERRUN", i - 1, n, r);
            continue
        }
        let c = s & (1 << 8 - o - 1) - 1;
        for (let l = 0; l < o; l++) {
            let u = n[i];
            if ((u & 192) != 128) {
                i += e("MISSING_CONTINUE", i, n, r), c = null;
                break
            }
            c = c << 6 | u & 63, i++
        }
        if (c !== null) {
            if (c > 1114111) {
                i += e("OUT_OF_RANGE", i - 1 - o, n, r, c);
                continue
            }
            if (c >= 55296 && c <= 57343) {
                i += e("UTF16_SURROGATE", i - 1 - o, n, r, c);
                continue
            }
            if (c <= a) {
                i += e("OVERLONG", i - 1 - o, n, r, c);
                continue
            }
            r.push(c)
        }
    }
    return r
}

function Nr(t, e) {
    e != null && (q3(e), t = t.normalize(e));
    let n = [];
    for (let r = 0; r < t.length; r++) {
        const i = t.charCodeAt(r);
        if (i < 128) n.push(i);
        else if (i < 2048) n.push(i >> 6 | 192), n.push(i & 63 | 128);
        else if ((i & 64512) == 55296) {
            r++;
            const s = t.charCodeAt(r);
            W(r < t.length && (s & 64512) === 56320, "invalid surrogate pair", "str", t);
            const o = 65536 + ((i & 1023) << 10) + (s & 1023);
            n.push(o >> 18 | 240), n.push(o >> 12 & 63 | 128), n.push(o >> 6 & 63 | 128), n.push(o & 63 | 128)
        } else n.push(i >> 12 | 224), n.push(i >> 6 & 63 | 128), n.push(i & 63 | 128)
    }
    return new Uint8Array(n)
}

function lE(t) {
    return t.map(e => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("")
}

function vp(t, e) {
    return lE(aE(t, e))
}

function ob(t) {
    async function e(n, r) {
        const i = n.url.split(":")[0].toLowerCase();
        re(i === "http" || i === "https", `unsupported protocol ${i}`, "UNSUPPORTED_OPERATION", {
            info: {
                protocol: i
            },
            operation: "request"
        }), re(i === "https" || !n.credentials || n.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
            operation: "request"
        });
        let s;
        if (r) {
            const f = new AbortController;
            s = f.signal, r.addListener(() => {
                f.abort()
            })
        }
        const o = {
                method: n.method,
                headers: new Headers(Array.from(n)),
                body: n.body || void 0,
                signal: s
            },
            a = await fetch(n.url, o),
            c = {};
        a.headers.forEach((f, d) => {
            c[d.toLowerCase()] = f
        });
        const l = await a.arrayBuffer(),
            u = l == null ? null : new Uint8Array(l);
        return {
            statusCode: a.status,
            statusMessage: a.statusText,
            headers: c,
            body: u
        }
    }
    return e
}
const cE = 12,
    uE = 250;
let Q0 = ob();
const fE = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"),
    dE = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
let Mf = !1;
async function ab(t, e) {
    try {
        const n = t.match(fE);
        if (!n) throw new Error("invalid data");
        return new Li(200, "OK", {
            "content-type": n[1] || "text/plain"
        }, n[2] ? rb(n[3]) : pE(n[3]))
    } catch {
        return new Li(599, "BAD REQUEST (invalid data: URI)", {}, null, new Ir(t))
    }
}

function lb(t) {
    async function e(n, r) {
        try {
            const i = n.match(dE);
            if (!i) throw new Error("invalid link");
            return new Ir(`${t}${i[2]}`)
        } catch {
            return new Li(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new Ir(n))
        }
    }
    return e
}
const nc = {
        data: ab,
        ipfs: lb("https://gateway.ipfs.io/ipfs/")
    },
    cb = new WeakMap;
class hE {#
    e;#
    t;
    constructor(e) {
        this.#e = [], this.#t = !1, cb.set(e, () => {
            if (!this.#t) {
                this.#t = !0;
                for (const n of this.#e) setTimeout(() => {
                    n()
                }, 0);
                this.#e = []
            }
        })
    }
    addListener(e) {
        re(!this.#t, "singal already cancelled", "UNSUPPORTED_OPERATION", {
            operation: "fetchCancelSignal.addCancelListener"
        }), this.#e.push(e)
    }
    get cancelled() {
        return this.#t
    }
    checkSignal() {
        re(!this.cancelled, "cancelled", "CANCELLED", {})
    }
}

function rc(t) {
    if (t == null) throw new Error("missing signal; should not happen");
    return t.checkSignal(), t
}
class Ir {#
    e;#
    t;#
    n;#
    r;#
    i;#
    s;#
    o;#
    a;#
    u;#
    c;#
    f;#
    d;#
    l;#
    h;#
    m;
    get url() {
        return this.#s
    }
    set url(e) {
        this.#s = String(e)
    }
    get body() {
        return this.#o == null ? null : new Uint8Array(this.#o)
    }
    set body(e) {
        if (e == null) this.#o = void 0, this.#a = void 0;
        else if (typeof e == "string") this.#o = Nr(e), this.#a = "text/plain";
        else if (e instanceof Uint8Array) this.#o = e, this.#a = "application/octet-stream";
        else if (typeof e == "object") this.#o = Nr(JSON.stringify(e)), this.#a = "application/json";
        else throw new Error("invalid body")
    }
    hasBody() {
        return this.#o != null
    }
    get method() {
        return this.#r ? this.#r : this.hasBody() ? "POST" : "GET"
    }
    set method(e) {
        e == null && (e = ""), this.#r = String(e).toUpperCase()
    }
    get headers() {
        const e = Object.assign({}, this.#n);
        return this.#u && (e.authorization = `Basic ${rE(Nr(this.#u))}`), this.allowGzip && (e["accept-encoding"] = "gzip"), e["content-type"] == null && this.#a && (e["content-type"] = this.#a), this.body && (e["content-length"] = String(this.body.length)), e
    }
    getHeader(e) {
        return this.headers[e.toLowerCase()]
    }
    setHeader(e, n) {
        this.#n[String(e).toLowerCase()] = String(n)
    }
    clearHeaders() {
        this.#n = {}
    }[Symbol.iterator]() {
        const e = this.headers,
            n = Object.keys(e);
        let r = 0;
        return {
            next: () => {
                if (r < n.length) {
                    const i = n[r++];
                    return {
                        value: [i, e[i]],
                        done: !1
                    }
                }
                return {
                    value: void 0,
                    done: !0
                }
            }
        }
    }
    get credentials() {
        return this.#u || null
    }
    setCredentials(e, n) {
        W(!e.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), this.#u = `${e}:${n}`
    }
    get allowGzip() {
        return this.#t
    }
    set allowGzip(e) {
        this.#t = !!e
    }
    get allowInsecureAuthentication() {
        return !!this.#e
    }
    set allowInsecureAuthentication(e) {
        this.#e = !!e
    }
    get timeout() {
        return this.#i
    }
    set timeout(e) {
        W(e >= 0, "timeout must be non-zero", "timeout", e), this.#i = e
    }
    get preflightFunc() {
        return this.#c || null
    }
    set preflightFunc(e) {
        this.#c = e
    }
    get processFunc() {
        return this.#f || null
    }
    set processFunc(e) {
        this.#f = e
    }
    get retryFunc() {
        return this.#d || null
    }
    set retryFunc(e) {
        this.#d = e
    }
    get getUrlFunc() {
        return this.#m || Q0
    }
    set getUrlFunc(e) {
        this.#m = e
    }
    constructor(e) {
        this.#s = String(e), this.#e = !1, this.#t = !0, this.#n = {}, this.#r = "", this.#i = 3e5, this.#h = {
            slotInterval: uE,
            maxAttempts: cE
        }, this.#m = null
    }
    toString() {
        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#o?De(this.#o):"null"}>`
    }
    setThrottleParams(e) {
        e.slotInterval != null && (this.#h.slotInterval = e.slotInterval), e.maxAttempts != null && (this.#h.maxAttempts = e.maxAttempts)
    }
    async# p(e, n, r, i, s) {
        if (e >= this.#h.maxAttempts) return s.makeServerError("exceeded maximum retry limit");
        re(J0() <= n, "timeout", "TIMEOUT", {
            operation: "request.send",
            reason: "timeout",
            request: i
        }), r > 0 && await mE(r);
        let o = this.clone();
        const a = (o.url.split(":")[0] || "").toLowerCase();
        if (a in nc) {
            const u = await nc[a](o.url, rc(i.#l));
            if (u instanceof Li) {
                let f = u;
                if (this.processFunc) {
                    rc(i.#l);
                    try {
                        f = await this.processFunc(o, f)
                    } catch (d) {
                        (d.throttle == null || typeof d.stall != "number") && f.makeServerError("error in post-processing function", d).assertOk()
                    }
                }
                return f
            }
            o = u
        }
        this.preflightFunc && (o = await this.preflightFunc(o));
        const c = await this.getUrlFunc(o, rc(i.#l));
        let l = new Li(c.statusCode, c.statusMessage, c.headers, c.body, i);
        if (l.statusCode === 301 || l.statusCode === 302) {
            try {
                const u = l.headers.location || "";
                return o.redirect(u).#p(e + 1, n, 0, i, l)
            } catch {}
            return l
        } else if (l.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(o, l, e))) {
            const u = l.headers["retry-after"];
            let f = this.#h.slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
            return typeof u == "string" && u.match(/^[1-9][0-9]*$/) && (f = parseInt(u)), o.clone().#p(e + 1, n, f, i, l)
        }
        if (this.processFunc) {
            rc(i.#l);
            try {
                l = await this.processFunc(o, l)
            } catch (u) {
                (u.throttle == null || typeof u.stall != "number") && l.makeServerError("error in post-processing function", u).assertOk();
                let f = this.#h.slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
                return u.stall >= 0 && (f = u.stall), o.clone().#p(e + 1, n, f, i, l)
            }
        }
        return l
    }
    send() {
        return re(this.#l == null, "request already sent", "UNSUPPORTED_OPERATION", {
            operation: "fetchRequest.send"
        }), this.#l = new hE(this), this.#p(0, J0() + this.timeout, 0, this, new Li(0, "", {}, null, this))
    }
    cancel() {
        re(this.#l != null, "request has not been sent", "UNSUPPORTED_OPERATION", {
            operation: "fetchRequest.cancel"
        });
        const e = cb.get(this);
        if (!e) throw new Error("missing signal; should not happen");
        e()
    }
    redirect(e) {
        const n = this.url.split(":")[0].toLowerCase(),
            r = e.split(":")[0].toLowerCase();
        re(this.method === "GET" && (n !== "https" || r !== "http") && e.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
            operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(e)})`
        });
        const i = new Ir(e);
        return i.method = "GET", i.allowGzip = this.allowGzip, i.timeout = this.timeout, i.#n = Object.assign({}, this.#n), this.#o && (i.#o = new Uint8Array(this.#o)), i.#a = this.#a, i
    }
    clone() {
        const e = new Ir(this.url);
        return e.#r = this.#r, this.#o && (e.#o = this.#o), e.#a = this.#a, e.#n = Object.assign({}, this.#n), e.#u = this.#u, this.allowGzip && (e.allowGzip = !0), e.timeout = this.timeout, this.allowInsecureAuthentication && (e.allowInsecureAuthentication = !0), e.#c = this.#c, e.#f = this.#f, e.#d = this.#d, e.#m = this.#m, e
    }
    static lockConfig() {
        Mf = !0
    }
    static getGateway(e) {
        return nc[e.toLowerCase()] || null
    }
    static registerGateway(e, n) {
        if (e = e.toLowerCase(), e === "http" || e === "https") throw new Error(`cannot intercept ${e}; use registerGetUrl`);
        if (Mf) throw new Error("gateways locked");
        nc[e] = n
    }
    static registerGetUrl(e) {
        if (Mf) throw new Error("gateways locked");
        Q0 = e
    }
    static createGetUrlFunc(e) {
        return ob()
    }
    static createDataGateway() {
        return ab
    }
    static createIpfsGatewayFunc(e) {
        return lb(e)
    }
}
class Li {#
    e;#
    t;#
    n;#
    r;#
    i;#
    s;
    toString() {
        return `<FetchResponse status=${this.statusCode} body=${this.#r?De(this.#r):"null"}>`
    }
    get statusCode() {
        return this.#e
    }
    get statusMessage() {
        return this.#t
    }
    get headers() {
        return Object.assign({}, this.#n)
    }
    get body() {
        return this.#r == null ? null : new Uint8Array(this.#r)
    }
    get bodyText() {
        try {
            return this.#r == null ? "" : vp(this.#r)
        } catch {
            re(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
                operation: "bodyText",
                info: {
                    response: this
                }
            })
        }
    }
    get bodyJson() {
        try {
            return JSON.parse(this.bodyText)
        } catch {
            re(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
                operation: "bodyJson",
                info: {
                    response: this
                }
            })
        }
    }[Symbol.iterator]() {
        const e = this.headers,
            n = Object.keys(e);
        let r = 0;
        return {
            next: () => {
                if (r < n.length) {
                    const i = n[r++];
                    return {
                        value: [i, e[i]],
                        done: !1
                    }
                }
                return {
                    value: void 0,
                    done: !0
                }
            }
        }
    }
    constructor(e, n, r, i, s) {
        this.#e = e, this.#t = n, this.#n = Object.keys(r).reduce((o, a) => (o[a.toLowerCase()] = String(r[a]), o), {}), this.#r = i == null ? null : new Uint8Array(i), this.#i = s || null, this.#s = {
            message: ""
        }
    }
    makeServerError(e, n) {
        let r;
        e ? r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})` : (e = `${this.statusCode} ${this.statusMessage}`, r = `CLIENT ESCALATED SERVER ERROR (${e})`);
        const i = new Li(599, r, this.headers, this.body, this.#i || void 0);
        return i.#s = {
            message: e,
            error: n
        }, i
    }
    throwThrottleError(e, n) {
        n == null ? n = -1 : W(Number.isInteger(n) && n >= 0, "invalid stall timeout", "stall", n);
        const r = new Error(e || "throttling requests");
        throw Ue(r, {
            stall: n,
            throttle: !0
        }), r
    }
    getHeader(e) {
        return this.headers[e.toLowerCase()]
    }
    hasBody() {
        return this.#r != null
    }
    get request() {
        return this.#i
    }
    ok() {
        return this.#s.message === "" && this.statusCode >= 200 && this.statusCode < 300
    }
    assertOk() {
        if (this.ok()) return;
        let {
            message: e,
            error: n
        } = this.#s;
        e === "" && (e = `server response ${this.statusCode} ${this.statusMessage}`), re(!1, e, "SERVER_ERROR", {
            request: this.request || "unknown request",
            response: this,
            error: n
        })
    }
}

function J0() {
    return new Date().getTime()
}

function pE(t) {
    return Nr(t.replace(/%([0-9a-f][0-9a-f])/gi, (e, n) => String.fromCharCode(parseInt(n, 16))))
}

function mE(t) {
    return new Promise(e => setTimeout(e, t))
}
const gE = BigInt(-1),
    rr = BigInt(0),
    uo = BigInt(1),
    yE = BigInt(5),
    qs = {};
let wo = "0000";
for (; wo.length < 80;) wo += wo;

function rs(t) {
    let e = wo;
    for (; e.length < t;) e += e;
    return BigInt("1" + e.substring(0, t))
}

function aa(t, e, n) {
    const r = BigInt(e.width);
    if (e.signed) {
        const i = uo << r - uo;
        re(n == null || t >= -i && t < i, "overflow", "NUMERIC_FAULT", {
            operation: n,
            fault: "overflow",
            value: t
        }), t > rr ? t = nu(hs(t, r), r) : t = -nu(hs(-t, r), r)
    } else {
        const i = uo << r;
        re(n == null || t >= 0 && t < i, "overflow", "NUMERIC_FAULT", {
            operation: n,
            fault: "overflow",
            value: t
        }), t = (t % i + i) % i & i - uo
    }
    return t
}

function Ff(t) {
    typeof t == "number" && (t = `fixed128x${t}`);
    let e = !0,
        n = 128,
        r = 18;
    if (typeof t == "string") {
        if (t !== "fixed")
            if (t === "ufixed") e = !1;
            else {
                const s = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                W(s, "invalid fixed format", "format", t), e = s[1] !== "u", n = parseInt(s[2]), r = parseInt(s[3])
            }
    } else if (t) {
        const s = t,
            o = (a, c, l) => s[a] == null ? l : (W(typeof s[a] === c, "invalid fixed format (" + a + " not " + c + ")", "format." + a, s[a]), s[a]);
        e = o("signed", "boolean", e), n = o("width", "number", n), r = o("decimals", "number", r)
    }
    W(n % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", n), W(r <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", r);
    const i = (e ? "" : "u") + "fixed" + String(n) + "x" + String(r);
    return {
        signed: e,
        width: n,
        decimals: r,
        name: i
    }
}

function vE(t, e) {
    let n = "";
    t < rr && (n = "-", t *= gE);
    let r = t.toString();
    if (e === 0) return n + r;
    for (; r.length <= e;) r = wo + r;
    const i = r.length - e;
    for (r = r.substring(0, i) + "." + r.substring(i); r[0] === "0" && r[1] !== ".";) r = r.substring(1);
    for (; r[r.length - 1] === "0" && r[r.length - 2] !== ".";) r = r.substring(0, r.length - 1);
    return n + r
}
class Ci {
    format;#
    e;#
    t;#
    n;
    _value;
    constructor(e, n, r) {
        wl(e, qs, "FixedNumber"), this.#t = n, this.#e = r;
        const i = vE(n, r.decimals);
        Ue(this, {
            format: r.name,
            _value: i
        }), this.#n = rs(r.decimals)
    }
    get signed() {
        return this.#e.signed
    }
    get width() {
        return this.#e.width
    }
    get decimals() {
        return this.#e.decimals
    }
    get value() {
        return this.#t
    }#
    r(e) {
        W(this.format === e.format, "incompatible format; use fixedNumber.toFormat", "other", e)
    }#
    i(e, n) {
        return e = aa(e, this.#e, n), new Ci(qs, e, this.#e)
    }#
    s(e, n) {
        return this.#r(e), this.#i(this.#t + e.#t, n)
    }
    addUnsafe(e) {
        return this.#s(e)
    }
    add(e) {
        return this.#s(e, "add")
    }#
    o(e, n) {
        return this.#r(e), this.#i(this.#t - e.#t, n)
    }
    subUnsafe(e) {
        return this.#o(e)
    }
    sub(e) {
        return this.#o(e, "sub")
    }#
    a(e, n) {
        return this.#r(e), this.#i(this.#t * e.#t / this.#n, n)
    }
    mulUnsafe(e) {
        return this.#a(e)
    }
    mul(e) {
        return this.#a(e, "mul")
    }
    mulSignal(e) {
        this.#r(e);
        const n = this.#t * e.#t;
        return re(n % this.#n === rr, "precision lost during signalling mul", "NUMERIC_FAULT", {
            operation: "mulSignal",
            fault: "underflow",
            value: this
        }), this.#i(n / this.#n, "mulSignal")
    }#
    u(e, n) {
        return re(e.#t !== rr, "division by zero", "NUMERIC_FAULT", {
            operation: "div",
            fault: "divide-by-zero",
            value: this
        }), this.#r(e), this.#i(this.#t * this.#n / e.#t, n)
    }
    divUnsafe(e) {
        return this.#u(e)
    }
    div(e) {
        return this.#u(e, "div")
    }
    divSignal(e) {
        re(e.#t !== rr, "division by zero", "NUMERIC_FAULT", {
            operation: "div",
            fault: "divide-by-zero",
            value: this
        }), this.#r(e);
        const n = this.#t * this.#n;
        return re(n % e.#t === rr, "precision lost during signalling div", "NUMERIC_FAULT", {
            operation: "divSignal",
            fault: "underflow",
            value: this
        }), this.#i(n / e.#t, "divSignal")
    }
    cmp(e) {
        let n = this.value,
            r = e.value;
        const i = this.decimals - e.decimals;
        return i > 0 ? r *= rs(i) : i < 0 && (n *= rs(-i)), n < r ? -1 : n > r ? 1 : 0
    }
    eq(e) {
        return this.cmp(e) === 0
    }
    lt(e) {
        return this.cmp(e) < 0
    }
    lte(e) {
        return this.cmp(e) <= 0
    }
    gt(e) {
        return this.cmp(e) > 0
    }
    gte(e) {
        return this.cmp(e) >= 0
    }
    floor() {
        let e = this.#t;
        return this.#t < rr && (e -= this.#n - uo), e = this.#t / this.#n * this.#n, this.#i(e, "floor")
    }
    ceiling() {
        let e = this.#t;
        return this.#t > rr && (e += this.#n - uo), e = this.#t / this.#n * this.#n, this.#i(e, "ceiling")
    }
    round(e) {
        if (e == null && (e = 0), e >= this.decimals) return this;
        const n = this.decimals - e,
            r = yE * rs(n - 1);
        let i = this.value + r;
        const s = rs(n);
        return i = i / s * s, aa(i, this.#e, "round"), new Ci(qs, i, this.#e)
    }
    isZero() {
        return this.#t === rr
    }
    isNegative() {
        return this.#t < rr
    }
    toString() {
        return this._value
    }
    toUnsafeFloat() {
        return parseFloat(this.toString())
    }
    toFormat(e) {
        return Ci.fromString(this.toString(), e)
    }
    static fromValue(e, n, r) {
        const i = n == null ? 0 : $e(n),
            s = Ff(r);
        let o = Le(e, "value");
        const a = i - s.decimals;
        if (a > 0) {
            const c = rs(a);
            re(o % c === rr, "value loses precision for format", "NUMERIC_FAULT", {
                operation: "fromValue",
                fault: "underflow",
                value: e
            }), o /= c
        } else a < 0 && (o *= rs(-a));
        return aa(o, s, "fromValue"), new Ci(qs, o, s)
    }
    static fromString(e, n) {
        const r = e.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
        W(r && r[2].length + r[3].length > 0, "invalid FixedNumber string value", "value", e);
        const i = Ff(n);
        let s = r[2] || "0",
            o = r[3] || "";
        for (; o.length < i.decimals;) o += wo;
        re(o.substring(i.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
            operation: "fromString",
            fault: "underflow",
            value: e
        }), o = o.substring(0, i.decimals);
        const a = BigInt(r[1] + s + o);
        return aa(a, i, "fromString"), new Ci(qs, a, i)
    }
    static fromBytes(e, n) {
        let r = Hu(qe(e, "value"));
        const i = Ff(n);
        return i.signed && (r = nu(r, i.width)), aa(r, i, "fromBytes"), new Ci(qs, r, i)
    }
}

function bE(t) {
    let e = t.toString(16);
    for (; e.length < 2;) e = "0" + e;
    return "0x" + e
}

function K0(t, e, n) {
    let r = 0;
    for (let i = 0; i < n; i++) r = r * 256 + t[e + i];
    return r
}

function Z0(t, e, n, r) {
    const i = [];
    for (; n < e + 1 + r;) {
        const s = ub(t, n);
        i.push(s.result), n += s.consumed, re(n <= e + 1 + r, "child data too short", "BUFFER_OVERRUN", {
            buffer: t,
            length: r,
            offset: e
        })
    }
    return {
        consumed: 1 + r,
        result: i
    }
}

function ub(t, e) {
    re(t.length !== 0, "data too short", "BUFFER_OVERRUN", {
        buffer: t,
        length: 0,
        offset: 1
    });
    const n = r => {
        re(r <= t.length, "data short segment too short", "BUFFER_OVERRUN", {
            buffer: t,
            length: t.length,
            offset: r
        })
    };
    if (t[e] >= 248) {
        const r = t[e] - 247;
        n(e + 1 + r);
        const i = K0(t, e + 1, r);
        return n(e + 1 + r + i), Z0(t, e, e + 1 + r, r + i)
    } else if (t[e] >= 192) {
        const r = t[e] - 192;
        return n(e + 1 + r), Z0(t, e, e + 1, r)
    } else if (t[e] >= 184) {
        const r = t[e] - 183;
        n(e + 1 + r);
        const i = K0(t, e + 1, r);
        n(e + 1 + r + i);
        const s = De(t.slice(e + 1 + r, e + 1 + r + i));
        return {
            consumed: 1 + r + i,
            result: s
        }
    } else if (t[e] >= 128) {
        const r = t[e] - 128;
        n(e + 1 + r);
        const i = De(t.slice(e + 1, e + 1 + r));
        return {
            consumed: 1 + r,
            result: i
        }
    }
    return {
        consumed: 1,
        result: bE(t[e])
    }
}

function bp(t) {
    const e = qe(t, "data"),
        n = ub(e, 0);
    return W(n.consumed === e.length, "unexpected junk after rlp payload", "data", t), n.result
}

function Y0(t) {
    const e = [];
    for (; t;) e.unshift(t & 255), t >>= 8;
    return e
}

function fb(t) {
    if (Array.isArray(t)) {
        let r = [];
        if (t.forEach(function(s) {
                r = r.concat(fb(s))
            }), r.length <= 55) return r.unshift(192 + r.length), r;
        const i = Y0(r.length);
        return i.unshift(247 + i.length), i.concat(r)
    }
    const e = Array.prototype.slice.call(qe(t, "object"));
    if (e.length === 1 && e[0] <= 127) return e;
    if (e.length <= 55) return e.unshift(128 + e.length), e;
    const n = Y0(e.length);
    return n.unshift(183 + n.length), n.concat(e)
}
const X0 = "0123456789abcdef";

function Ga(t) {
    let e = "0x";
    for (const n of fb(t)) e += X0[n >> 4], e += X0[n & 15];
    return e
}
const wE = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];

function xE(t, e) {
    let n = 18;
    if (typeof e == "string") {
        const r = wE.indexOf(e);
        W(r >= 0, "invalid unit", "unit", e), n = 3 * r
    } else e != null && (n = $e(e, "unit"));
    return Ci.fromValue(t, n, {
        decimals: n,
        width: 512
    }).toString()
}

function db(t) {
    return xE(t, 18)
}
const hn = 32,
    Jd = new Uint8Array(hn),
    AE = ["then"],
    ic = {};

function la(t, e) {
    const n = new Error(`deferred error during ABI decoding triggered accessing ${t}`);
    throw n.error = e, n
}
class xo extends Array {#
    e;
    constructor(...e) {
        const n = e[0];
        let r = e[1],
            i = (e[2] || []).slice(),
            s = !0;
        n !== ic && (r = e, i = [], s = !1), super(r.length), r.forEach((a, c) => {
            this[c] = a
        });
        const o = i.reduce((a, c) => (typeof c == "string" && a.set(c, (a.get(c) || 0) + 1), a), new Map);
        if (this.#e = Object.freeze(r.map((a, c) => {
                const l = i[c];
                return l != null && o.get(l) === 1 ? l : null
            })), !!s) return Object.freeze(this), new Proxy(this, {
            get: (a, c, l) => {
                if (typeof c == "string") {
                    if (c.match(/^[0-9]+$/)) {
                        const f = $e(c, "%index");
                        if (f < 0 || f >= this.length) throw new RangeError("out of result range");
                        const d = a[f];
                        return d instanceof Error && la(`index ${f}`, d), d
                    }
                    if (AE.indexOf(c) >= 0) return Reflect.get(a, c, l);
                    const u = a[c];
                    if (u instanceof Function) return function(...f) {
                        return u.apply(this === l ? a : this, f)
                    };
                    if (!(c in a)) return a.getValue.apply(this === l ? a : this, [c])
                }
                return Reflect.get(a, c, l)
            }
        })
    }
    toArray() {
        const e = [];
        return this.forEach((n, r) => {
            n instanceof Error && la(`index ${r}`, n), e.push(n)
        }), e
    }
    toObject() {
        return this.#e.reduce((e, n, r) => (re(n != null, "value at index ${ index } unnamed", "UNSUPPORTED_OPERATION", {
            operation: "toObject()"
        }), n in e || (e[n] = this.getValue(n)), e), {})
    }
    slice(e, n) {
        e == null && (e = 0), e < 0 && (e += this.length, e < 0 && (e = 0)), n == null && (n = this.length), n < 0 && (n += this.length, n < 0 && (n = 0)), n > this.length && (n = this.length);
        const r = [],
            i = [];
        for (let s = e; s < n; s++) r.push(this[s]), i.push(this.#e[s]);
        return new xo(ic, r, i)
    }
    filter(e, n) {
        const r = [],
            i = [];
        for (let s = 0; s < this.length; s++) {
            const o = this[s];
            o instanceof Error && la(`index ${s}`, o), e.call(n, o, s, this) && (r.push(o), i.push(this.#e[s]))
        }
        return new xo(ic, r, i)
    }
    map(e, n) {
        const r = [];
        for (let i = 0; i < this.length; i++) {
            const s = this[i];
            s instanceof Error && la(`index ${i}`, s), r.push(e.call(n, s, i, this))
        }
        return r
    }
    getValue(e) {
        const n = this.#e.indexOf(e);
        if (n === -1) return;
        const r = this[n];
        return r instanceof Error && la(`property ${JSON.stringify(e)}`, r.error), r
    }
    static fromItems(e, n) {
        return new xo(ic, e, n)
    }
}

function q0(t) {
    let e = _n(t);
    return re(e.length <= hn, "value out-of-bounds", "BUFFER_OVERRUN", {
        buffer: e,
        length: hn,
        offset: e.length
    }), e.length !== hn && (e = kn(Ht([Jd.slice(e.length % hn), e]))), e
}
class di {
    name;
    type;
    localName;
    dynamic;
    constructor(e, n, r, i) {
        Ue(this, {
            name: e,
            type: n,
            localName: r,
            dynamic: i
        }, {
            name: "string",
            type: "string",
            localName: "string",
            dynamic: "boolean"
        })
    }
    _throwError(e, n) {
        W(!1, e, this.localName, n)
    }
}
class Kd {#
    e;#
    t;
    constructor() {
        this.#e = [], this.#t = 0
    }
    get data() {
        return Ht(this.#e)
    }
    get length() {
        return this.#t
    }#
    n(e) {
        return this.#e.push(e), this.#t += e.length, e.length
    }
    appendWriter(e) {
        return this.#n(kn(e.data))
    }
    writeBytes(e) {
        let n = kn(e);
        const r = n.length % hn;
        return r && (n = kn(Ht([n, Jd.slice(r)]))), this.#n(n)
    }
    writeValue(e) {
        return this.#n(q0(e))
    }
    writeUpdatableValue() {
        const e = this.#e.length;
        return this.#e.push(Jd), this.#t += hn, n => {
            this.#e[e] = q0(n)
        }
    }
}
class wp {
    allowLoose;#
    e;#
    t;
    constructor(e, n) {
        Ue(this, {
            allowLoose: !!n
        }), this.#e = kn(e), this.#t = 0
    }
    get data() {
        return De(this.#e)
    }
    get dataLength() {
        return this.#e.length
    }
    get consumed() {
        return this.#t
    }
    get bytes() {
        return new Uint8Array(this.#e)
    }#
    n(e, n, r) {
        let i = Math.ceil(n / hn) * hn;
        return this.#t + i > this.#e.length && (this.allowLoose && r && this.#t + n <= this.#e.length ? i = n : re(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
            buffer: kn(this.#e),
            length: this.#e.length,
            offset: this.#t + i
        })), this.#e.slice(this.#t, this.#t + i)
    }
    subReader(e) {
        return new wp(this.#e.slice(this.#t + e), this.allowLoose)
    }
    readBytes(e, n) {
        let r = this.#n(0, e, !!n);
        return this.#t += r.length, r.slice(0, e)
    }
    readValue() {
        return Hu(this.readBytes(hn))
    }
    readIndex() {
        return eE(this.readBytes(hn))
    }
}

function ru(t) {
    if (!Number.isSafeInteger(t) || t < 0) throw new Error(`Wrong positive integer: ${t}`)
}

function xp(t, ...e) {
    if (!(t instanceof Uint8Array)) throw new Error("Expected Uint8Array");
    if (e.length > 0 && !e.includes(t.length)) throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)
}

function kE(t) {
    if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    ru(t.outputLen), ru(t.blockLen)
}

function Oo(t, e = !0) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished) throw new Error("Hash#digest() has already been called")
}

function hb(t, e) {
    xp(t);
    const n = e.outputLen;
    if (t.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`)
}
const Uf = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0; /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const pb = t => t instanceof Uint8Array,
    _E = t => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)),
    Hf = t => new DataView(t.buffer, t.byteOffset, t.byteLength),
    mr = (t, e) => t << 32 - e | t >>> e,
    EE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!EE) throw new Error("Non little-endian hardware is not supported");

function PE(t) {
    if (typeof t != "string") throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
    return new Uint8Array(new TextEncoder().encode(t))
}

function zu(t) {
    if (typeof t == "string" && (t = PE(t)), !pb(t)) throw new Error(`expected Uint8Array, got ${typeof t}`);
    return t
}

function SE(...t) {
    const e = new Uint8Array(t.reduce((r, i) => r + i.length, 0));
    let n = 0;
    return t.forEach(r => {
        if (!pb(r)) throw new Error("Uint8Array expected");
        e.set(r, n), n += r.length
    }), e
}
class Ap {
    clone() {
        return this._cloneInto()
    }
}

function mb(t) {
    const e = r => t().update(zu(r)).digest(),
        n = t();
    return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e
}

function NE(t = 32) {
    if (Uf && typeof Uf.getRandomValues == "function") return Uf.getRandomValues(new Uint8Array(t));
    throw new Error("crypto.getRandomValues must be defined")
}
class gb extends Ap {
    constructor(e, n) {
        super(), this.finished = !1, this.destroyed = !1, kE(e);
        const r = zu(n);
        if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const i = this.blockLen,
            s = new Uint8Array(i);
        s.set(r.length > i ? e.create().update(r).digest() : r);
        for (let o = 0; o < s.length; o++) s[o] ^= 54;
        this.iHash.update(s), this.oHash = e.create();
        for (let o = 0; o < s.length; o++) s[o] ^= 106;
        this.oHash.update(s), s.fill(0)
    }
    update(e) {
        return Oo(this), this.iHash.update(e), this
    }
    digestInto(e) {
        Oo(this), xp(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy()
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const {
            oHash: n,
            iHash: r,
            finished: i,
            destroyed: s,
            blockLen: o,
            outputLen: a
        } = this;
        return e = e, e.finished = i, e.destroyed = s, e.blockLen = o, e.outputLen = a, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
    }
}
const yb = (t, e, n) => new gb(t, e).update(n).digest();
yb.create = (t, e) => new gb(t, e);

function RE(t, e, n, r) {
    if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n, r);
    const i = BigInt(32),
        s = BigInt(4294967295),
        o = Number(n >> i & s),
        a = Number(n & s),
        c = r ? 4 : 0,
        l = r ? 0 : 4;
    t.setUint32(e + c, o, r), t.setUint32(e + l, a, r)
}
class CE extends Ap {
    constructor(e, n, r, i) {
        super(), this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Hf(this.buffer)
    }
    update(e) {
        Oo(this);
        const {
            view: n,
            buffer: r,
            blockLen: i
        } = this;
        e = zu(e);
        const s = e.length;
        for (let o = 0; o < s;) {
            const a = Math.min(i - this.pos, s - o);
            if (a === i) {
                const c = Hf(e);
                for (; i <= s - o; o += i) this.process(c, o);
                continue
            }
            r.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(n, 0), this.pos = 0)
        }
        return this.length += e.length, this.roundClean(), this
    }
    digestInto(e) {
        Oo(this), hb(e, this), this.finished = !0;
        const {
            buffer: n,
            view: r,
            blockLen: i,
            isLE: s
        } = this;
        let {
            pos: o
        } = this;
        n[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(r, 0), o = 0);
        for (let f = o; f < i; f++) n[f] = 0;
        RE(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
        const a = Hf(e),
            c = this.outputLen;
        if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const l = c / 4,
            u = this.get();
        if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
        for (let f = 0; f < l; f++) a.setUint32(4 * f, u[f], s)
    }
    digest() {
        const {
            buffer: e,
            outputLen: n
        } = this;
        this.digestInto(e);
        const r = e.slice(0, n);
        return this.destroy(), r
    }
    _cloneInto(e) {
        e || (e = new this.constructor), e.set(...this.get());
        const {
            blockLen: n,
            buffer: r,
            length: i,
            finished: s,
            destroyed: o,
            pos: a
        } = this;
        return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % n && e.buffer.set(r), e
    }
}
const OE = (t, e, n) => t & e ^ ~t & n,
    TE = (t, e, n) => t & e ^ t & n ^ e & n,
    BE = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
    wi = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
    xi = new Uint32Array(64);
class IE extends CE {
    constructor() {
        super(64, 32, 8, !1), this.A = wi[0] | 0, this.B = wi[1] | 0, this.C = wi[2] | 0, this.D = wi[3] | 0, this.E = wi[4] | 0, this.F = wi[5] | 0, this.G = wi[6] | 0, this.H = wi[7] | 0
    }
    get() {
        const {
            A: e,
            B: n,
            C: r,
            D: i,
            E: s,
            F: o,
            G: a,
            H: c
        } = this;
        return [e, n, r, i, s, o, a, c]
    }
    set(e, n, r, i, s, o, a, c) {
        this.A = e | 0, this.B = n | 0, this.C = r | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0
    }
    process(e, n) {
        for (let f = 0; f < 16; f++, n += 4) xi[f] = e.getUint32(n, !1);
        for (let f = 16; f < 64; f++) {
            const d = xi[f - 15],
                h = xi[f - 2],
                p = mr(d, 7) ^ mr(d, 18) ^ d >>> 3,
                g = mr(h, 17) ^ mr(h, 19) ^ h >>> 10;
            xi[f] = g + xi[f - 7] + p + xi[f - 16] | 0
        }
        let {
            A: r,
            B: i,
            C: s,
            D: o,
            E: a,
            F: c,
            G: l,
            H: u
        } = this;
        for (let f = 0; f < 64; f++) {
            const d = mr(a, 6) ^ mr(a, 11) ^ mr(a, 25),
                h = u + d + OE(a, c, l) + BE[f] + xi[f] | 0,
                g = (mr(r, 2) ^ mr(r, 13) ^ mr(r, 22)) + TE(r, i, s) | 0;
            u = l, l = c, c = a, a = o + h | 0, o = s, s = i, i = r, r = h + g | 0
        }
        r = r + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, u = u + this.H | 0, this.set(r, i, s, o, a, c, l, u)
    }
    roundClean() {
        xi.fill(0)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
    }
}
const DE = mb(() => new IE),
    sc = BigInt(2 ** 32 - 1),
    $0 = BigInt(32);

function LE(t, e = !1) {
    return e ? {
        h: Number(t & sc),
        l: Number(t >> $0 & sc)
    } : {
        h: Number(t >> $0 & sc) | 0,
        l: Number(t & sc) | 0
    }
}

function ME(t, e = !1) {
    let n = new Uint32Array(t.length),
        r = new Uint32Array(t.length);
    for (let i = 0; i < t.length; i++) {
        const {
            h: s,
            l: o
        } = LE(t[i], e);
        [n[i], r[i]] = [s, o]
    }
    return [n, r]
}
const FE = (t, e, n) => t << n | e >>> 32 - n,
    UE = (t, e, n) => e << n | t >>> 32 - n,
    HE = (t, e, n) => e << n - 32 | t >>> 64 - n,
    zE = (t, e, n) => t << n - 32 | e >>> 64 - n,
    [vb, bb, wb] = [
        [],
        [],
        []
    ],
    jE = BigInt(0),
    ca = BigInt(1),
    VE = BigInt(2),
    GE = BigInt(7),
    WE = BigInt(256),
    QE = BigInt(113);
for (let t = 0, e = ca, n = 1, r = 0; t < 24; t++) {
    [n, r] = [r, (2 * n + 3 * r) % 5], vb.push(2 * (5 * r + n)), bb.push((t + 1) * (t + 2) / 2 % 64);
    let i = jE;
    for (let s = 0; s < 7; s++) e = (e << ca ^ (e >> GE) * QE) % WE, e & VE && (i ^= ca << (ca << BigInt(s)) - ca);
    wb.push(i)
}
const [JE, KE] = ME(wb, !0), eg = (t, e, n) => n > 32 ? HE(t, e, n) : FE(t, e, n), tg = (t, e, n) => n > 32 ? zE(t, e, n) : UE(t, e, n);

function ZE(t, e = 24) {
    const n = new Uint32Array(10);
    for (let r = 24 - e; r < 24; r++) {
        for (let o = 0; o < 10; o++) n[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
        for (let o = 0; o < 10; o += 2) {
            const a = (o + 8) % 10,
                c = (o + 2) % 10,
                l = n[c],
                u = n[c + 1],
                f = eg(l, u, 1) ^ n[a],
                d = tg(l, u, 1) ^ n[a + 1];
            for (let h = 0; h < 50; h += 10) t[o + h] ^= f, t[o + h + 1] ^= d
        }
        let i = t[2],
            s = t[3];
        for (let o = 0; o < 24; o++) {
            const a = bb[o],
                c = eg(i, s, a),
                l = tg(i, s, a),
                u = vb[o];
            i = t[u], s = t[u + 1], t[u] = c, t[u + 1] = l
        }
        for (let o = 0; o < 50; o += 10) {
            for (let a = 0; a < 10; a++) n[a] = t[o + a];
            for (let a = 0; a < 10; a++) t[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10]
        }
        t[0] ^= JE[r], t[1] ^= KE[r]
    }
    n.fill(0)
}
class kp extends Ap {
    constructor(e, n, r, i = !1, s = 24) {
        if (super(), this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, ru(r), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200), this.state32 = _E(this.state)
    }
    keccak() {
        ZE(this.state32, this.rounds), this.posOut = 0, this.pos = 0
    }
    update(e) {
        Oo(this);
        const {
            blockLen: n,
            state: r
        } = this;
        e = zu(e);
        const i = e.length;
        for (let s = 0; s < i;) {
            const o = Math.min(n - this.pos, i - s);
            for (let a = 0; a < o; a++) r[this.pos++] ^= e[s++];
            this.pos === n && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished) return;
        this.finished = !0;
        const {
            state: e,
            suffix: n,
            pos: r,
            blockLen: i
        } = this;
        e[r] ^= n, n & 128 && r === i - 1 && this.keccak(), e[i - 1] ^= 128, this.keccak()
    }
    writeInto(e) {
        Oo(this, !1), xp(e), this.finish();
        const n = this.state,
            {
                blockLen: r
            } = this;
        for (let i = 0, s = e.length; i < s;) {
            this.posOut >= r && this.keccak();
            const o = Math.min(r - this.posOut, s - i);
            e.set(n.subarray(this.posOut, this.posOut + o), i), this.posOut += o, i += o
        }
        return e
    }
    xofInto(e) {
        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
        return this.writeInto(e)
    }
    xof(e) {
        return ru(e), this.xofInto(new Uint8Array(e))
    }
    digestInto(e) {
        if (hb(e, this), this.finished) throw new Error("digest() was already called");
        return this.writeInto(e), this.destroy(), e
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0, this.state.fill(0)
    }
    _cloneInto(e) {
        const {
            blockLen: n,
            suffix: r,
            outputLen: i,
            rounds: s,
            enableXOF: o
        } = this;
        return e || (e = new kp(n, r, i, o, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = r, e.outputLen = i, e.enableXOF = o, e.destroyed = this.destroyed, e
    }
}
const YE = (t, e, n) => mb(() => new kp(e, t, n)),
    XE = YE(1, 136, 256 / 8);
let xb = !1;
const Ab = function(t) {
    return XE(t)
};
let kb = Ab;

function Pt(t) {
    const e = qe(t, "data");
    return De(kb(e))
}
Pt._ = Ab;
Pt.lock = function() {
    xb = !0
};
Pt.register = function(t) {
    if (xb) throw new TypeError("keccak256 is locked");
    kb = t
};
Object.freeze(Pt); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _b = BigInt(0),
    ju = BigInt(1),
    qE = BigInt(2),
    Vu = t => t instanceof Uint8Array,
    $E = Array.from({
        length: 256
    }, (t, e) => e.toString(16).padStart(2, "0"));

function To(t) {
    if (!Vu(t)) throw new Error("Uint8Array expected");
    let e = "";
    for (let n = 0; n < t.length; n++) e += $E[t[n]];
    return e
}

function Eb(t) {
    const e = t.toString(16);
    return e.length & 1 ? `0${e}` : e
}

function _p(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    return BigInt(t === "" ? "0" : `0x${t}`)
}

function Bo(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    const e = t.length;
    if (e % 2) throw new Error("padded hex string expected, got unpadded hex of length " + e);
    const n = new Uint8Array(e / 2);
    for (let r = 0; r < n.length; r++) {
        const i = r * 2,
            s = t.slice(i, i + 2),
            o = Number.parseInt(s, 16);
        if (Number.isNaN(o) || o < 0) throw new Error("Invalid byte sequence");
        n[r] = o
    }
    return n
}

function Es(t) {
    return _p(To(t))
}

function Ep(t) {
    if (!Vu(t)) throw new Error("Uint8Array expected");
    return _p(To(Uint8Array.from(t).reverse()))
}

function Io(t, e) {
    return Bo(t.toString(16).padStart(e * 2, "0"))
}

function Pp(t, e) {
    return Io(t, e).reverse()
}

function e6(t) {
    return Bo(Eb(t))
}

function ir(t, e, n) {
    let r;
    if (typeof e == "string") try {
            r = Bo(e)
        } catch (s) {
            throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${s}`)
        } else if (Vu(e)) r = Uint8Array.from(e);
        else throw new Error(`${t} must be hex string or Uint8Array`);
    const i = r.length;
    if (typeof n == "number" && i !== n) throw new Error(`${t} expected ${n} bytes, got ${i}`);
    return r
}

function Wa(...t) {
    const e = new Uint8Array(t.reduce((r, i) => r + i.length, 0));
    let n = 0;
    return t.forEach(r => {
        if (!Vu(r)) throw new Error("Uint8Array expected");
        e.set(r, n), n += r.length
    }), e
}

function t6(t, e) {
    if (t.length !== e.length) return !1;
    for (let n = 0; n < t.length; n++)
        if (t[n] !== e[n]) return !1;
    return !0
}

function n6(t) {
    if (typeof t != "string") throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
    return new Uint8Array(new TextEncoder().encode(t))
}

function r6(t) {
    let e;
    for (e = 0; t > _b; t >>= ju, e += 1);
    return e
}

function i6(t, e) {
    return t >> BigInt(e) & ju
}
const s6 = (t, e, n) => t | (n ? ju : _b) << BigInt(e),
    Sp = t => (qE << BigInt(t - 1)) - ju,
    zf = t => new Uint8Array(t),
    ng = t => Uint8Array.from(t);

function Pb(t, e, n) {
    if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
    if (typeof n != "function") throw new Error("hmacFn must be a function");
    let r = zf(t),
        i = zf(t),
        s = 0;
    const o = () => {
            r.fill(1), i.fill(0), s = 0
        },
        a = (...f) => n(i, r, ...f),
        c = (f = zf()) => {
            i = a(ng([0]), f), r = a(), f.length !== 0 && (i = a(ng([1]), f), r = a())
        },
        l = () => {
            if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
            let f = 0;
            const d = [];
            for (; f < e;) {
                r = a();
                const h = r.slice();
                d.push(h), f += r.length
            }
            return Wa(...d)
        };
    return (f, d) => {
        o(), c(f);
        let h;
        for (; !(h = d(l()));) c();
        return o(), h
    }
}
const o6 = {
    bigint: t => typeof t == "bigint",
    function: t => typeof t == "function",
    boolean: t => typeof t == "boolean",
    string: t => typeof t == "string",
    stringOrUint8Array: t => typeof t == "string" || t instanceof Uint8Array,
    isSafeInteger: t => Number.isSafeInteger(t),
    array: t => Array.isArray(t),
    field: (t, e) => e.Fp.isValid(t),
    hash: t => typeof t == "function" && Number.isSafeInteger(t.outputLen)
};

function xl(t, e, n = {}) {
    const r = (i, s, o) => {
        const a = o6[s];
        if (typeof a != "function") throw new Error(`Invalid validator "${s}", expected function`);
        const c = t[i];
        if (!(o && c === void 0) && !a(c, t)) throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${s}`)
    };
    for (const [i, s] of Object.entries(e)) r(i, s, !1);
    for (const [i, s] of Object.entries(n)) r(i, s, !0);
    return t
}
const a6 = Object.freeze(Object.defineProperty({
    __proto__: null,
    bitGet: i6,
    bitLen: r6,
    bitMask: Sp,
    bitSet: s6,
    bytesToHex: To,
    bytesToNumberBE: Es,
    bytesToNumberLE: Ep,
    concatBytes: Wa,
    createHmacDrbg: Pb,
    ensureBytes: ir,
    equalBytes: t6,
    hexToBytes: Bo,
    hexToNumber: _p,
    numberToBytesBE: Io,
    numberToBytesLE: Pp,
    numberToHexUnpadded: Eb,
    numberToVarBytesBE: e6,
    utf8ToBytes: n6,
    validateObject: xl
}, Symbol.toStringTag, {
    value: "Module"
})); /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const $t = BigInt(0),
    Ut = BigInt(1),
    fs = BigInt(2),
    l6 = BigInt(3),
    Zd = BigInt(4),
    rg = BigInt(5),
    ig = BigInt(8);
BigInt(9);
BigInt(16);

function wn(t, e) {
    const n = t % e;
    return n >= $t ? n : e + n
}

function c6(t, e, n) {
    if (n <= $t || e < $t) throw new Error("Expected power/modulo > 0");
    if (n === Ut) return $t;
    let r = Ut;
    for (; e > $t;) e & Ut && (r = r * t % n), t = t * t % n, e >>= Ut;
    return r
}

function Mn(t, e, n) {
    let r = t;
    for (; e-- > $t;) r *= r, r %= n;
    return r
}

function Yd(t, e) {
    if (t === $t || e <= $t) throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
    let n = wn(t, e),
        r = e,
        i = $t,
        s = Ut;
    for (; n !== $t;) {
        const a = r / n,
            c = r % n,
            l = i - s * a;
        r = n, n = c, i = s, s = l
    }
    if (r !== Ut) throw new Error("invert: does not exist");
    return wn(i, e)
}

function u6(t) {
    const e = (t - Ut) / fs;
    let n, r, i;
    for (n = t - Ut, r = 0; n % fs === $t; n /= fs, r++);
    for (i = fs; i < t && c6(i, e, t) !== t - Ut; i++);
    if (r === 1) {
        const o = (t + Ut) / Zd;
        return function(c, l) {
            const u = c.pow(l, o);
            if (!c.eql(c.sqr(u), l)) throw new Error("Cannot find square root");
            return u
        }
    }
    const s = (n + Ut) / fs;
    return function(a, c) {
        if (a.pow(c, e) === a.neg(a.ONE)) throw new Error("Cannot find square root");
        let l = r,
            u = a.pow(a.mul(a.ONE, i), n),
            f = a.pow(c, s),
            d = a.pow(c, n);
        for (; !a.eql(d, a.ONE);) {
            if (a.eql(d, a.ZERO)) return a.ZERO;
            let h = 1;
            for (let g = a.sqr(d); h < l && !a.eql(g, a.ONE); h++) g = a.sqr(g);
            const p = a.pow(u, Ut << BigInt(l - h - 1));
            u = a.sqr(p), f = a.mul(f, p), d = a.mul(d, u), l = h
        }
        return f
    }
}

function f6(t) {
    if (t % Zd === l6) {
        const e = (t + Ut) / Zd;
        return function(r, i) {
            const s = r.pow(i, e);
            if (!r.eql(r.sqr(s), i)) throw new Error("Cannot find square root");
            return s
        }
    }
    if (t % ig === rg) {
        const e = (t - rg) / ig;
        return function(r, i) {
            const s = r.mul(i, fs),
                o = r.pow(s, e),
                a = r.mul(i, o),
                c = r.mul(r.mul(a, fs), o),
                l = r.mul(a, r.sub(c, r.ONE));
            if (!r.eql(r.sqr(l), i)) throw new Error("Cannot find square root");
            return l
        }
    }
    return u6(t)
}
const d6 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

function h6(t) {
    const e = {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger"
        },
        n = d6.reduce((r, i) => (r[i] = "function", r), e);
    return xl(t, n)
}

function p6(t, e, n) {
    if (n < $t) throw new Error("Expected power > 0");
    if (n === $t) return t.ONE;
    if (n === Ut) return e;
    let r = t.ONE,
        i = e;
    for (; n > $t;) n & Ut && (r = t.mul(r, i)), i = t.sqr(i), n >>= Ut;
    return r
}

function m6(t, e) {
    const n = new Array(e.length),
        r = e.reduce((s, o, a) => t.is0(o) ? s : (n[a] = s, t.mul(s, o)), t.ONE),
        i = t.inv(r);
    return e.reduceRight((s, o, a) => t.is0(o) ? s : (n[a] = t.mul(s, n[a]), t.mul(s, o)), i), n
}

function Sb(t, e) {
    const n = e !== void 0 ? e : t.toString(2).length,
        r = Math.ceil(n / 8);
    return {
        nBitLength: n,
        nByteLength: r
    }
}

function g6(t, e, n = !1, r = {}) {
    if (t <= $t) throw new Error(`Expected Field ORDER > 0, got ${t}`);
    const {
        nBitLength: i,
        nByteLength: s
    } = Sb(t, e);
    if (s > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const o = f6(t),
        a = Object.freeze({
            ORDER: t,
            BITS: i,
            BYTES: s,
            MASK: Sp(i),
            ZERO: $t,
            ONE: Ut,
            create: c => wn(c, t),
            isValid: c => {
                if (typeof c != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
                return $t <= c && c < t
            },
            is0: c => c === $t,
            isOdd: c => (c & Ut) === Ut,
            neg: c => wn(-c, t),
            eql: (c, l) => c === l,
            sqr: c => wn(c * c, t),
            add: (c, l) => wn(c + l, t),
            sub: (c, l) => wn(c - l, t),
            mul: (c, l) => wn(c * l, t),
            pow: (c, l) => p6(a, c, l),
            div: (c, l) => wn(c * Yd(l, t), t),
            sqrN: c => c * c,
            addN: (c, l) => c + l,
            subN: (c, l) => c - l,
            mulN: (c, l) => c * l,
            inv: c => Yd(c, t),
            sqrt: r.sqrt || (c => o(a, c)),
            invertBatch: c => m6(a, c),
            cmov: (c, l, u) => u ? l : c,
            toBytes: c => n ? Pp(c, s) : Io(c, s),
            fromBytes: c => {
                if (c.length !== s) throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);
                return n ? Ep(c) : Es(c)
            }
        });
    return Object.freeze(a)
}

function Nb(t) {
    if (typeof t != "bigint") throw new Error("field order must be bigint");
    const e = t.toString(2).length;
    return Math.ceil(e / 8)
}

function Rb(t) {
    const e = Nb(t);
    return e + Math.ceil(e / 2)
}

function y6(t, e, n = !1) {
    const r = t.length,
        i = Nb(e),
        s = Rb(e);
    if (r < 16 || r < s || r > 1024) throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);
    const o = n ? Es(t) : Ep(t),
        a = wn(o, e - Ut) + Ut;
    return n ? Pp(a, i) : Io(a, i)
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const v6 = BigInt(0),
    jf = BigInt(1);

function b6(t, e) {
    const n = (i, s) => {
            const o = s.negate();
            return i ? o : s
        },
        r = i => {
            const s = Math.ceil(e / i) + 1,
                o = 2 ** (i - 1);
            return {
                windows: s,
                windowSize: o
            }
        };
    return {
        constTimeNegate: n,
        unsafeLadder(i, s) {
            let o = t.ZERO,
                a = i;
            for (; s > v6;) s & jf && (o = o.add(a)), a = a.double(), s >>= jf;
            return o
        },
        precomputeWindow(i, s) {
            const {
                windows: o,
                windowSize: a
            } = r(s), c = [];
            let l = i,
                u = l;
            for (let f = 0; f < o; f++) {
                u = l, c.push(u);
                for (let d = 1; d < a; d++) u = u.add(l), c.push(u);
                l = u.double()
            }
            return c
        },
        wNAF(i, s, o) {
            const {
                windows: a,
                windowSize: c
            } = r(i);
            let l = t.ZERO,
                u = t.BASE;
            const f = BigInt(2 ** i - 1),
                d = 2 ** i,
                h = BigInt(i);
            for (let p = 0; p < a; p++) {
                const g = p * c;
                let b = Number(o & f);
                o >>= h, b > c && (b -= d, o += jf);
                const x = g,
                    w = g + Math.abs(b) - 1,
                    O = p % 2 !== 0,
                    N = b < 0;
                b === 0 ? u = u.add(n(O, s[x])) : l = l.add(n(N, s[w]))
            }
            return {
                p: l,
                f: u
            }
        },
        wNAFCached(i, s, o, a) {
            const c = i._WINDOW_SIZE || 1;
            let l = s.get(i);
            return l || (l = this.precomputeWindow(i, c), c !== 1 && s.set(i, a(l))), this.wNAF(c, l, o)
        }
    }
}

function Cb(t) {
    return h6(t.Fp), xl(t, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }), Object.freeze({ ...Sb(t.n, t.nBitLength),
        ...t,
        p: t.Fp.ORDER
    })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function w6(t) {
    const e = Cb(t);
    xl(e, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const {
        endo: n,
        Fp: r,
        a: i
    } = e;
    if (n) {
        if (!r.eql(i, r.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof n != "object" || typeof n.beta != "bigint" || typeof n.splitScalar != "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
    }
    return Object.freeze({ ...e
    })
}
const {
    bytesToNumberBE: x6,
    hexToBytes: A6
} = a6, ps = {
    Err: class extends Error {
        constructor(e = "") {
            super(e)
        }
    },
    _parseInt(t) {
        const {
            Err: e
        } = ps;
        if (t.length < 2 || t[0] !== 2) throw new e("Invalid signature integer tag");
        const n = t[1],
            r = t.subarray(2, n + 2);
        if (!n || r.length !== n) throw new e("Invalid signature integer: wrong length");
        if (r[0] & 128) throw new e("Invalid signature integer: negative");
        if (r[0] === 0 && !(r[1] & 128)) throw new e("Invalid signature integer: unnecessary leading zero");
        return {
            d: x6(r),
            l: t.subarray(n + 2)
        }
    },
    toSig(t) {
        const {
            Err: e
        } = ps, n = typeof t == "string" ? A6(t) : t;
        if (!(n instanceof Uint8Array)) throw new Error("ui8a expected");
        let r = n.length;
        if (r < 2 || n[0] != 48) throw new e("Invalid signature tag");
        if (n[1] !== r - 2) throw new e("Invalid signature: incorrect length");
        const {
            d: i,
            l: s
        } = ps._parseInt(n.subarray(2)), {
            d: o,
            l: a
        } = ps._parseInt(s);
        if (a.length) throw new e("Invalid signature: left bytes after parsing");
        return {
            r: i,
            s: o
        }
    },
    hexFromSig(t) {
        const e = l => Number.parseInt(l[0], 16) & 8 ? "00" + l : l,
            n = l => {
                const u = l.toString(16);
                return u.length & 1 ? `0${u}` : u
            },
            r = e(n(t.s)),
            i = e(n(t.r)),
            s = r.length / 2,
            o = i.length / 2,
            a = n(s),
            c = n(o);
        return `30${n(o+s+4)}02${c}${i}02${a}${r}`
    }
}, Zr = BigInt(0), Hn = BigInt(1);
BigInt(2);
const sg = BigInt(3);
BigInt(4);

function k6(t) {
    const e = w6(t),
        {
            Fp: n
        } = e,
        r = e.toBytes || ((p, g, b) => {
            const x = g.toAffine();
            return Wa(Uint8Array.from([4]), n.toBytes(x.x), n.toBytes(x.y))
        }),
        i = e.fromBytes || (p => {
            const g = p.subarray(1),
                b = n.fromBytes(g.subarray(0, n.BYTES)),
                x = n.fromBytes(g.subarray(n.BYTES, 2 * n.BYTES));
            return {
                x: b,
                y: x
            }
        });

    function s(p) {
        const {
            a: g,
            b
        } = e, x = n.sqr(p), w = n.mul(x, p);
        return n.add(n.add(w, n.mul(p, g)), b)
    }
    if (!n.eql(n.sqr(e.Gy), s(e.Gx))) throw new Error("bad generator point: equation left != right");

    function o(p) {
        return typeof p == "bigint" && Zr < p && p < e.n
    }

    function a(p) {
        if (!o(p)) throw new Error("Expected valid bigint: 0 < bigint < curve.n")
    }

    function c(p) {
        const {
            allowedPrivateKeyLengths: g,
            nByteLength: b,
            wrapPrivateKey: x,
            n: w
        } = e;
        if (g && typeof p != "bigint") {
            if (p instanceof Uint8Array && (p = To(p)), typeof p != "string" || !g.includes(p.length)) throw new Error("Invalid key");
            p = p.padStart(b * 2, "0")
        }
        let O;
        try {
            O = typeof p == "bigint" ? p : Es(ir("private key", p, b))
        } catch {
            throw new Error(`private key must be ${b} bytes, hex or bigint, not ${typeof p}`)
        }
        return x && (O = wn(O, w)), a(O), O
    }
    const l = new Map;

    function u(p) {
        if (!(p instanceof f)) throw new Error("ProjectivePoint expected")
    }
    class f {
        constructor(g, b, x) {
            if (this.px = g, this.py = b, this.pz = x, g == null || !n.isValid(g)) throw new Error("x required");
            if (b == null || !n.isValid(b)) throw new Error("y required");
            if (x == null || !n.isValid(x)) throw new Error("z required")
        }
        static fromAffine(g) {
            const {
                x: b,
                y: x
            } = g || {};
            if (!g || !n.isValid(b) || !n.isValid(x)) throw new Error("invalid affine point");
            if (g instanceof f) throw new Error("projective point not allowed");
            const w = O => n.eql(O, n.ZERO);
            return w(b) && w(x) ? f.ZERO : new f(b, x, n.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(g) {
            const b = n.invertBatch(g.map(x => x.pz));
            return g.map((x, w) => x.toAffine(b[w])).map(f.fromAffine)
        }
        static fromHex(g) {
            const b = f.fromAffine(i(ir("pointHex", g)));
            return b.assertValidity(), b
        }
        static fromPrivateKey(g) {
            return f.BASE.multiply(c(g))
        }
        _setWindowSize(g) {
            this._WINDOW_SIZE = g, l.delete(this)
        }
        assertValidity() {
            if (this.is0()) {
                if (e.allowInfinityPoint && !n.is0(this.py)) return;
                throw new Error("bad point: ZERO")
            }
            const {
                x: g,
                y: b
            } = this.toAffine();
            if (!n.isValid(g) || !n.isValid(b)) throw new Error("bad point: x or y not FE");
            const x = n.sqr(b),
                w = s(g);
            if (!n.eql(x, w)) throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup")
        }
        hasEvenY() {
            const {
                y: g
            } = this.toAffine();
            if (n.isOdd) return !n.isOdd(g);
            throw new Error("Field doesn't support isOdd")
        }
        equals(g) {
            u(g);
            const {
                px: b,
                py: x,
                pz: w
            } = this, {
                px: O,
                py: N,
                pz: U
            } = g, H = n.eql(n.mul(b, U), n.mul(O, w)), M = n.eql(n.mul(x, U), n.mul(N, w));
            return H && M
        }
        negate() {
            return new f(this.px, n.neg(this.py), this.pz)
        }
        double() {
            const {
                a: g,
                b
            } = e, x = n.mul(b, sg), {
                px: w,
                py: O,
                pz: N
            } = this;
            let U = n.ZERO,
                H = n.ZERO,
                M = n.ZERO,
                y = n.mul(w, w),
                v = n.mul(O, O),
                A = n.mul(N, N),
                E = n.mul(w, O);
            return E = n.add(E, E), M = n.mul(w, N), M = n.add(M, M), U = n.mul(g, M), H = n.mul(x, A), H = n.add(U, H), U = n.sub(v, H), H = n.add(v, H), H = n.mul(U, H), U = n.mul(E, U), M = n.mul(x, M), A = n.mul(g, A), E = n.sub(y, A), E = n.mul(g, E), E = n.add(E, M), M = n.add(y, y), y = n.add(M, y), y = n.add(y, A), y = n.mul(y, E), H = n.add(H, y), A = n.mul(O, N), A = n.add(A, A), y = n.mul(A, E), U = n.sub(U, y), M = n.mul(A, v), M = n.add(M, M), M = n.add(M, M), new f(U, H, M)
        }
        add(g) {
            u(g);
            const {
                px: b,
                py: x,
                pz: w
            } = this, {
                px: O,
                py: N,
                pz: U
            } = g;
            let H = n.ZERO,
                M = n.ZERO,
                y = n.ZERO;
            const v = e.a,
                A = n.mul(e.b, sg);
            let E = n.mul(b, O),
                P = n.mul(x, N),
                R = n.mul(w, U),
                F = n.add(b, x),
                _ = n.add(O, N);
            F = n.mul(F, _), _ = n.add(E, P), F = n.sub(F, _), _ = n.add(b, w);
            let S = n.add(O, U);
            return _ = n.mul(_, S), S = n.add(E, R), _ = n.sub(_, S), S = n.add(x, w), H = n.add(N, U), S = n.mul(S, H), H = n.add(P, R), S = n.sub(S, H), y = n.mul(v, _), H = n.mul(A, R), y = n.add(H, y), H = n.sub(P, y), y = n.add(P, y), M = n.mul(H, y), P = n.add(E, E), P = n.add(P, E), R = n.mul(v, R), _ = n.mul(A, _), P = n.add(P, R), R = n.sub(E, R), R = n.mul(v, R), _ = n.add(_, R), E = n.mul(P, _), M = n.add(M, E), E = n.mul(S, _), H = n.mul(F, H), H = n.sub(H, E), E = n.mul(F, P), y = n.mul(S, y), y = n.add(y, E), new f(H, M, y)
        }
        subtract(g) {
            return this.add(g.negate())
        }
        is0() {
            return this.equals(f.ZERO)
        }
        wNAF(g) {
            return h.wNAFCached(this, l, g, b => {
                const x = n.invertBatch(b.map(w => w.pz));
                return b.map((w, O) => w.toAffine(x[O])).map(f.fromAffine)
            })
        }
        multiplyUnsafe(g) {
            const b = f.ZERO;
            if (g === Zr) return b;
            if (a(g), g === Hn) return this;
            const {
                endo: x
            } = e;
            if (!x) return h.unsafeLadder(this, g);
            let {
                k1neg: w,
                k1: O,
                k2neg: N,
                k2: U
            } = x.splitScalar(g), H = b, M = b, y = this;
            for (; O > Zr || U > Zr;) O & Hn && (H = H.add(y)), U & Hn && (M = M.add(y)), y = y.double(), O >>= Hn, U >>= Hn;
            return w && (H = H.negate()), N && (M = M.negate()), M = new f(n.mul(M.px, x.beta), M.py, M.pz), H.add(M)
        }
        multiply(g) {
            a(g);
            let b = g,
                x, w;
            const {
                endo: O
            } = e;
            if (O) {
                const {
                    k1neg: N,
                    k1: U,
                    k2neg: H,
                    k2: M
                } = O.splitScalar(b);
                let {
                    p: y,
                    f: v
                } = this.wNAF(U), {
                    p: A,
                    f: E
                } = this.wNAF(M);
                y = h.constTimeNegate(N, y), A = h.constTimeNegate(H, A), A = new f(n.mul(A.px, O.beta), A.py, A.pz), x = y.add(A), w = v.add(E)
            } else {
                const {
                    p: N,
                    f: U
                } = this.wNAF(b);
                x = N, w = U
            }
            return f.normalizeZ([x, w])[0]
        }
        multiplyAndAddUnsafe(g, b, x) {
            const w = f.BASE,
                O = (U, H) => H === Zr || H === Hn || !U.equals(w) ? U.multiplyUnsafe(H) : U.multiply(H),
                N = O(this, b).add(O(g, x));
            return N.is0() ? void 0 : N
        }
        toAffine(g) {
            const {
                px: b,
                py: x,
                pz: w
            } = this, O = this.is0();
            g == null && (g = O ? n.ONE : n.inv(w));
            const N = n.mul(b, g),
                U = n.mul(x, g),
                H = n.mul(w, g);
            if (O) return {
                x: n.ZERO,
                y: n.ZERO
            };
            if (!n.eql(H, n.ONE)) throw new Error("invZ was invalid");
            return {
                x: N,
                y: U
            }
        }
        isTorsionFree() {
            const {
                h: g,
                isTorsionFree: b
            } = e;
            if (g === Hn) return !0;
            if (b) return b(f, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            const {
                h: g,
                clearCofactor: b
            } = e;
            return g === Hn ? this : b ? b(f, this) : this.multiplyUnsafe(e.h)
        }
        toRawBytes(g = !0) {
            return this.assertValidity(), r(f, this, g)
        }
        toHex(g = !0) {
            return To(this.toRawBytes(g))
        }
    }
    f.BASE = new f(e.Gx, e.Gy, n.ONE), f.ZERO = new f(n.ZERO, n.ONE, n.ZERO);
    const d = e.nBitLength,
        h = b6(f, e.endo ? Math.ceil(d / 2) : d);
    return {
        CURVE: e,
        ProjectivePoint: f,
        normPrivateKeyToScalar: c,
        weierstrassEquation: s,
        isWithinCurveOrder: o
    }
}

function _6(t) {
    const e = Cb(t);
    return xl(e, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }), Object.freeze({
        lowS: !0,
        ...e
    })
}

function E6(t) {
    const e = _6(t),
        {
            Fp: n,
            n: r
        } = e,
        i = n.BYTES + 1,
        s = 2 * n.BYTES + 1;

    function o(_) {
        return Zr < _ && _ < n.ORDER
    }

    function a(_) {
        return wn(_, r)
    }

    function c(_) {
        return Yd(_, r)
    }
    const {
        ProjectivePoint: l,
        normPrivateKeyToScalar: u,
        weierstrassEquation: f,
        isWithinCurveOrder: d
    } = k6({ ...e,
        toBytes(_, S, I) {
            const B = S.toAffine(),
                j = n.toBytes(B.x),
                Y = Wa;
            return I ? Y(Uint8Array.from([S.hasEvenY() ? 2 : 3]), j) : Y(Uint8Array.from([4]), j, n.toBytes(B.y))
        },
        fromBytes(_) {
            const S = _.length,
                I = _[0],
                B = _.subarray(1);
            if (S === i && (I === 2 || I === 3)) {
                const j = Es(B);
                if (!o(j)) throw new Error("Point is not on curve");
                const Y = f(j);
                let te = n.sqrt(Y);
                const he = (te & Hn) === Hn;
                return (I & 1) === 1 !== he && (te = n.neg(te)), {
                    x: j,
                    y: te
                }
            } else if (S === s && I === 4) {
                const j = n.fromBytes(B.subarray(0, n.BYTES)),
                    Y = n.fromBytes(B.subarray(n.BYTES, 2 * n.BYTES));
                return {
                    x: j,
                    y: Y
                }
            } else throw new Error(`Point of length ${S} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`)
        }
    }), h = _ => To(Io(_, e.nByteLength));

    function p(_) {
        const S = r >> Hn;
        return _ > S
    }

    function g(_) {
        return p(_) ? a(-_) : _
    }
    const b = (_, S, I) => Es(_.slice(S, I));
    class x {
        constructor(S, I, B) {
            this.r = S, this.s = I, this.recovery = B, this.assertValidity()
        }
        static fromCompact(S) {
            const I = e.nByteLength;
            return S = ir("compactSignature", S, I * 2), new x(b(S, 0, I), b(S, I, 2 * I))
        }
        static fromDER(S) {
            const {
                r: I,
                s: B
            } = ps.toSig(ir("DER", S));
            return new x(I, B)
        }
        assertValidity() {
            if (!d(this.r)) throw new Error("r must be 0 < r < CURVE.n");
            if (!d(this.s)) throw new Error("s must be 0 < s < CURVE.n")
        }
        addRecoveryBit(S) {
            return new x(this.r, this.s, S)
        }
        recoverPublicKey(S) {
            const {
                r: I,
                s: B,
                recovery: j
            } = this, Y = M(ir("msgHash", S));
            if (j == null || ![0, 1, 2, 3].includes(j)) throw new Error("recovery id invalid");
            const te = j === 2 || j === 3 ? I + e.n : I;
            if (te >= n.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const he = j & 1 ? "03" : "02",
                Te = l.fromHex(he + h(te)),
                Be = c(te),
                ve = a(-Y * Be),
                X = a(B * Be),
                V = l.BASE.multiplyAndAddUnsafe(Te, ve, X);
            if (!V) throw new Error("point at infinify");
            return V.assertValidity(), V
        }
        hasHighS() {
            return p(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new x(this.r, a(-this.s), this.recovery) : this
        }
        toDERRawBytes() {
            return Bo(this.toDERHex())
        }
        toDERHex() {
            return ps.hexFromSig({
                r: this.r,
                s: this.s
            })
        }
        toCompactRawBytes() {
            return Bo(this.toCompactHex())
        }
        toCompactHex() {
            return h(this.r) + h(this.s)
        }
    }
    const w = {
        isValidPrivateKey(_) {
            try {
                return u(_), !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: u,
        randomPrivateKey: () => {
            const _ = Rb(e.n);
            return y6(e.randomBytes(_), e.n)
        },
        precompute(_ = 8, S = l.BASE) {
            return S._setWindowSize(_), S.multiply(BigInt(3)), S
        }
    };

    function O(_, S = !0) {
        return l.fromPrivateKey(_).toRawBytes(S)
    }

    function N(_) {
        const S = _ instanceof Uint8Array,
            I = typeof _ == "string",
            B = (S || I) && _.length;
        return S ? B === i || B === s : I ? B === 2 * i || B === 2 * s : _ instanceof l
    }

    function U(_, S, I = !0) {
        if (N(_)) throw new Error("first arg must be private key");
        if (!N(S)) throw new Error("second arg must be public key");
        return l.fromHex(S).multiply(u(_)).toRawBytes(I)
    }
    const H = e.bits2int || function(_) {
            const S = Es(_),
                I = _.length * 8 - e.nBitLength;
            return I > 0 ? S >> BigInt(I) : S
        },
        M = e.bits2int_modN || function(_) {
            return a(H(_))
        },
        y = Sp(e.nBitLength);

    function v(_) {
        if (typeof _ != "bigint") throw new Error("bigint expected");
        if (!(Zr <= _ && _ < y)) throw new Error(`bigint expected < 2^${e.nBitLength}`);
        return Io(_, e.nByteLength)
    }

    function A(_, S, I = E) {
        if (["recovered", "canonical"].some(ae => ae in I)) throw new Error("sign() legacy options not supported");
        const {
            hash: B,
            randomBytes: j
        } = e;
        let {
            lowS: Y,
            prehash: te,
            extraEntropy: he
        } = I;
        Y == null && (Y = !0), _ = ir("msgHash", _), te && (_ = ir("prehashed msgHash", B(_)));
        const Te = M(_),
            Be = u(S),
            ve = [v(Be), v(Te)];
        if (he != null) {
            const ae = he === !0 ? j(n.BYTES) : he;
            ve.push(ir("extraEntropy", ae))
        }
        const X = Wa(...ve),
            V = Te;

        function oe(ae) {
            const Ae = H(ae);
            if (!d(Ae)) return;
            const Fe = c(Ae),
                C = l.BASE.multiply(Ae).toAffine(),
                T = a(C.x);
            if (T === Zr) return;
            const z = a(Fe * a(V + T * Be));
            if (z === Zr) return;
            let Q = (C.x === T ? 0 : 2) | Number(C.y & Hn),
                $ = z;
            return Y && p(z) && ($ = g(z), Q ^= 1), new x(T, $, Q)
        }
        return {
            seed: X,
            k2sig: oe
        }
    }
    const E = {
            lowS: e.lowS,
            prehash: !1
        },
        P = {
            lowS: e.lowS,
            prehash: !1
        };

    function R(_, S, I = E) {
        const {
            seed: B,
            k2sig: j
        } = A(_, S, I), Y = e;
        return Pb(Y.hash.outputLen, Y.nByteLength, Y.hmac)(B, j)
    }
    l.BASE._setWindowSize(8);

    function F(_, S, I, B = P) {
        const j = _;
        if (S = ir("msgHash", S), I = ir("publicKey", I), "strict" in B) throw new Error("options.strict was renamed to lowS");
        const {
            lowS: Y,
            prehash: te
        } = B;
        let he, Te;
        try {
            if (typeof j == "string" || j instanceof Uint8Array) try {
                he = x.fromDER(j)
            } catch (C) {
                if (!(C instanceof ps.Err)) throw C;
                he = x.fromCompact(j)
            } else if (typeof j == "object" && typeof j.r == "bigint" && typeof j.s == "bigint") {
                const {
                    r: C,
                    s: T
                } = j;
                he = new x(C, T)
            } else throw new Error("PARSE");
            Te = l.fromHex(I)
        } catch (C) {
            if (C.message === "PARSE") throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return !1
        }
        if (Y && he.hasHighS()) return !1;
        te && (S = e.hash(S));
        const {
            r: Be,
            s: ve
        } = he, X = M(S), V = c(ve), oe = a(X * V), ae = a(Be * V), Ae = l.BASE.multiplyAndAddUnsafe(Te, oe, ae) ? .toAffine();
        return Ae ? a(Ae.x) === Be : !1
    }
    return {
        CURVE: e,
        getPublicKey: O,
        getSharedSecret: U,
        sign: R,
        verify: F,
        ProjectivePoint: l,
        Signature: x,
        utils: w
    }
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function P6(t) {
    return {
        hash: t,
        hmac: (e, ...n) => yb(t, e, SE(...n)),
        randomBytes: NE
    }
}

function S6(t, e) {
    const n = r => E6({ ...t,
        ...P6(r)
    });
    return Object.freeze({ ...n(e),
        create: n
    })
} /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ob = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    og = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    N6 = BigInt(1),
    Xd = BigInt(2),
    ag = (t, e) => (t + e / Xd) / e;

function R6(t) {
    const e = Ob,
        n = BigInt(3),
        r = BigInt(6),
        i = BigInt(11),
        s = BigInt(22),
        o = BigInt(23),
        a = BigInt(44),
        c = BigInt(88),
        l = t * t * t % e,
        u = l * l * t % e,
        f = Mn(u, n, e) * u % e,
        d = Mn(f, n, e) * u % e,
        h = Mn(d, Xd, e) * l % e,
        p = Mn(h, i, e) * h % e,
        g = Mn(p, s, e) * p % e,
        b = Mn(g, a, e) * g % e,
        x = Mn(b, c, e) * b % e,
        w = Mn(x, a, e) * g % e,
        O = Mn(w, n, e) * u % e,
        N = Mn(O, o, e) * p % e,
        U = Mn(N, r, e) * l % e,
        H = Mn(U, Xd, e);
    if (!qd.eql(qd.sqr(H), t)) throw new Error("Cannot find square root");
    return H
}
const qd = g6(Ob, void 0, void 0, {
        sqrt: R6
    }),
    Pi = S6({
        a: BigInt(0),
        b: BigInt(7),
        Fp: qd,
        n: og,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: !0,
        endo: {
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
            splitScalar: t => {
                const e = og,
                    n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                    r = -N6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                    i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                    s = n,
                    o = BigInt("0x100000000000000000000000000000000"),
                    a = ag(s * t, e),
                    c = ag(-r * t, e);
                let l = wn(t - a * n - c * i, e),
                    u = wn(-a * r - c * s, e);
                const f = l > o,
                    d = u > o;
                if (f && (l = e - l), d && (u = e - u), l > o || u > o) throw new Error("splitScalar: Endomorphism failed, k=" + t);
                return {
                    k1neg: f,
                    k1: l,
                    k2neg: d,
                    k2: u
                }
            }
        }
    }, DE);
BigInt(0);
Pi.ProjectivePoint;
const $d = "0x0000000000000000000000000000000000000000",
    lg = "0x0000000000000000000000000000000000000000000000000000000000000000",
    cg = BigInt(0),
    ug = BigInt(1),
    fg = BigInt(2),
    dg = BigInt(27),
    hg = BigInt(28),
    oc = BigInt(35),
    $s = {};

function pg(t) {
    return Sr(_n(t), 32)
}
class Qt {#
    e;#
    t;#
    n;#
    r;
    get r() {
        return this.#e
    }
    set r(e) {
        W(_s(e) === 32, "invalid r", "value", e), this.#e = De(e)
    }
    get s() {
        return this.#t
    }
    set s(e) {
        W(_s(e) === 32, "invalid s", "value", e);
        const n = De(e);
        W(parseInt(n.substring(0, 3)) < 8, "non-canonical s", "value", n), this.#t = n
    }
    get v() {
        return this.#n
    }
    set v(e) {
        const n = $e(e, "value");
        W(n === 27 || n === 28, "invalid v", "v", e), this.#n = n
    }
    get networkV() {
        return this.#r
    }
    get legacyChainId() {
        const e = this.networkV;
        return e == null ? null : Qt.getChainId(e)
    }
    get yParity() {
        return this.v === 27 ? 0 : 1
    }
    get yParityAndS() {
        const e = qe(this.s);
        return this.yParity && (e[0] |= 128), De(e)
    }
    get compactSerialized() {
        return Ht([this.r, this.yParityAndS])
    }
    get serialized() {
        return Ht([this.r, this.s, this.yParity ? "0x1c" : "0x1b"])
    }
    constructor(e, n, r, i) {
        wl(e, $s, "Signature"), this.#e = n, this.#t = r, this.#n = i, this.#r = null
    }[Symbol.for("nodejs.util.inspect.custom")]() {
        return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`
    }
    clone() {
        const e = new Qt($s, this.r, this.s, this.v);
        return this.networkV && (e.#r = this.networkV), e
    }
    toJSON() {
        const e = this.networkV;
        return {
            _type: "signature",
            networkV: e != null ? e.toString() : null,
            r: this.r,
            s: this.s,
            v: this.v
        }
    }
    static getChainId(e) {
        const n = Le(e, "v");
        return n == dg || n == hg ? cg : (W(n >= oc, "invalid EIP-155 v", "v", e), (n - oc) / fg)
    }
    static getChainIdV(e, n) {
        return Le(e) * fg + BigInt(35 + n - 27)
    }
    static getNormalizedV(e) {
        const n = Le(e);
        return n === cg || n === dg ? 27 : n === ug || n === hg ? 28 : (W(n >= oc, "invalid v", "v", e), n & ug ? 27 : 28)
    }
    static from(e) {
        function n(l, u) {
            W(l, u, "signature", e)
        }
        if (e == null) return new Qt($s, lg, lg, 27);
        if (typeof e == "string") {
            const l = qe(e, "signature");
            if (l.length === 64) {
                const u = De(l.slice(0, 32)),
                    f = l.slice(32, 64),
                    d = f[0] & 128 ? 28 : 27;
                return f[0] &= 127, new Qt($s, u, De(f), d)
            }
            if (l.length === 65) {
                const u = De(l.slice(0, 32)),
                    f = l.slice(32, 64);
                n((f[0] & 128) === 0, "non-canonical s");
                const d = Qt.getNormalizedV(l[64]);
                return new Qt($s, u, De(f), d)
            }
            n(!1, "invalid raw signature length")
        }
        if (e instanceof Qt) return e.clone();
        const r = e.r;
        n(r != null, "missing r");
        const i = pg(r),
            s = function(l, u) {
                if (l != null) return pg(l);
                if (u != null) {
                    n(Ot(u, 32), "invalid yParityAndS");
                    const f = qe(u);
                    return f[0] &= 127, De(f)
                }
                n(!1, "missing s")
            }(e.s, e.yParityAndS);
        n((qe(s)[0] & 128) == 0, "non-canonical s");
        const {
            networkV: o,
            v: a
        } = function(l, u, f) {
            if (l != null) {
                const d = Le(l);
                return {
                    networkV: d >= oc ? d : void 0,
                    v: Qt.getNormalizedV(d)
                }
            }
            if (u != null) return n(Ot(u, 32), "invalid yParityAndS"), {
                v: qe(u)[0] & 128 ? 28 : 27
            };
            if (f != null) {
                switch ($e(f, "sig.yParity")) {
                    case 0:
                        return {
                            v: 27
                        };
                    case 1:
                        return {
                            v: 28
                        }
                }
                n(!1, "invalid yParity")
            }
            n(!1, "missing v")
        }(e.v, e.yParityAndS, e.yParity), c = new Qt($s, i, s, a);
        return o && (c.#r = o), n(e.yParity == null || $e(e.yParity, "sig.yParity") === c.yParity, "yParity mismatch"), n(e.yParityAndS == null || e.yParityAndS === c.yParityAndS, "yParityAndS mismatch"), c
    }
}
class Yr {#
    e;
    constructor(e) {
        W(_s(e) === 32, "invalid private key", "privateKey", "[REDACTED]"), this.#e = De(e)
    }
    get privateKey() {
        return this.#e
    }
    get publicKey() {
        return Yr.computePublicKey(this.#e)
    }
    get compressedPublicKey() {
        return Yr.computePublicKey(this.#e, !0)
    }
    sign(e) {
        W(_s(e) === 32, "invalid digest length", "digest", e);
        const n = Pi.sign(kn(e), kn(this.#e), {
            lowS: !0
        });
        return Qt.from({
            r: Vi(n.r, 32),
            s: Vi(n.s, 32),
            v: n.recovery ? 28 : 27
        })
    }
    computeSharedSecret(e) {
        const n = Yr.computePublicKey(e);
        return De(Pi.getSharedSecret(kn(this.#e), qe(n), !1))
    }
    static computePublicKey(e, n) {
        let r = qe(e, "key");
        if (r.length === 32) {
            const s = Pi.getPublicKey(r, !!n);
            return De(s)
        }
        if (r.length === 64) {
            const s = new Uint8Array(65);
            s[0] = 4, s.set(r, 1), r = s
        }
        const i = Pi.ProjectivePoint.fromHex(r);
        return De(i.toRawBytes(n))
    }
    static recoverPublicKey(e, n) {
        W(_s(e) === 32, "invalid digest length", "digest", e);
        const r = Qt.from(n);
        let i = Pi.Signature.fromCompact(kn(Ht([r.r, r.s])));
        i = i.addRecoveryBit(r.yParity);
        const s = i.recoverPublicKey(kn(e));
        return W(s != null, "invalid signautre for digest", "signature", n), "0x" + s.toHex(!1)
    }
    static addPoints(e, n, r) {
        const i = Pi.ProjectivePoint.fromHex(Yr.computePublicKey(e).substring(2)),
            s = Pi.ProjectivePoint.fromHex(Yr.computePublicKey(n).substring(2));
        return "0x" + i.add(s).toHex(!!r)
    }
}
const C6 = BigInt(0),
    O6 = BigInt(36);

function mg(t) {
    t = t.toLowerCase();
    const e = t.substring(2).split(""),
        n = new Uint8Array(40);
    for (let i = 0; i < 40; i++) n[i] = e[i].charCodeAt(0);
    const r = qe(Pt(n));
    for (let i = 0; i < 40; i += 2) r[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return "0x" + e.join("")
}
const Np = {};
for (let t = 0; t < 10; t++) Np[String(t)] = String(t);
for (let t = 0; t < 26; t++) Np[String.fromCharCode(65 + t)] = String(10 + t);
const gg = 15;

function T6(t) {
    t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
    let e = t.split("").map(r => Np[r]).join("");
    for (; e.length >= gg;) {
        let r = e.substring(0, gg);
        e = parseInt(r, 10) % 97 + e.substring(r.length)
    }
    let n = String(98 - parseInt(e, 10) % 97);
    for (; n.length < 2;) n = "0" + n;
    return n
}
const B6 = function() {
    const t = {};
    for (let e = 0; e < 36; e++) {
        const n = "0123456789abcdefghijklmnopqrstuvwxyz" [e];
        t[n] = BigInt(e)
    }
    return t
}();

function I6(t) {
    t = t.toLowerCase();
    let e = C6;
    for (let n = 0; n < t.length; n++) e = e * O6 + B6[t[n]];
    return e
}

function ct(t) {
    if (W(typeof t == "string", "invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        t.startsWith("0x") || (t = "0x" + t);
        const e = mg(t);
        return W(!t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === t, "bad address checksum", "address", t), e
    }
    if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        W(t.substring(2, 4) === T6(t), "bad icap checksum", "address", t);
        let e = I6(t.substring(4)).toString(16);
        for (; e.length < 40;) e = "0" + e;
        return mg("0x" + e)
    }
    W(!1, "invalid address", "address", t)
}

function D6(t) {
    const e = ct(t.from);
    let r = Le(t.nonce, "tx.nonce").toString(16);
    return r === "0" ? r = "0x" : r.length % 2 ? r = "0x0" + r : r = "0x" + r, ct(It(Pt(Ga([e, r])), 12))
}

function Tb(t) {
    return t && typeof t.getAddress == "function"
}
async function Vf(t, e) {
    const n = await e;
    return (n == null || n === "0x0000000000000000000000000000000000000000") && (re(typeof t != "string", "unconfigured name", "UNCONFIGURED_NAME", {
        value: t
    }), W(!1, "invalid AddressLike value; did not resolve to a value address", "target", t)), ct(n)
}

function pn(t, e) {
    if (typeof t == "string") return t.match(/^0x[0-9a-f]{40}$/i) ? ct(t) : (re(e != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName"
    }), Vf(t, e.resolveName(t)));
    if (Tb(t)) return Vf(t, t.getAddress());
    if (t && typeof t.then == "function") return Vf(t, t);
    W(!1, "unsupported addressable value", "target", t)
}
const Gr = {};

function Ne(t, e) {
    let n = !1;
    return e < 0 && (n = !0, e *= -1), new Dt(Gr, `${n?"":"u"}int${e}`, t, {
        signed: n,
        width: e
    })
}

function lt(t, e) {
    return new Dt(Gr, `bytes${e||""}`, t, {
        size: e
    })
}
const yg = Symbol.for("_ethers_typed");
class Dt {
    type;
    value;#
    e;
    _typedSymbol;
    constructor(e, n, r, i) {
        i == null && (i = null), wl(Gr, e, "Typed"), Ue(this, {
            _typedSymbol: yg,
            type: n,
            value: r
        }), this.#e = i, this.format()
    }
    format() {
        if (this.type === "array") throw new Error("");
        if (this.type === "dynamicArray") throw new Error("");
        return this.type === "tuple" ? `tuple(${this.value.map(e=>e.format()).join(",")})` : this.type
    }
    defaultValue() {
        return 0
    }
    minValue() {
        return 0
    }
    maxValue() {
        return 0
    }
    isBigInt() {
        return !!this.type.match(/^u?int[0-9]+$/)
    }
    isData() {
        return this.type.startsWith("bytes")
    }
    isString() {
        return this.type === "string"
    }
    get tupleName() {
        if (this.type !== "tuple") throw TypeError("not a tuple");
        return this.#e
    }
    get arrayLength() {
        if (this.type !== "array") throw TypeError("not an array");
        return this.#e === !0 ? -1 : this.#e === !1 ? this.value.length : null
    }
    static from(e, n) {
        return new Dt(Gr, e, n)
    }
    static uint8(e) {
        return Ne(e, 8)
    }
    static uint16(e) {
        return Ne(e, 16)
    }
    static uint24(e) {
        return Ne(e, 24)
    }
    static uint32(e) {
        return Ne(e, 32)
    }
    static uint40(e) {
        return Ne(e, 40)
    }
    static uint48(e) {
        return Ne(e, 48)
    }
    static uint56(e) {
        return Ne(e, 56)
    }
    static uint64(e) {
        return Ne(e, 64)
    }
    static uint72(e) {
        return Ne(e, 72)
    }
    static uint80(e) {
        return Ne(e, 80)
    }
    static uint88(e) {
        return Ne(e, 88)
    }
    static uint96(e) {
        return Ne(e, 96)
    }
    static uint104(e) {
        return Ne(e, 104)
    }
    static uint112(e) {
        return Ne(e, 112)
    }
    static uint120(e) {
        return Ne(e, 120)
    }
    static uint128(e) {
        return Ne(e, 128)
    }
    static uint136(e) {
        return Ne(e, 136)
    }
    static uint144(e) {
        return Ne(e, 144)
    }
    static uint152(e) {
        return Ne(e, 152)
    }
    static uint160(e) {
        return Ne(e, 160)
    }
    static uint168(e) {
        return Ne(e, 168)
    }
    static uint176(e) {
        return Ne(e, 176)
    }
    static uint184(e) {
        return Ne(e, 184)
    }
    static uint192(e) {
        return Ne(e, 192)
    }
    static uint200(e) {
        return Ne(e, 200)
    }
    static uint208(e) {
        return Ne(e, 208)
    }
    static uint216(e) {
        return Ne(e, 216)
    }
    static uint224(e) {
        return Ne(e, 224)
    }
    static uint232(e) {
        return Ne(e, 232)
    }
    static uint240(e) {
        return Ne(e, 240)
    }
    static uint248(e) {
        return Ne(e, 248)
    }
    static uint256(e) {
        return Ne(e, 256)
    }
    static uint(e) {
        return Ne(e, 256)
    }
    static int8(e) {
        return Ne(e, -8)
    }
    static int16(e) {
        return Ne(e, -16)
    }
    static int24(e) {
        return Ne(e, -24)
    }
    static int32(e) {
        return Ne(e, -32)
    }
    static int40(e) {
        return Ne(e, -40)
    }
    static int48(e) {
        return Ne(e, -48)
    }
    static int56(e) {
        return Ne(e, -56)
    }
    static int64(e) {
        return Ne(e, -64)
    }
    static int72(e) {
        return Ne(e, -72)
    }
    static int80(e) {
        return Ne(e, -80)
    }
    static int88(e) {
        return Ne(e, -88)
    }
    static int96(e) {
        return Ne(e, -96)
    }
    static int104(e) {
        return Ne(e, -104)
    }
    static int112(e) {
        return Ne(e, -112)
    }
    static int120(e) {
        return Ne(e, -120)
    }
    static int128(e) {
        return Ne(e, -128)
    }
    static int136(e) {
        return Ne(e, -136)
    }
    static int144(e) {
        return Ne(e, -144)
    }
    static int152(e) {
        return Ne(e, -152)
    }
    static int160(e) {
        return Ne(e, -160)
    }
    static int168(e) {
        return Ne(e, -168)
    }
    static int176(e) {
        return Ne(e, -176)
    }
    static int184(e) {
        return Ne(e, -184)
    }
    static int192(e) {
        return Ne(e, -192)
    }
    static int200(e) {
        return Ne(e, -200)
    }
    static int208(e) {
        return Ne(e, -208)
    }
    static int216(e) {
        return Ne(e, -216)
    }
    static int224(e) {
        return Ne(e, -224)
    }
    static int232(e) {
        return Ne(e, -232)
    }
    static int240(e) {
        return Ne(e, -240)
    }
    static int248(e) {
        return Ne(e, -248)
    }
    static int256(e) {
        return Ne(e, -256)
    }
    static int(e) {
        return Ne(e, -256)
    }
    static bytes1(e) {
        return lt(e, 1)
    }
    static bytes2(e) {
        return lt(e, 2)
    }
    static bytes3(e) {
        return lt(e, 3)
    }
    static bytes4(e) {
        return lt(e, 4)
    }
    static bytes5(e) {
        return lt(e, 5)
    }
    static bytes6(e) {
        return lt(e, 6)
    }
    static bytes7(e) {
        return lt(e, 7)
    }
    static bytes8(e) {
        return lt(e, 8)
    }
    static bytes9(e) {
        return lt(e, 9)
    }
    static bytes10(e) {
        return lt(e, 10)
    }
    static bytes11(e) {
        return lt(e, 11)
    }
    static bytes12(e) {
        return lt(e, 12)
    }
    static bytes13(e) {
        return lt(e, 13)
    }
    static bytes14(e) {
        return lt(e, 14)
    }
    static bytes15(e) {
        return lt(e, 15)
    }
    static bytes16(e) {
        return lt(e, 16)
    }
    static bytes17(e) {
        return lt(e, 17)
    }
    static bytes18(e) {
        return lt(e, 18)
    }
    static bytes19(e) {
        return lt(e, 19)
    }
    static bytes20(e) {
        return lt(e, 20)
    }
    static bytes21(e) {
        return lt(e, 21)
    }
    static bytes22(e) {
        return lt(e, 22)
    }
    static bytes23(e) {
        return lt(e, 23)
    }
    static bytes24(e) {
        return lt(e, 24)
    }
    static bytes25(e) {
        return lt(e, 25)
    }
    static bytes26(e) {
        return lt(e, 26)
    }
    static bytes27(e) {
        return lt(e, 27)
    }
    static bytes28(e) {
        return lt(e, 28)
    }
    static bytes29(e) {
        return lt(e, 29)
    }
    static bytes30(e) {
        return lt(e, 30)
    }
    static bytes31(e) {
        return lt(e, 31)
    }
    static bytes32(e) {
        return lt(e, 32)
    }
    static address(e) {
        return new Dt(Gr, "address", e)
    }
    static bool(e) {
        return new Dt(Gr, "bool", !!e)
    }
    static bytes(e) {
        return new Dt(Gr, "bytes", e)
    }
    static string(e) {
        return new Dt(Gr, "string", e)
    }
    static array(e, n) {
        throw new Error("not implemented yet")
    }
    static tuple(e, n) {
        throw new Error("not implemented yet")
    }
    static overrides(e) {
        return new Dt(Gr, "overrides", Object.assign({}, e))
    }
    static isTyped(e) {
        return e && typeof e == "object" && "_typedSymbol" in e && e._typedSymbol === yg
    }
    static dereference(e, n) {
        if (Dt.isTyped(e)) {
            if (e.type !== n) throw new Error(`invalid type: expecetd ${n}, got ${e.type}`);
            return e.value
        }
        return e
    }
}
class L6 extends di {
    constructor(e) {
        super("address", "address", e, !1)
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000"
    }
    encode(e, n) {
        let r = Dt.dereference(n, "string");
        try {
            r = ct(r)
        } catch (i) {
            return this._throwError(i.message, n)
        }
        return e.writeValue(r)
    }
    decode(e) {
        return ct(Vi(e.readValue(), 20))
    }
}
class M6 extends di {
    coder;
    constructor(e) {
        super(e.name, e.type, "_", e.dynamic), this.coder = e
    }
    defaultValue() {
        return this.coder.defaultValue()
    }
    encode(e, n) {
        return this.coder.encode(e, n)
    }
    decode(e) {
        return this.coder.decode(e)
    }
}

function Bb(t, e, n) {
    let r = [];
    if (Array.isArray(n)) r = n;
    else if (n && typeof n == "object") {
        let c = {};
        r = e.map(l => {
            const u = l.localName;
            return re(u, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
                argument: "values",
                info: {
                    coder: l
                },
                value: n
            }), re(!c[u], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
                argument: "values",
                info: {
                    coder: l
                },
                value: n
            }), c[u] = !0, n[u]
        })
    } else W(!1, "invalid tuple value", "tuple", n);
    W(e.length === r.length, "types/value length mismatch", "tuple", n);
    let i = new Kd,
        s = new Kd,
        o = [];
    e.forEach((c, l) => {
        let u = r[l];
        if (c.dynamic) {
            let f = s.length;
            c.encode(s, u);
            let d = i.writeUpdatableValue();
            o.push(h => {
                d(h + f)
            })
        } else c.encode(i, u)
    }), o.forEach(c => {
        c(i.length)
    });
    let a = t.appendWriter(i);
    return a += t.appendWriter(s), a
}

function Ib(t, e) {
    let n = [],
        r = [],
        i = t.subReader(0);
    return e.forEach(s => {
        let o = null;
        if (s.dynamic) {
            let a = t.readIndex(),
                c = i.subReader(a);
            try {
                o = s.decode(c)
            } catch (l) {
                if (Wn(l, "BUFFER_OVERRUN")) throw l;
                o = l, o.baseType = s.name, o.name = s.localName, o.type = s.type
            }
        } else try {
            o = s.decode(t)
        } catch (a) {
            if (Wn(a, "BUFFER_OVERRUN")) throw a;
            o = a, o.baseType = s.name, o.name = s.localName, o.type = s.type
        }
        if (o == null) throw new Error("investigate");
        n.push(o), r.push(s.localName || null)
    }), xo.fromItems(n, r)
}
class F6 extends di {
    coder;
    length;
    constructor(e, n, r) {
        const i = e.type + "[" + (n >= 0 ? n : "") + "]",
            s = n === -1 || e.dynamic;
        super("array", i, r, s), Ue(this, {
            coder: e,
            length: n
        })
    }
    defaultValue() {
        const e = this.coder.defaultValue(),
            n = [];
        for (let r = 0; r < this.length; r++) n.push(e);
        return n
    }
    encode(e, n) {
        const r = Dt.dereference(n, "array");
        Array.isArray(r) || this._throwError("expected array value", r);
        let i = this.length;
        i === -1 && (i = r.length, e.writeValue(r.length)), $v(r.length, i, "coder array" + (this.localName ? " " + this.localName : ""));
        let s = [];
        for (let o = 0; o < r.length; o++) s.push(this.coder);
        return Bb(e, s, r)
    }
    decode(e) {
        let n = this.length;
        n === -1 && (n = e.readIndex(), re(n * hn <= e.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
            buffer: e.bytes,
            offset: n * hn,
            length: e.dataLength
        }));
        let r = [];
        for (let i = 0; i < n; i++) r.push(new M6(this.coder));
        return Ib(e, r)
    }
}
class U6 extends di {
    constructor(e) {
        super("bool", "bool", e, !1)
    }
    defaultValue() {
        return !1
    }
    encode(e, n) {
        const r = Dt.dereference(n, "bool");
        return e.writeValue(r ? 1 : 0)
    }
    decode(e) {
        return !!e.readValue()
    }
}
class Db extends di {
    constructor(e, n) {
        super(e, e, n, !0)
    }
    defaultValue() {
        return "0x"
    }
    encode(e, n) {
        n = kn(n);
        let r = e.writeValue(n.length);
        return r += e.writeBytes(n), r
    }
    decode(e) {
        return e.readBytes(e.readIndex(), !0)
    }
}
class H6 extends Db {
    constructor(e) {
        super("bytes", e)
    }
    decode(e) {
        return De(super.decode(e))
    }
}
class z6 extends di {
    size;
    constructor(e, n) {
        let r = "bytes" + String(e);
        super(r, r, n, !1), Ue(this, {
            size: e
        }, {
            size: "number"
        })
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2)
    }
    encode(e, n) {
        let r = kn(Dt.dereference(n, this.type));
        return r.length !== this.size && this._throwError("incorrect data length", n), e.writeBytes(r)
    }
    decode(e) {
        return De(e.readBytes(this.size))
    }
}
const j6 = new Uint8Array([]);
class V6 extends di {
    constructor(e) {
        super("null", "", e, !1)
    }
    defaultValue() {
        return null
    }
    encode(e, n) {
        return n != null && this._throwError("not null", n), e.writeBytes(j6)
    }
    decode(e) {
        return e.readBytes(0), null
    }
}
const G6 = BigInt(0),
    W6 = BigInt(1),
    Q6 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
class J6 extends di {
    size;
    signed;
    constructor(e, n, r) {
        const i = (n ? "int" : "uint") + e * 8;
        super(i, i, r, !1), Ue(this, {
            size: e,
            signed: n
        }, {
            size: "number",
            signed: "boolean"
        })
    }
    defaultValue() {
        return 0
    }
    encode(e, n) {
        let r = Le(Dt.dereference(n, this.type)),
            i = hs(Q6, hn * 8);
        if (this.signed) {
            let s = hs(i, this.size * 8 - 1);
            (r > s || r < -(s + W6)) && this._throwError("value out-of-bounds", n), r = yp(r, 8 * hn)
        } else(r < G6 || r > hs(i, this.size * 8)) && this._throwError("value out-of-bounds", n);
        return e.writeValue(r)
    }
    decode(e) {
        let n = hs(e.readValue(), this.size * 8);
        return this.signed && (n = nu(n, this.size * 8)), n
    }
}
class K6 extends Db {
    constructor(e) {
        super("string", e)
    }
    defaultValue() {
        return ""
    }
    encode(e, n) {
        return super.encode(e, Nr(Dt.dereference(n, "string")))
    }
    decode(e) {
        return vp(super.decode(e))
    }
}
class ac extends di {
    coders;
    constructor(e, n) {
        let r = !1;
        const i = [];
        e.forEach(o => {
            o.dynamic && (r = !0), i.push(o.type)
        });
        const s = "tuple(" + i.join(",") + ")";
        super("tuple", s, n, r), Ue(this, {
            coders: Object.freeze(e.slice())
        })
    }
    defaultValue() {
        const e = [];
        this.coders.forEach(r => {
            e.push(r.defaultValue())
        });
        const n = this.coders.reduce((r, i) => {
            const s = i.localName;
            return s && (r[s] || (r[s] = 0), r[s]++), r
        }, {});
        return this.coders.forEach((r, i) => {
            let s = r.localName;
            !s || n[s] !== 1 || (s === "length" && (s = "_length"), e[s] == null && (e[s] = e[i]))
        }), Object.freeze(e)
    }
    encode(e, n) {
        const r = Dt.dereference(n, "tuple");
        return Bb(e, this.coders, r)
    }
    decode(e) {
        return Ib(e, this.coders)
    }
}

function Rs(t) {
    return Pt(Nr(t))
}
var Z6 = "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";
const vg = new Map([
        [8217, "apostrophe"],
        [8260, "fraction slash"],
        [12539, "middle dot"]
    ]),
    bg = 4;

function Y6(t) {
    let e = 0;

    function n() {
        return t[e++] << 8 | t[e++]
    }
    let r = n(),
        i = 1,
        s = [0, 1];
    for (let U = 1; U < r; U++) s.push(i += n());
    let o = n(),
        a = e;
    e += o;
    let c = 0,
        l = 0;

    function u() {
        return c == 0 && (l = l << 8 | t[e++], c = 8), l >> --c & 1
    }
    const f = 31,
        d = 2 ** f,
        h = d >>> 1,
        p = h >> 1,
        g = d - 1;
    let b = 0;
    for (let U = 0; U < f; U++) b = b << 1 | u();
    let x = [],
        w = 0,
        O = d;
    for (;;) {
        let U = Math.floor(((b - w + 1) * i - 1) / O),
            H = 0,
            M = r;
        for (; M - H > 1;) {
            let A = H + M >>> 1;
            U < s[A] ? M = A : H = A
        }
        if (H == 0) break;
        x.push(H);
        let y = w + Math.floor(O * s[H] / i),
            v = w + Math.floor(O * s[H + 1] / i) - 1;
        for (; !((y ^ v) & h);) b = b << 1 & g | u(), y = y << 1 & g, v = v << 1 & g | 1;
        for (; y & ~v & p;) b = b & h | b << 1 & g >>> 1 | u(), y = y << 1 ^ h, v = (v ^ h) << 1 | h | 1;
        w = y, O = 1 + v - y
    }
    let N = r - 4;
    return x.map(U => {
        switch (U - N) {
            case 3:
                return N + 65792 + (t[a++] << 16 | t[a++] << 8 | t[a++]);
            case 2:
                return N + 256 + (t[a++] << 8 | t[a++]);
            case 1:
                return N + t[a++];
            default:
                return U - 1
        }
    })
}

function X6(t) {
    let e = 0;
    return () => t[e++]
}

function Lb(t) {
    return X6(Y6(q6(t)))
}

function q6(t) {
    let e = [];
    [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((i, s) => e[i.charCodeAt(0)] = s);
    let n = t.length,
        r = new Uint8Array(6 * n >> 3);
    for (let i = 0, s = 0, o = 0, a = 0; i < n; i++) a = a << 6 | e[t.charCodeAt(i)], o += 6, o >= 8 && (r[s++] = a >> (o -= 8));
    return r
}

function $6(t) {
    return t & 1 ? ~t >> 1 : t >> 1
}

function e8(t, e) {
    let n = Array(t);
    for (let r = 0, i = 0; r < t; r++) n[r] = i += $6(e());
    return n
}

function Qa(t, e = 0) {
    let n = [];
    for (;;) {
        let r = t(),
            i = t();
        if (!i) break;
        e += r;
        for (let s = 0; s < i; s++) n.push(e + s);
        e += i + 1
    }
    return n
}

function Mb(t) {
    return Ja(() => {
        let e = Qa(t);
        if (e.length) return e
    })
}

function Fb(t) {
    let e = [];
    for (;;) {
        let n = t();
        if (n == 0) break;
        e.push(t8(n, t))
    }
    for (;;) {
        let n = t() - 1;
        if (n < 0) break;
        e.push(n8(n, t))
    }
    return e.flat()
}

function Ja(t) {
    let e = [];
    for (;;) {
        let n = t(e.length);
        if (!n) break;
        e.push(n)
    }
    return e
}

function Ub(t, e, n) {
    let r = Array(t).fill().map(() => []);
    for (let i = 0; i < e; i++) e8(t, n).forEach((s, o) => r[o].push(s));
    return r
}

function t8(t, e) {
    let n = 1 + e(),
        r = e(),
        i = Ja(e);
    return Ub(i.length, 1 + t, e).flatMap((o, a) => {
        let [c, ...l] = o;
        return Array(i[a]).fill().map((u, f) => {
            let d = f * r;
            return [c + f * n, l.map(h => h + d)]
        })
    })
}

function n8(t, e) {
    let n = 1 + e();
    return Ub(n, 1 + t, e).map(i => [i[0], i.slice(1)])
}

function r8(t) {
    let e = [],
        n = Qa(t);
    return i(r([]), []), e;

    function r(s) {
        let o = t(),
            a = Ja(() => {
                let c = Qa(t).map(l => n[l]);
                if (c.length) return r(c)
            });
        return {
            S: o,
            B: a,
            Q: s
        }
    }

    function i({
        S: s,
        B: o
    }, a, c) {
        if (!(s & 4 && c === a[a.length - 1])) {
            s & 2 && (c = a[a.length - 1]), s & 1 && e.push(a);
            for (let l of o)
                for (let u of l.Q) i(l, [...a, u], c)
        }
    }
}

function i8(t) {
    return t.toString(16).toUpperCase().padStart(2, "0")
}

function Hb(t) {
    return `{${i8(t)}}`
}

function s8(t) {
    let e = [];
    for (let n = 0, r = t.length; n < r;) {
        let i = t.codePointAt(n);
        n += i < 65536 ? 1 : 2, e.push(i)
    }
    return e
}

function Do(t) {
    let n = t.length;
    if (n < 4096) return String.fromCodePoint(...t);
    let r = [];
    for (let i = 0; i < n;) r.push(String.fromCodePoint(...t.slice(i, i += 4096)));
    return r.join("")
}

function o8(t, e) {
    let n = t.length,
        r = n - e.length;
    for (let i = 0; r == 0 && i < n; i++) r = t[i] - e[i];
    return r
}
var a8 = "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";
const Ka = 44032,
    iu = 4352,
    su = 4449,
    ou = 4519,
    zb = 19,
    jb = 21,
    Lo = 28,
    au = jb * Lo,
    l8 = zb * au,
    c8 = Ka + l8,
    u8 = iu + zb,
    f8 = su + jb,
    d8 = ou + Lo;

function ma(t) {
    return t >> 24 & 255
}

function Vb(t) {
    return t & 16777215
}
let eh, wg, th, Bc;

function h8() {
    let t = Lb(a8);
    eh = new Map(Mb(t).flatMap((e, n) => e.map(r => [r, n + 1 << 24]))), wg = new Set(Qa(t)), th = new Map, Bc = new Map;
    for (let [e, n] of Fb(t)) {
        if (!wg.has(e) && n.length == 2) {
            let [r, i] = n, s = Bc.get(r);
            s || (s = new Map, Bc.set(r, s)), s.set(i, e)
        }
        th.set(e, n.reverse())
    }
}

function Gb(t) {
    return t >= Ka && t < c8
}

function p8(t, e) {
    if (t >= iu && t < u8 && e >= su && e < f8) return Ka + (t - iu) * au + (e - su) * Lo;
    if (Gb(t) && e > ou && e < d8 && (t - Ka) % Lo == 0) return t + (e - ou); {
        let n = Bc.get(t);
        return n && (n = n.get(e), n) ? n : -1
    }
}

function Wb(t) {
    eh || h8();
    let e = [],
        n = [],
        r = !1;

    function i(s) {
        let o = eh.get(s);
        o && (r = !0, s |= o), e.push(s)
    }
    for (let s of t)
        for (;;) {
            if (s < 128) e.push(s);
            else if (Gb(s)) {
                let o = s - Ka,
                    a = o / au | 0,
                    c = o % au / Lo | 0,
                    l = o % Lo;
                i(iu + a), i(su + c), l > 0 && i(ou + l)
            } else {
                let o = th.get(s);
                o ? n.push(...o) : i(s)
            }
            if (!n.length) break;
            s = n.pop()
        }
    if (r && e.length > 1) {
        let s = ma(e[0]);
        for (let o = 1; o < e.length; o++) {
            let a = ma(e[o]);
            if (a == 0 || s <= a) {
                s = a;
                continue
            }
            let c = o - 1;
            for (;;) {
                let l = e[c + 1];
                if (e[c + 1] = e[c], e[c] = l, !c || (s = ma(e[--c]), s <= a)) break
            }
            s = ma(e[o])
        }
    }
    return e
}

function m8(t) {
    let e = [],
        n = [],
        r = -1,
        i = 0;
    for (let s of t) {
        let o = ma(s),
            a = Vb(s);
        if (r == -1) o == 0 ? r = a : e.push(a);
        else if (i > 0 && i >= o) o == 0 ? (e.push(r, ...n), n.length = 0, r = a) : n.push(a), i = o;
        else {
            let c = p8(r, a);
            c >= 0 ? r = c : i == 0 && o == 0 ? (e.push(r), r = a) : (n.push(a), i = o)
        }
    }
    return r >= 0 && e.push(r, ...n), e
}

function Qb(t) {
    return Wb(t).map(Vb)
}

function g8(t) {
    return m8(Wb(t))
}
const xg = 45,
    Jb = ".",
    Kb = 65039,
    Zb = 1,
    fo = t => Array.from(t);

function Za(t, e) {
    return t.P.has(e) || t.Q.has(e)
}
class y8 extends Array {
    get is_emoji() {
        return !0
    }
}
let nh, Yb, ms, rh, Xb, Ao, Gf, so, qb, Ag, ih;

function Rp() {
    if (nh) return;
    let t = Lb(Z6);
    const e = () => Qa(t),
        n = () => new Set(e());
    nh = new Map(Fb(t)), Yb = n(), ms = e(), rh = new Set(e().map(u => ms[u])), ms = new Set(ms), Xb = n(), n();
    let r = Mb(t),
        i = t();
    const s = () => new Set(e().flatMap(u => r[u]).concat(e()));
    Ao = Ja(u => {
        let f = Ja(t).map(d => d + 96);
        if (f.length) {
            let d = u >= i;
            f[0] -= 32, f = Do(f), d && (f = `Restricted[${f}]`);
            let h = s(),
                p = s(),
                g = !t();
            return {
                N: f,
                P: h,
                Q: p,
                M: g,
                R: d
            }
        }
    }), Gf = n(), so = new Map;
    let o = e().concat(fo(Gf)).sort((u, f) => u - f);
    o.forEach((u, f) => {
        let d = t(),
            h = o[f] = d ? o[f - d] : {
                V: [],
                M: new Map
            };
        h.V.push(u), Gf.has(u) || so.set(u, h)
    });
    for (let {
            V: u,
            M: f
        } of new Set(so.values())) {
        let d = [];
        for (let p of u) {
            let g = Ao.filter(x => Za(x, p)),
                b = d.find(({
                    G: x
                }) => g.some(w => x.has(w)));
            b || (b = {
                G: new Set,
                V: []
            }, d.push(b)), b.V.push(p), g.forEach(x => b.G.add(x))
        }
        let h = d.flatMap(p => fo(p.G));
        for (let {
                G: p,
                V: g
            } of d) {
            let b = new Set(h.filter(x => !p.has(x)));
            for (let x of g) f.set(x, b)
        }
    }
    let a = new Set,
        c = new Set;
    const l = u => a.has(u) ? c.add(u) : a.add(u);
    for (let u of Ao) {
        for (let f of u.P) l(f);
        for (let f of u.Q) l(f)
    }
    for (let u of a) !so.has(u) && !c.has(u) && so.set(u, Zb);
    qb = new Set(fo(a).concat(fo(Qb(a)))), Ag = r8(t).map(u => y8.from(u)).sort(o8), ih = new Map;
    for (let u of Ag) {
        let f = [ih];
        for (let d of u) {
            let h = f.map(p => {
                let g = p.get(d);
                return g || (g = new Map, p.set(d, g)), g
            });
            d === Kb ? f.push(...h) : f = h
        }
        for (let d of f) d.V = u
    }
}

function Cp(t) {
    return ($b(t) ? "" : `${Op(Gu([t]))} `) + Hb(t)
}

function Op(t) {
    return `"${t}"`
}

function v8(t) {
    if (t.length >= 4 && t[2] == xg && t[3] == xg) throw new Error(`invalid label extension: "${Do(t.slice(0,4))}"`)
}

function b8(t) {
    for (let n = t.lastIndexOf(95); n > 0;)
        if (t[--n] !== 95) throw new Error("underscore allowed only at start")
}

function w8(t) {
    let e = t[0],
        n = vg.get(e);
    if (n) throw Na(`leading ${n}`);
    let r = t.length,
        i = -1;
    for (let s = 1; s < r; s++) {
        e = t[s];
        let o = vg.get(e);
        if (o) {
            if (i == s) throw Na(`${n} + ${o}`);
            i = s + 1, n = o
        }
    }
    if (i == r) throw Na(`trailing ${n}`)
}

function Gu(t, e = Hb) {
    let n = [];
    x8(t[0]) && n.push("");
    let r = 0,
        i = t.length;
    for (let s = 0; s < i; s++) {
        let o = t[s];
        $b(o) && (n.push(Do(t.slice(r, s))), n.push(e(o)), r = s + 1)
    }
    return n.push(Do(t.slice(r, i))), n.join("")
}

function x8(t) {
    return Rp(), ms.has(t)
}

function $b(t) {
    return Rp(), Xb.has(t)
}

function A8(t) {
    return P8(k8(t, g8, R8))
}

function k8(t, e, n) {
    if (!t) return [];
    Rp();
    let r = 0;
    return t.split(Jb).map(i => {
        let s = s8(i),
            o = {
                input: s,
                offset: r
            };
        r += s.length + 1;
        try {
            let a = o.tokens = N8(s, e, n),
                c = a.length,
                l;
            if (!c) throw new Error("empty label");
            let u = o.output = a.flat();
            if (b8(u), !(o.emoji = c > 1 || a[0].is_emoji) && u.every(d => d < 128)) v8(u), l = "ASCII";
            else {
                let d = a.flatMap(h => h.is_emoji ? [] : h);
                if (!d.length) l = "Emoji";
                else {
                    if (ms.has(u[0])) throw Na("leading combining mark");
                    for (let g = 1; g < c; g++) {
                        let b = a[g];
                        if (!b.is_emoji && ms.has(b[0])) throw Na(`emoji + combining mark: "${Do(a[g-1])} + ${Gu([b[0]])}"`)
                    }
                    w8(u);
                    let h = fo(new Set(d)),
                        [p] = E8(h);
                    S8(p, d), _8(p, h), l = p.N
                }
            }
            o.type = l
        } catch (a) {
            o.error = a
        }
        return o
    })
}

function _8(t, e) {
    let n, r = [];
    for (let i of e) {
        let s = so.get(i);
        if (s === Zb) return;
        if (s) {
            let o = s.M.get(i);
            if (n = n ? n.filter(a => o.has(a)) : fo(o), !n.length) return
        } else r.push(i)
    }
    if (n) {
        for (let i of n)
            if (r.every(s => Za(i, s))) throw new Error(`whole-script confusable: ${t.N}/${i.N}`)
    }
}

function E8(t) {
    let e = Ao;
    for (let n of t) {
        let r = e.filter(i => Za(i, n));
        if (!r.length) throw Ao.some(i => Za(i, n)) ? tw(e[0], n) : ew(n);
        if (e = r, r.length == 1) break
    }
    return e
}

function P8(t) {
    return t.map(({
        input: e,
        error: n,
        output: r
    }) => {
        if (n) {
            let i = n.message;
            throw new Error(t.length == 1 ? i : `Invalid label ${Op(Gu(e))}: ${i}`)
        }
        return Do(r)
    }).join(Jb)
}

function ew(t) {
    return new Error(`disallowed character: ${Cp(t)}`)
}

function tw(t, e) {
    let n = Cp(e),
        r = Ao.find(i => i.P.has(e));
    return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${t.N} + ${n}`)
}

function Na(t) {
    return new Error(`illegal placement: ${t}`)
}

function S8(t, e) {
    for (let n of e)
        if (!Za(t, n)) throw tw(t, n);
    if (t.M) {
        let n = Qb(e);
        for (let r = 1, i = n.length; r < i; r++)
            if (rh.has(n[r])) {
                let s = r + 1;
                for (let o; s < i && rh.has(o = n[s]); s++)
                    for (let a = r; a < s; a++)
                        if (n[a] == o) throw new Error(`duplicate non-spacing marks: ${Cp(o)}`);
                if (s - r > bg) throw new Error(`excessive non-spacing marks: ${Op(Gu(n.slice(r-1,s)))} (${s-r}/${bg})`);
                r = s
            }
    }
}

function N8(t, e, n) {
    let r = [],
        i = [];
    for (t = t.slice().reverse(); t.length;) {
        let s = C8(t);
        if (s) i.length && (r.push(e(i)), i = []), r.push(n(s));
        else {
            let o = t.pop();
            if (qb.has(o)) i.push(o);
            else {
                let a = nh.get(o);
                if (a) i.push(...a);
                else if (!Yb.has(o)) throw ew(o)
            }
        }
    }
    return i.length && r.push(e(i)), r
}

function R8(t) {
    return t.filter(e => e != Kb)
}

function C8(t, e) {
    let n = ih,
        r, i = t.length;
    for (; i && (n = n.get(t[--i]), !!n);) {
        let {
            V: s
        } = n;
        s && (r = s, e && e.push(...t.slice(i).reverse()), t.length = i)
    }
    return r
}
const nw = new Uint8Array(32);
nw.fill(0);

function kg(t) {
    return W(t.length !== 0, "invalid ENS name; empty component", "comp", t), t
}

function rw(t) {
    const e = Nr(O8(t)),
        n = [];
    if (t.length === 0) return n;
    let r = 0;
    for (let i = 0; i < e.length; i++) e[i] === 46 && (n.push(kg(e.slice(r, i))), r = i + 1);
    return W(r < e.length, "invalid ENS name; empty component", "name", t), n.push(kg(e.slice(r))), n
}

function O8(t) {
    try {
        if (t.length === 0) throw new Error("empty label");
        return A8(t)
    } catch (e) {
        W(!1, `invalid ENS name (${e.message})`, "name", t)
    }
}

function sh(t) {
    W(typeof t == "string", "invalid ENS name; not a string", "name", t), W(t.length, "invalid ENS name (empty label)", "name", t);
    let e = nw;
    const n = rw(t);
    for (; n.length;) e = Pt(Ht([e, Pt(n.pop())]));
    return De(e)
}

function T8(t) {
    return De(Ht(rw(t).map(e => {
        if (e.length > 63) throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
        const n = new Uint8Array(e.length + 1);
        return n.set(e, 1), n[0] = n.length - 1, n
    }))) + "00"
}

function Wf(t, e) {
    return {
        address: ct(t),
        storageKeys: e.map((n, r) => (W(Ot(n, 32), "invalid slot", `storageKeys[${r}]`, n), n.toLowerCase()))
    }
}

function Hs(t) {
    if (Array.isArray(t)) return t.map((n, r) => Array.isArray(n) ? (W(n.length === 2, "invalid slot set", `value[${r}]`, n), Wf(n[0], n[1])) : (W(n != null && typeof n == "object", "invalid address-slot set", "value", t), Wf(n.address, n.storageKeys)));
    W(t != null && typeof t == "object", "invalid access list", "value", t);
    const e = Object.keys(t).map(n => {
        const r = t[n].reduce((i, s) => (i[s] = !0, i), {});
        return Wf(n, Object.keys(r).sort())
    });
    return e.sort((n, r) => n.address.localeCompare(r.address)), e
}

function B8(t) {
    let e;
    return typeof t == "string" ? e = Yr.computePublicKey(t, !1) : e = t.publicKey, ct(Pt("0x" + e.substring(4)).substring(26))
}

function I8(t, e) {
    return B8(Yr.recoverPublicKey(t, e))
}
const xn = BigInt(0),
    D8 = BigInt(2),
    L8 = BigInt(27),
    M8 = BigInt(28),
    F8 = BigInt(35),
    U8 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

function Tp(t) {
    return t === "0x" ? null : ct(t)
}

function iw(t, e) {
    try {
        return Hs(t)
    } catch (n) {
        W(!1, n.message, e, t)
    }
}

function Wu(t, e) {
    return t === "0x" ? 0 : $e(t, e)
}

function dn(t, e) {
    if (t === "0x") return xn;
    const n = Le(t, e);
    return W(n <= U8, "value exceeds uint size", e, n), n
}

function nn(t, e) {
    const n = Le(t, "value"),
        r = _n(n);
    return W(r.length <= 32, "value too large", `tx.${e}`, n), r
}

function sw(t) {
    return Hs(t).map(e => [e.address, e.storageKeys])
}

function H8(t) {
    const e = bp(t);
    W(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", t);
    const n = {
        type: 0,
        nonce: Wu(e[0], "nonce"),
        gasPrice: dn(e[1], "gasPrice"),
        gasLimit: dn(e[2], "gasLimit"),
        to: Tp(e[3]),
        value: dn(e[4], "value"),
        data: De(e[5]),
        chainId: xn
    };
    if (e.length === 6) return n;
    const r = dn(e[6], "v"),
        i = dn(e[7], "r"),
        s = dn(e[8], "s");
    if (i === xn && s === xn) n.chainId = r;
    else {
        let o = (r - F8) / D8;
        o < xn && (o = xn), n.chainId = o, W(o !== xn || r === L8 || r === M8, "non-canonical legacy v", "v", e[6]), n.signature = Qt.from({
            r: Sr(e[7], 32),
            s: Sr(e[8], 32),
            v: r
        }), n.hash = Pt(t)
    }
    return n
}

function _g(t, e) {
    const n = [nn(t.nonce || 0, "nonce"), nn(t.gasPrice || 0, "gasPrice"), nn(t.gasLimit || 0, "gasLimit"), t.to != null ? ct(t.to) : "0x", nn(t.value || 0, "value"), t.data || "0x"];
    let r = xn;
    if (t.chainId != xn) r = Le(t.chainId, "tx.chainId"), W(!e || e.networkV == null || e.legacyChainId === r, "tx.chainId/sig.v mismatch", "sig", e);
    else if (t.signature) {
        const s = t.signature.legacyChainId;
        s != null && (r = s)
    }
    if (!e) return r !== xn && (n.push(_n(r)), n.push("0x"), n.push("0x")), Ga(n);
    let i = BigInt(27 + e.yParity);
    return r !== xn ? i = Qt.getChainIdV(r, e.v) : BigInt(e.v) !== i && W(!1, "tx.chainId/sig.v mismatch", "sig", e), n.push(_n(i)), n.push(_n(e.r)), n.push(_n(e.s)), Ga(n)
}

function ow(t, e) {
    let n;
    try {
        if (n = Wu(e[0], "yParity"), n !== 0 && n !== 1) throw new Error("bad yParity")
    } catch {
        W(!1, "invalid yParity", "yParity", e[0])
    }
    const r = Sr(e[1], 32),
        i = Sr(e[2], 32),
        s = Qt.from({
            r,
            s: i,
            yParity: n
        });
    t.signature = s
}

function z8(t) {
    const e = bp(qe(t).slice(1));
    W(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", De(t));
    const n = dn(e[2], "maxPriorityFeePerGas"),
        r = dn(e[3], "maxFeePerGas"),
        i = {
            type: 2,
            chainId: dn(e[0], "chainId"),
            nonce: Wu(e[1], "nonce"),
            maxPriorityFeePerGas: n,
            maxFeePerGas: r,
            gasPrice: null,
            gasLimit: dn(e[4], "gasLimit"),
            to: Tp(e[5]),
            value: dn(e[6], "value"),
            data: De(e[7]),
            accessList: iw(e[8], "accessList")
        };
    return e.length === 9 || (i.hash = Pt(t), ow(i, e.slice(9))), i
}

function Eg(t, e) {
    const n = [nn(t.chainId || 0, "chainId"), nn(t.nonce || 0, "nonce"), nn(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), nn(t.maxFeePerGas || 0, "maxFeePerGas"), nn(t.gasLimit || 0, "gasLimit"), t.to != null ? ct(t.to) : "0x", nn(t.value || 0, "value"), t.data || "0x", sw(t.accessList || [])];
    return e && (n.push(nn(e.yParity, "yParity")), n.push(_n(e.r)), n.push(_n(e.s))), Ht(["0x02", Ga(n)])
}

function j8(t) {
    const e = bp(qe(t).slice(1));
    W(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", De(t));
    const n = {
        type: 1,
        chainId: dn(e[0], "chainId"),
        nonce: Wu(e[1], "nonce"),
        gasPrice: dn(e[2], "gasPrice"),
        gasLimit: dn(e[3], "gasLimit"),
        to: Tp(e[4]),
        value: dn(e[5], "value"),
        data: De(e[6]),
        accessList: iw(e[7], "accessList")
    };
    return e.length === 8 || (n.hash = Pt(t), ow(n, e.slice(8))), n
}

function Pg(t, e) {
    const n = [nn(t.chainId || 0, "chainId"), nn(t.nonce || 0, "nonce"), nn(t.gasPrice || 0, "gasPrice"), nn(t.gasLimit || 0, "gasLimit"), t.to != null ? ct(t.to) : "0x", nn(t.value || 0, "value"), t.data || "0x", sw(t.accessList || [])];
    return e && (n.push(nn(e.yParity, "recoveryParam")), n.push(_n(e.r)), n.push(_n(e.s))), Ht(["0x01", Ga(n)])
}
class Wr {#
    e;#
    t;#
    n;#
    r;#
    i;#
    s;#
    o;#
    a;#
    u;#
    c;#
    f;#
    d;
    get type() {
        return this.#e
    }
    set type(e) {
        switch (e) {
            case null:
                this.#e = null;
                break;
            case 0:
            case "legacy":
                this.#e = 0;
                break;
            case 1:
            case "berlin":
            case "eip-2930":
                this.#e = 1;
                break;
            case 2:
            case "london":
            case "eip-1559":
                this.#e = 2;
                break;
            default:
                W(!1, "unsupported transaction type", "type", e)
        }
    }
    get typeName() {
        switch (this.type) {
            case 0:
                return "legacy";
            case 1:
                return "eip-2930";
            case 2:
                return "eip-1559"
        }
        return null
    }
    get to() {
        return this.#t
    }
    set to(e) {
        this.#t = e == null ? null : ct(e)
    }
    get nonce() {
        return this.#r
    }
    set nonce(e) {
        this.#r = $e(e, "value")
    }
    get gasLimit() {
        return this.#i
    }
    set gasLimit(e) {
        this.#i = Le(e)
    }
    get gasPrice() {
        const e = this.#s;
        return e == null && (this.type === 0 || this.type === 1) ? xn : e
    }
    set gasPrice(e) {
        this.#s = e == null ? null : Le(e, "gasPrice")
    }
    get maxPriorityFeePerGas() {
        const e = this.#o;
        return e ? ? (this.type === 2 ? xn : null)
    }
    set maxPriorityFeePerGas(e) {
        this.#o = e == null ? null : Le(e, "maxPriorityFeePerGas")
    }
    get maxFeePerGas() {
        const e = this.#a;
        return e ? ? (this.type === 2 ? xn : null)
    }
    set maxFeePerGas(e) {
        this.#a = e == null ? null : Le(e, "maxFeePerGas")
    }
    get data() {
        return this.#n
    }
    set data(e) {
        this.#n = De(e)
    }
    get value() {
        return this.#u
    }
    set value(e) {
        this.#u = Le(e, "value")
    }
    get chainId() {
        return this.#c
    }
    set chainId(e) {
        this.#c = Le(e)
    }
    get signature() {
        return this.#f || null
    }
    set signature(e) {
        this.#f = e == null ? null : Qt.from(e)
    }
    get accessList() {
        const e = this.#d || null;
        return e ? ? (this.type === 1 || this.type === 2 ? [] : null)
    }
    set accessList(e) {
        this.#d = e == null ? null : Hs(e)
    }
    constructor() {
        this.#e = null, this.#t = null, this.#r = 0, this.#i = BigInt(0), this.#s = null, this.#o = null, this.#a = null, this.#n = "0x", this.#u = BigInt(0), this.#c = BigInt(0), this.#f = null, this.#d = null
    }
    get hash() {
        return this.signature == null ? null : Pt(this.serialized)
    }
    get unsignedHash() {
        return Pt(this.unsignedSerialized)
    }
    get from() {
        return this.signature == null ? null : I8(this.unsignedHash, this.signature)
    }
    get fromPublicKey() {
        return this.signature == null ? null : Yr.recoverPublicKey(this.unsignedHash, this.signature)
    }
    isSigned() {
        return this.signature != null
    }
    get serialized() {
        switch (re(this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
            operation: ".serialized"
        }), this.inferType()) {
            case 0:
                return _g(this, this.signature);
            case 1:
                return Pg(this, this.signature);
            case 2:
                return Eg(this, this.signature)
        }
        re(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
            operation: ".serialized"
        })
    }
    get unsignedSerialized() {
        switch (this.inferType()) {
            case 0:
                return _g(this);
            case 1:
                return Pg(this);
            case 2:
                return Eg(this)
        }
        re(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
            operation: ".unsignedSerialized"
        })
    }
    inferType() {
        return this.inferTypes().pop()
    }
    inferTypes() {
        const e = this.gasPrice != null,
            n = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null,
            r = this.accessList != null;
        this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && re(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
            value: this
        }), re(!n || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
            value: this
        }), re(this.type !== 0 || !r, "legacy transaction cannot have accessList", "BAD_DATA", {
            value: this
        });
        const i = [];
        return this.type != null ? i.push(this.type) : n ? i.push(2) : e ? (i.push(1), r || i.push(0)) : r ? (i.push(1), i.push(2)) : (i.push(0), i.push(1), i.push(2)), i.sort(), i
    }
    isLegacy() {
        return this.type === 0
    }
    isBerlin() {
        return this.type === 1
    }
    isLondon() {
        return this.type === 2
    }
    clone() {
        return Wr.from(this)
    }
    toJSON() {
        const e = n => n == null ? null : n.toString();
        return {
            type: this.type,
            to: this.to,
            data: this.data,
            nonce: this.nonce,
            gasLimit: e(this.gasLimit),
            gasPrice: e(this.gasPrice),
            maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
            maxFeePerGas: e(this.maxFeePerGas),
            value: e(this.value),
            chainId: e(this.chainId),
            sig: this.signature ? this.signature.toJSON() : null,
            accessList: this.accessList
        }
    }
    static from(e) {
        if (e == null) return new Wr;
        if (typeof e == "string") {
            const r = qe(e);
            if (r[0] >= 127) return Wr.from(H8(r));
            switch (r[0]) {
                case 1:
                    return Wr.from(j8(r));
                case 2:
                    return Wr.from(z8(r))
            }
            re(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                operation: "from"
            })
        }
        const n = new Wr;
        return e.type != null && (n.type = e.type), e.to != null && (n.to = e.to), e.nonce != null && (n.nonce = e.nonce), e.gasLimit != null && (n.gasLimit = e.gasLimit), e.gasPrice != null && (n.gasPrice = e.gasPrice), e.maxPriorityFeePerGas != null && (n.maxPriorityFeePerGas = e.maxPriorityFeePerGas), e.maxFeePerGas != null && (n.maxFeePerGas = e.maxFeePerGas), e.data != null && (n.data = e.data), e.value != null && (n.value = e.value), e.chainId != null && (n.chainId = e.chainId), e.signature != null && (n.signature = Qt.from(e.signature)), e.accessList != null && (n.accessList = e.accessList), e.hash != null && (W(n.isSigned(), "unsigned transaction cannot define hash", "tx", e), W(n.hash === e.hash, "hash mismatch", "tx", e)), e.from != null && (W(n.isSigned(), "unsigned transaction cannot define from", "tx", e), W(n.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)), n
    }
}
const V8 = new RegExp("^bytes([0-9]+)$"),
    G8 = new RegExp("^(u?int)([0-9]*)$"),
    W8 = new RegExp("^(.*)\\[([0-9]*)\\]$");

function aw(t, e, n) {
    switch (t) {
        case "address":
            return qe(n ? Sr(e, 32) : ct(e));
        case "string":
            return Nr(e);
        case "bytes":
            return qe(e);
        case "bool":
            return e = e ? "0x01" : "0x00", qe(n ? Sr(e, 32) : e)
    }
    let r = t.match(G8);
    if (r) {
        let i = r[1] === "int",
            s = parseInt(r[2] || "256");
        return W((!r[2] || r[2] === String(s)) && s % 8 === 0 && s !== 0 && s <= 256, "invalid number type", "type", t), n && (s = 256), i && (e = yp(e, s)), qe(Sr(_n(e), s / 8))
    }
    if (r = t.match(V8), r) {
        const i = parseInt(r[1]);
        return W(String(i) === r[1] && i !== 0 && i <= 32, "invalid bytes type", "type", t), W(_s(e) === i, `invalid value for ${t}`, "value", e), n ? qe(nb(e, 32)) : e
    }
    if (r = t.match(W8), r && Array.isArray(e)) {
        const i = r[1],
            s = parseInt(r[2] || String(e.length));
        W(s === e.length, `invalid array length for ${t}`, "value", e);
        const o = [];
        return e.forEach(function(a) {
            o.push(aw(i, a, !0))
        }), qe(Ht(o))
    }
    W(!1, "invalid type", "type", t)
}

function Q8(t, e) {
    W(t.length === e.length, "wrong number of values; expected ${ types.length }", "values", e);
    const n = [];
    return t.forEach(function(r, i) {
        n.push(aw(r, e[i]))
    }), De(Ht(n))
}

function Sg(t, e) {
    return Pt(Q8(t, e))
}
const lw = new Uint8Array(32);
lw.fill(0);
const J8 = BigInt(-1),
    cw = BigInt(0),
    uw = BigInt(1),
    K8 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

function Z8(t) {
    const e = qe(t),
        n = e.length % 32;
    return n ? Ht([e, lw.slice(n)]) : De(e)
}
const Y8 = Vi(uw, 32),
    X8 = Vi(cw, 32),
    Ng = {
        name: "string",
        version: "string",
        chainId: "uint256",
        verifyingContract: "address",
        salt: "bytes32"
    },
    Qf = ["name", "version", "chainId", "verifyingContract", "salt"];

function Rg(t) {
    return function(e) {
        return W(typeof e == "string", `invalid domain value for ${JSON.stringify(t)}`, `domain.${t}`, e), e
    }
}
const q8 = {
    name: Rg("name"),
    version: Rg("version"),
    chainId: function(t) {
        const e = Le(t, "domain.chainId");
        return W(e >= 0, "invalid chain ID", "domain.chainId", t), Number.isSafeInteger(e) ? Number(e) : co(e)
    },
    verifyingContract: function(t) {
        try {
            return ct(t).toLowerCase()
        } catch {}
        W(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", t)
    },
    salt: function(t) {
        const e = qe(t, "domain.salt");
        return W(e.length === 32, 'invalid domain value "salt"', "domain.salt", t), De(e)
    }
};

function Jf(t) {
    {
        const e = t.match(/^(u?)int(\d*)$/);
        if (e) {
            const n = e[1] === "",
                r = parseInt(e[2] || "256");
            W(r % 8 === 0 && r !== 0 && r <= 256 && (e[2] == null || e[2] === String(r)), "invalid numeric width", "type", t);
            const i = hs(K8, n ? r - 1 : r),
                s = n ? (i + uw) * J8 : cw;
            return function(o) {
                const a = Le(o, "value");
                return W(a >= s && a <= i, `value out-of-bounds for ${t}`, "value", a), Vi(n ? yp(a, 256) : a, 32)
            }
        }
    } {
        const e = t.match(/^bytes(\d+)$/);
        if (e) {
            const n = parseInt(e[1]);
            return W(n !== 0 && n <= 32 && e[1] === String(n), "invalid bytes width", "type", t),
                function(r) {
                    const i = qe(r);
                    return W(i.length === n, `invalid length for ${t}`, "value", r), Z8(r)
                }
        }
    }
    switch (t) {
        case "address":
            return function(e) {
                return Sr(ct(e), 32)
            };
        case "bool":
            return function(e) {
                return e ? Y8 : X8
            };
        case "bytes":
            return function(e) {
                return Pt(e)
            };
        case "string":
            return function(e) {
                return Rs(e)
            }
    }
    return null
}

function Cg(t, e) {
    return `${t}(${e.map(({name:n,type:r})=>r+" "+n).join(",")})`
}
class Nn {
    primaryType;#
    e;
    get types() {
        return JSON.parse(this.#e)
    }#
    t;#
    n;
    constructor(e) {
        this.#e = JSON.stringify(e), this.#t = new Map, this.#n = new Map;
        const n = new Map,
            r = new Map,
            i = new Map;
        Object.keys(e).forEach(a => {
            n.set(a, new Set), r.set(a, []), i.set(a, new Set)
        });
        for (const a in e) {
            const c = new Set;
            for (const l of e[a]) {
                W(!c.has(l.name), `duplicate variable name ${JSON.stringify(l.name)} in ${JSON.stringify(a)}`, "types", e), c.add(l.name);
                const u = l.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
                W(u !== a, `circular type reference to ${JSON.stringify(u)}`, "types", e), !Jf(u) && (W(r.has(u), `unknown type ${JSON.stringify(u)}`, "types", e), r.get(u).push(a), n.get(a).add(u))
            }
        }
        const s = Array.from(r.keys()).filter(a => r.get(a).length === 0);
        W(s.length !== 0, "missing primary type", "types", e), W(s.length === 1, `ambiguous primary types or unused types: ${s.map(a=>JSON.stringify(a)).join(", ")}`, "types", e), Ue(this, {
            primaryType: s[0]
        });

        function o(a, c) {
            W(!c.has(a), `circular type reference to ${JSON.stringify(a)}`, "types", e), c.add(a);
            for (const l of n.get(a))
                if (r.has(l)) {
                    o(l, c);
                    for (const u of c) i.get(u).add(l)
                }
            c.delete(a)
        }
        o(this.primaryType, new Set);
        for (const [a, c] of i) {
            const l = Array.from(c);
            l.sort(), this.#t.set(a, Cg(a, e[a]) + l.map(u => Cg(u, e[u])).join(""))
        }
    }
    getEncoder(e) {
        let n = this.#n.get(e);
        return n || (n = this.#r(e), this.#n.set(e, n)), n
    }#
    r(e) {
        {
            const i = Jf(e);
            if (i) return i
        }
        const n = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (n) {
            const i = n[1],
                s = this.getEncoder(i);
            return o => {
                W(!n[3] || parseInt(n[3]) === o.length, `array length mismatch; expected length ${parseInt(n[3])}`, "value", o);
                let a = o.map(s);
                return this.#t.has(i) && (a = a.map(Pt)), Pt(Ht(a))
            }
        }
        const r = this.types[e];
        if (r) {
            const i = Rs(this.#t.get(e));
            return s => {
                const o = r.map(({
                    name: a,
                    type: c
                }) => {
                    const l = this.getEncoder(c)(s[a]);
                    return this.#t.has(c) ? Pt(l) : l
                });
                return o.unshift(i), Ht(o)
            }
        }
        W(!1, `unknown type: ${e}`, "type", e)
    }
    encodeType(e) {
        const n = this.#t.get(e);
        return W(n, `unknown type: ${JSON.stringify(e)}`, "name", e), n
    }
    encodeData(e, n) {
        return this.getEncoder(e)(n)
    }
    hashStruct(e, n) {
        return Pt(this.encodeData(e, n))
    }
    encode(e) {
        return this.encodeData(this.primaryType, e)
    }
    hash(e) {
        return this.hashStruct(this.primaryType, e)
    }
    _visit(e, n, r) {
        if (Jf(e)) return r(e, n);
        const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (i) return W(!i[3] || parseInt(i[3]) === n.length, `array length mismatch; expected length ${parseInt(i[3])}`, "value", n), n.map(o => this._visit(i[1], o, r));
        const s = this.types[e];
        if (s) return s.reduce((o, {
            name: a,
            type: c
        }) => (o[a] = this._visit(c, n[a], r), o), {});
        W(!1, `unknown type: ${e}`, "type", e)
    }
    visit(e, n) {
        return this._visit(this.primaryType, e, n)
    }
    static from(e) {
        return new Nn(e)
    }
    static getPrimaryType(e) {
        return Nn.from(e).primaryType
    }
    static hashStruct(e, n, r) {
        return Nn.from(n).hashStruct(e, r)
    }
    static hashDomain(e) {
        const n = [];
        for (const r in e) {
            if (e[r] == null) continue;
            const i = Ng[r];
            W(i, `invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e), n.push({
                name: r,
                type: i
            })
        }
        return n.sort((r, i) => Qf.indexOf(r.name) - Qf.indexOf(i.name)), Nn.hashStruct("EIP712Domain", {
            EIP712Domain: n
        }, e)
    }
    static encode(e, n, r) {
        return Ht(["0x1901", Nn.hashDomain(e), Nn.from(n).hash(r)])
    }
    static hash(e, n, r) {
        return Pt(Nn.encode(e, n, r))
    }
    static async resolveNames(e, n, r, i) {
        e = Object.assign({}, e);
        for (const a in e) e[a] == null && delete e[a];
        const s = {};
        e.verifyingContract && !Ot(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x");
        const o = Nn.from(n);
        o.visit(r, (a, c) => (a === "address" && !Ot(c, 20) && (s[c] = "0x"), c));
        for (const a in s) s[a] = await i(a);
        return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), r = o.visit(r, (a, c) => a === "address" && s[c] ? s[c] : c), {
            domain: e,
            value: r
        }
    }
    static getPayload(e, n, r) {
        Nn.hashDomain(e);
        const i = {},
            s = [];
        Qf.forEach(c => {
            const l = e[c];
            l != null && (i[c] = q8[c](l), s.push({
                name: c,
                type: Ng[c]
            }))
        });
        const o = Nn.from(n),
            a = Object.assign({}, n);
        return W(a.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", n), a.EIP712Domain = s, o.encode(r), {
            types: a,
            domain: i,
            primaryType: o.primaryType,
            message: o.visit(r, (c, l) => {
                if (c.match(/^bytes(\d*)/)) return De(qe(l));
                if (c.match(/^u?int/)) return Le(l).toString();
                switch (c) {
                    case "address":
                        return l.toLowerCase();
                    case "bool":
                        return !!l;
                    case "string":
                        return W(typeof l == "string", "invalid string", "value", l), l
                }
                W(!1, "unsupported type", "type", c)
            })
        }
    }
}

function mn(t) {
    const e = new Set;
    return t.forEach(n => e.add(n)), Object.freeze(e)
}
const $8 = "external public payable",
    e5 = mn($8.split(" ")),
    fw = "constant external internal payable private public pure view",
    t5 = mn(fw.split(" ")),
    dw = "constructor error event fallback function receive struct",
    hw = mn(dw.split(" ")),
    pw = "calldata memory storage payable indexed",
    n5 = mn(pw.split(" ")),
    r5 = "tuple returns",
    i5 = [dw, pw, r5, fw].join(" "),
    s5 = mn(i5.split(" ")),
    o5 = {
        "(": "OPEN_PAREN",
        ")": "CLOSE_PAREN",
        "[": "OPEN_BRACKET",
        "]": "CLOSE_BRACKET",
        ",": "COMMA",
        "@": "AT"
    },
    a5 = new RegExp("^(\\s*)"),
    l5 = new RegExp("^([0-9]+)"),
    c5 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
    mw = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
    gw = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
class Xn {#
    e;#
    t;
    get offset() {
        return this.#e
    }
    get length() {
        return this.#t.length - this.#e
    }
    constructor(e) {
        this.#e = 0, this.#t = e.slice()
    }
    clone() {
        return new Xn(this.#t)
    }
    reset() {
        this.#e = 0
    }#
    n(e = 0, n = 0) {
        return new Xn(this.#t.slice(e, n).map(r => Object.freeze(Object.assign({}, r, {
            match: r.match - e,
            linkBack: r.linkBack - e,
            linkNext: r.linkNext - e
        }))))
    }
    popKeyword(e) {
        const n = this.peek();
        if (n.type !== "KEYWORD" || !e.has(n.text)) throw new Error(`expected keyword ${n.text}`);
        return this.pop().text
    }
    popType(e) {
        if (this.peek().type !== e) throw new Error(`expected ${e}; got ${JSON.stringify(this.peek())}`);
        return this.pop().text
    }
    popParen() {
        const e = this.peek();
        if (e.type !== "OPEN_PAREN") throw new Error("bad start");
        const n = this.#n(this.#e + 1, e.match + 1);
        return this.#e = e.match + 1, n
    }
    popParams() {
        const e = this.peek();
        if (e.type !== "OPEN_PAREN") throw new Error("bad start");
        const n = [];
        for (; this.#e < e.match - 1;) {
            const r = this.peek().linkNext;
            n.push(this.#n(this.#e + 1, r)), this.#e = r
        }
        return this.#e = e.match + 1, n
    }
    peek() {
        if (this.#e >= this.#t.length) throw new Error("out-of-bounds");
        return this.#t[this.#e]
    }
    peekKeyword(e) {
        const n = this.peekType("KEYWORD");
        return n != null && e.has(n) ? n : null
    }
    peekType(e) {
        if (this.length === 0) return null;
        const n = this.peek();
        return n.type === e ? n.text : null
    }
    pop() {
        const e = this.peek();
        return this.#e++, e
    }
    toString() {
        const e = [];
        for (let n = this.#e; n < this.#t.length; n++) {
            const r = this.#t[n];
            e.push(`${r.type}:${r.text}`)
        }
        return `<TokenString ${e.join(" ")}>`
    }
}

function Ji(t) {
    const e = [],
        n = o => {
            const a = s < t.length ? JSON.stringify(t[s]) : "$EOI";
            throw new Error(`invalid token ${a} at ${s}: ${o}`)
        };
    let r = [],
        i = [],
        s = 0;
    for (; s < t.length;) {
        let o = t.substring(s),
            a = o.match(a5);
        a && (s += a[1].length, o = t.substring(s));
        const c = {
            depth: r.length,
            linkBack: -1,
            linkNext: -1,
            match: -1,
            type: "",
            text: "",
            offset: s,
            value: -1
        };
        e.push(c);
        let l = o5[o[0]] || "";
        if (l) {
            if (c.type = l, c.text = o[0], s++, l === "OPEN_PAREN") r.push(e.length - 1), i.push(e.length - 1);
            else if (l == "CLOSE_PAREN") r.length === 0 && n("no matching open bracket"), c.match = r.pop(), e[c.match].match = e.length - 1, c.depth--, c.linkBack = i.pop(), e[c.linkBack].linkNext = e.length - 1;
            else if (l === "COMMA") c.linkBack = i.pop(), e[c.linkBack].linkNext = e.length - 1, i.push(e.length - 1);
            else if (l === "OPEN_BRACKET") c.type = "BRACKET";
            else if (l === "CLOSE_BRACKET") {
                let u = e.pop().text;
                if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
                    const f = e.pop().text;
                    u = f + u, e[e.length - 1].value = $e(f)
                }
                if (e.length === 0 || e[e.length - 1].type !== "BRACKET") throw new Error("missing opening bracket");
                e[e.length - 1].text += u
            }
            continue
        }
        if (a = o.match(c5), a) {
            if (c.text = a[1], s += c.text.length, s5.has(c.text)) {
                c.type = "KEYWORD";
                continue
            }
            if (c.text.match(gw)) {
                c.type = "TYPE";
                continue
            }
            c.type = "ID";
            continue
        }
        if (a = o.match(l5), a) {
            c.text = a[1], c.type = "NUMBER", s += c.text.length;
            continue
        }
        throw new Error(`unexpected token ${JSON.stringify(o[0])} at position ${s}`)
    }
    return new Xn(e.map(o => Object.freeze(o)))
}

function Og(t, e) {
    let n = [];
    for (const r in e.keys()) t.has(r) && n.push(r);
    if (n.length > 1) throw new Error(`conflicting types: ${n.join(", ")}`)
}

function Qu(t, e) {
    if (e.peekKeyword(hw)) {
        const n = e.pop().text;
        if (n !== t) throw new Error(`expected ${t}, got ${n}`)
    }
    return e.popType("ID")
}

function si(t, e) {
    const n = new Set;
    for (;;) {
        const r = t.peekType("KEYWORD");
        if (r == null || e && !e.has(r)) break;
        if (t.pop(), n.has(r)) throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
        n.add(r)
    }
    return Object.freeze(n)
}

function yw(t) {
    let e = si(t, t5);
    return Og(e, mn("constant payable nonpayable".split(" "))), Og(e, mn("pure view payable nonpayable".split(" "))), e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable"
}

function ni(t, e) {
    return t.popParams().map(n => vt.from(n, e))
}

function vw(t) {
    if (t.peekType("AT")) {
        if (t.pop(), t.peekType("NUMBER")) return Le(t.pop().text);
        throw new Error("invalid gas")
    }
    return null
}

function Cs(t) {
    if (t.length) throw new Error(`unexpected tokens: ${t.toString()}`)
}
const u5 = new RegExp(/^(.*)\[([0-9]*)\]$/);

function Tg(t) {
    const e = t.match(gw);
    if (W(e, "invalid type", "type", t), t === "uint") return "uint256";
    if (t === "int") return "int256";
    if (e[2]) {
        const n = parseInt(e[2]);
        W(n !== 0 && n <= 32, "invalid bytes length", "type", t)
    } else if (e[3]) {
        const n = parseInt(e[3]);
        W(n !== 0 && n <= 256 && n % 8 === 0, "invalid numeric width", "type", t)
    }
    return t
}
const Ct = {},
    Sn = Symbol.for("_ethers_internal"),
    Bg = "_ParamTypeInternal",
    Ig = "_ErrorInternal",
    Dg = "_EventInternal",
    Lg = "_ConstructorInternal",
    Mg = "_FallbackInternal",
    Fg = "_FunctionInternal",
    Ug = "_StructInternal";
class vt {
    name;
    type;
    baseType;
    indexed;
    components;
    arrayLength;
    arrayChildren;
    constructor(e, n, r, i, s, o, a, c) {
        if (wl(e, Ct, "ParamType"), Object.defineProperty(this, Sn, {
                value: Bg
            }), o && (o = Object.freeze(o.slice())), i === "array") {
            if (a == null || c == null) throw new Error("")
        } else if (a != null || c != null) throw new Error("");
        if (i === "tuple") {
            if (o == null) throw new Error("")
        } else if (o != null) throw new Error("");
        Ue(this, {
            name: n,
            type: r,
            baseType: i,
            indexed: s,
            components: o,
            arrayLength: a,
            arrayChildren: c
        })
    }
    format(e) {
        if (e == null && (e = "sighash"), e === "json") {
            const r = this.name || "";
            if (this.isArray()) {
                const s = JSON.parse(this.arrayChildren.format("json"));
                return s.name = r, s.type += `[${this.arrayLength<0?"":String(this.arrayLength)}]`, JSON.stringify(s)
            }
            const i = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: r
            };
            return typeof this.indexed == "boolean" && (i.indexed = this.indexed), this.isTuple() && (i.components = this.components.map(s => JSON.parse(s.format(e)))), JSON.stringify(i)
        }
        let n = "";
        return this.isArray() ? (n += this.arrayChildren.format(e), n += `[${this.arrayLength<0?"":String(this.arrayLength)}]`) : this.isTuple() ? (e !== "sighash" && (n += this.type), n += "(" + this.components.map(r => r.format(e)).join(e === "full" ? ", " : ",") + ")") : n += this.type, e !== "sighash" && (this.indexed === !0 && (n += " indexed"), e === "full" && this.name && (n += " " + this.name)), n
    }
    isArray() {
        return this.baseType === "array"
    }
    isTuple() {
        return this.baseType === "tuple"
    }
    isIndexable() {
        return this.indexed != null
    }
    walk(e, n) {
        if (this.isArray()) {
            if (!Array.isArray(e)) throw new Error("invalid array value");
            if (this.arrayLength !== -1 && e.length !== this.arrayLength) throw new Error("array is wrong length");
            const r = this;
            return e.map(i => r.arrayChildren.walk(i, n))
        }
        if (this.isTuple()) {
            if (!Array.isArray(e)) throw new Error("invalid tuple value");
            if (e.length !== this.components.length) throw new Error("array is wrong length");
            const r = this;
            return e.map((i, s) => r.components[s].walk(i, n))
        }
        return n(this.type, e)
    }#
    e(e, n, r, i) {
        if (this.isArray()) {
            if (!Array.isArray(n)) throw new Error("invalid array value");
            if (this.arrayLength !== -1 && n.length !== this.arrayLength) throw new Error("array is wrong length");
            const o = this.arrayChildren,
                a = n.slice();
            a.forEach((c, l) => {
                o.#e(e, c, r, u => {
                    a[l] = u
                })
            }), i(a);
            return
        }
        if (this.isTuple()) {
            const o = this.components;
            let a;
            if (Array.isArray(n)) a = n.slice();
            else {
                if (n == null || typeof n != "object") throw new Error("invalid tuple value");
                a = o.map(c => {
                    if (!c.name) throw new Error("cannot use object value with unnamed components");
                    if (!(c.name in n)) throw new Error(`missing value for component ${c.name}`);
                    return n[c.name]
                })
            }
            if (a.length !== this.components.length) throw new Error("array is wrong length");
            a.forEach((c, l) => {
                o[l].#e(e, c, r, u => {
                    a[l] = u
                })
            }), i(a);
            return
        }
        const s = r(this.type, n);
        s.then ? e.push(async function() {
            i(await s)
        }()) : i(s)
    }
    async walkAsync(e, n) {
        const r = [],
            i = [e];
        return this.#e(r, e, n, s => {
            i[0] = s
        }), r.length && await Promise.all(r), i[0]
    }
    static from(e, n) {
        if (vt.isParamType(e)) return e;
        if (typeof e == "string") try {
            return vt.from(Ji(e), n)
        } catch {
            W(!1, "invalid param type", "obj", e)
        } else if (e instanceof Xn) {
            let a = "",
                c = "",
                l = null;
            si(e, mn(["tuple"])).has("tuple") || e.peekType("OPEN_PAREN") ? (c = "tuple", l = e.popParams().map(g => vt.from(g)), a = `tuple(${l.map(g=>g.format()).join(",")})`) : (a = Tg(e.popType("TYPE")), c = a);
            let u = null,
                f = null;
            for (; e.length && e.peekType("BRACKET");) {
                const g = e.pop();
                u = new vt(Ct, "", a, c, null, l, f, u), f = g.value, a += g.text, c = "array", l = null
            }
            let d = null;
            if (si(e, n5).has("indexed")) {
                if (!n) throw new Error("");
                d = !0
            }
            const p = e.peekType("ID") ? e.pop().text : "";
            if (e.length) throw new Error("leftover tokens");
            return new vt(Ct, p, a, c, d, l, f, u)
        }
        const r = e.name;
        W(!r || typeof r == "string" && r.match(mw), "invalid name", "obj.name", r);
        let i = e.indexed;
        i != null && (W(n, "parameter cannot be indexed", "obj.indexed", e.indexed), i = !!i);
        let s = e.type,
            o = s.match(u5);
        if (o) {
            const a = parseInt(o[2] || "-1"),
                c = vt.from({
                    type: o[1],
                    components: e.components
                });
            return new vt(Ct, r || "", s, "array", i, null, a, c)
        }
        if (s === "tuple" || s.startsWith("tuple(") || s.startsWith("(")) {
            const a = e.components != null ? e.components.map(l => vt.from(l)) : null;
            return new vt(Ct, r || "", s, "tuple", i, a, null, null)
        }
        return s = Tg(e.type), new vt(Ct, r || "", s, s, i, null, null, null)
    }
    static isParamType(e) {
        return e && e[Sn] === Bg
    }
}
class Os {
    type;
    inputs;
    constructor(e, n, r) {
        wl(e, Ct, "Fragment"), r = Object.freeze(r.slice()), Ue(this, {
            type: n,
            inputs: r
        })
    }
    static from(e) {
        if (typeof e == "string") {
            try {
                Os.from(JSON.parse(e))
            } catch {}
            return Os.from(Ji(e))
        }
        if (e instanceof Xn) switch (e.peekKeyword(hw)) {
            case "constructor":
                return qr.from(e);
            case "error":
                return An.from(e);
            case "event":
                return wr.from(e);
            case "fallback":
            case "receive":
                return Qr.from(e);
            case "function":
                return xr.from(e);
            case "struct":
                return Ps.from(e)
        } else if (typeof e == "object") {
            switch (e.type) {
                case "constructor":
                    return qr.from(e);
                case "error":
                    return An.from(e);
                case "event":
                    return wr.from(e);
                case "fallback":
                case "receive":
                    return Qr.from(e);
                case "function":
                    return xr.from(e);
                case "struct":
                    return Ps.from(e)
            }
            re(!1, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
                operation: "Fragment.from"
            })
        }
        W(!1, "unsupported frgament object", "obj", e)
    }
    static isConstructor(e) {
        return qr.isFragment(e)
    }
    static isError(e) {
        return An.isFragment(e)
    }
    static isEvent(e) {
        return wr.isFragment(e)
    }
    static isFunction(e) {
        return xr.isFragment(e)
    }
    static isStruct(e) {
        return Ps.isFragment(e)
    }
}
class Ju extends Os {
    name;
    constructor(e, n, r, i) {
        super(e, n, i), W(typeof r == "string" && r.match(mw), "invalid identifier", "name", r), i = Object.freeze(i.slice()), Ue(this, {
            name: r
        })
    }
}

function Ya(t, e) {
    return "(" + e.map(n => n.format(t)).join(t === "full" ? ", " : ",") + ")"
}
class An extends Ju {
    constructor(e, n, r) {
        super(e, "error", n, r), Object.defineProperty(this, Sn, {
            value: Ig
        })
    }
    get selector() {
        return Rs(this.format("sighash")).substring(0, 10)
    }
    format(e) {
        if (e == null && (e = "sighash"), e === "json") return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map(r => JSON.parse(r.format(e)))
        });
        const n = [];
        return e !== "sighash" && n.push("error"), n.push(this.name + Ya(e, this.inputs)), n.join(" ")
    }
    static from(e) {
        if (An.isFragment(e)) return e;
        if (typeof e == "string") return An.from(Ji(e));
        if (e instanceof Xn) {
            const n = Qu("error", e),
                r = ni(e);
            return Cs(e), new An(Ct, n, r)
        }
        return new An(Ct, e.name, e.inputs ? e.inputs.map(vt.from) : [])
    }
    static isFragment(e) {
        return e && e[Sn] === Ig
    }
}
class wr extends Ju {
    anonymous;
    constructor(e, n, r, i) {
        super(e, "event", n, r), Object.defineProperty(this, Sn, {
            value: Dg
        }), Ue(this, {
            anonymous: i
        })
    }
    get topicHash() {
        return Rs(this.format("sighash"))
    }
    format(e) {
        if (e == null && (e = "sighash"), e === "json") return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map(r => JSON.parse(r.format(e)))
        });
        const n = [];
        return e !== "sighash" && n.push("event"), n.push(this.name + Ya(e, this.inputs)), e !== "sighash" && this.anonymous && n.push("anonymous"), n.join(" ")
    }
    static getTopicHash(e, n) {
        return n = (n || []).map(i => vt.from(i)), new wr(Ct, e, n, !1).topicHash
    }
    static from(e) {
        if (wr.isFragment(e)) return e;
        if (typeof e == "string") try {
            return wr.from(Ji(e))
        } catch {
            W(!1, "invalid event fragment", "obj", e)
        } else if (e instanceof Xn) {
            const n = Qu("event", e),
                r = ni(e, !0),
                i = !!si(e, mn(["anonymous"])).has("anonymous");
            return Cs(e), new wr(Ct, n, r, i)
        }
        return new wr(Ct, e.name, e.inputs ? e.inputs.map(n => vt.from(n, !0)) : [], !!e.anonymous)
    }
    static isFragment(e) {
        return e && e[Sn] === Dg
    }
}
class qr extends Os {
    payable;
    gas;
    constructor(e, n, r, i, s) {
        super(e, n, r), Object.defineProperty(this, Sn, {
            value: Lg
        }), Ue(this, {
            payable: i,
            gas: s
        })
    }
    format(e) {
        if (re(e != null && e !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
                operation: "format(sighash)"
            }), e === "json") return JSON.stringify({
            type: "constructor",
            stateMutability: this.payable ? "payable" : "undefined",
            payable: this.payable,
            gas: this.gas != null ? this.gas : void 0,
            inputs: this.inputs.map(r => JSON.parse(r.format(e)))
        });
        const n = [`constructor${Ya(e,this.inputs)}`];
        return this.payable && n.push("payable"), this.gas != null && n.push(`@${this.gas.toString()}`), n.join(" ")
    }
    static from(e) {
        if (qr.isFragment(e)) return e;
        if (typeof e == "string") try {
            return qr.from(Ji(e))
        } catch {
            W(!1, "invalid constuctor fragment", "obj", e)
        } else if (e instanceof Xn) {
            si(e, mn(["constructor"]));
            const n = ni(e),
                r = !!si(e, e5).has("payable"),
                i = vw(e);
            return Cs(e), new qr(Ct, "constructor", n, r, i)
        }
        return new qr(Ct, "constructor", e.inputs ? e.inputs.map(vt.from) : [], !!e.payable, e.gas != null ? e.gas : null)
    }
    static isFragment(e) {
        return e && e[Sn] === Lg
    }
}
class Qr extends Os {
    payable;
    constructor(e, n, r) {
        super(e, "fallback", n), Object.defineProperty(this, Sn, {
            value: Mg
        }), Ue(this, {
            payable: r
        })
    }
    format(e) {
        const n = this.inputs.length === 0 ? "receive" : "fallback";
        if (e === "json") {
            const r = this.payable ? "payable" : "nonpayable";
            return JSON.stringify({
                type: n,
                stateMutability: r
            })
        }
        return `${n}()${this.payable?" payable":""}`
    }
    static from(e) {
        if (Qr.isFragment(e)) return e;
        if (typeof e == "string") try {
            return Qr.from(Ji(e))
        } catch {
            W(!1, "invalid fallback fragment", "obj", e)
        } else if (e instanceof Xn) {
            const n = e.toString(),
                r = e.peekKeyword(mn(["fallback", "receive"]));
            if (W(r, "type must be fallback or receive", "obj", n), e.popKeyword(mn(["fallback", "receive"])) === "receive") {
                const a = ni(e);
                return W(a.length === 0, "receive cannot have arguments", "obj.inputs", a), si(e, mn(["payable"])), Cs(e), new Qr(Ct, [], !0)
            }
            let s = ni(e);
            s.length ? W(s.length === 1 && s[0].type === "bytes", "invalid fallback inputs", "obj.inputs", s.map(a => a.format("minimal")).join(", ")) : s = [vt.from("bytes")];
            const o = yw(e);
            if (W(o === "nonpayable" || o === "payable", "fallback cannot be constants", "obj.stateMutability", o), si(e, mn(["returns"])).has("returns")) {
                const a = ni(e);
                W(a.length === 1 && a[0].type === "bytes", "invalid fallback outputs", "obj.outputs", a.map(c => c.format("minimal")).join(", "))
            }
            return Cs(e), new Qr(Ct, s, o === "payable")
        }
        if (e.type === "receive") return new Qr(Ct, [], !0);
        if (e.type === "fallback") {
            const n = [vt.from("bytes")],
                r = e.stateMutability === "payable";
            return new Qr(Ct, n, r)
        }
        W(!1, "invalid fallback description", "obj", e)
    }
    static isFragment(e) {
        return e && e[Sn] === Mg
    }
}
class xr extends Ju {
    constant;
    outputs;
    stateMutability;
    payable;
    gas;
    constructor(e, n, r, i, s, o) {
        super(e, "function", n, i), Object.defineProperty(this, Sn, {
            value: Fg
        }), s = Object.freeze(s.slice()), Ue(this, {
            constant: r === "view" || r === "pure",
            gas: o,
            outputs: s,
            payable: r === "payable",
            stateMutability: r
        })
    }
    get selector() {
        return Rs(this.format("sighash")).substring(0, 10)
    }
    format(e) {
        if (e == null && (e = "sighash"), e === "json") return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas != null ? this.gas : void 0,
            inputs: this.inputs.map(r => JSON.parse(r.format(e))),
            outputs: this.outputs.map(r => JSON.parse(r.format(e)))
        });
        const n = [];
        return e !== "sighash" && n.push("function"), n.push(this.name + Ya(e, this.inputs)), e !== "sighash" && (this.stateMutability !== "nonpayable" && n.push(this.stateMutability), this.outputs && this.outputs.length && (n.push("returns"), n.push(Ya(e, this.outputs))), this.gas != null && n.push(`@${this.gas.toString()}`)), n.join(" ")
    }
    static getSelector(e, n) {
        return n = (n || []).map(i => vt.from(i)), new xr(Ct, e, "view", n, [], null).selector
    }
    static from(e) {
        if (xr.isFragment(e)) return e;
        if (typeof e == "string") try {
            return xr.from(Ji(e))
        } catch {
            W(!1, "invalid function fragment", "obj", e)
        } else if (e instanceof Xn) {
            const r = Qu("function", e),
                i = ni(e),
                s = yw(e);
            let o = [];
            si(e, mn(["returns"])).has("returns") && (o = ni(e));
            const a = vw(e);
            return Cs(e), new xr(Ct, r, s, i, o, a)
        }
        let n = e.stateMutability;
        return n == null && (n = "payable", typeof e.constant == "boolean" ? (n = "view", e.constant || (n = "payable", typeof e.payable == "boolean" && !e.payable && (n = "nonpayable"))) : typeof e.payable == "boolean" && !e.payable && (n = "nonpayable")), new xr(Ct, e.name, n, e.inputs ? e.inputs.map(vt.from) : [], e.outputs ? e.outputs.map(vt.from) : [], e.gas != null ? e.gas : null)
    }
    static isFragment(e) {
        return e && e[Sn] === Fg
    }
}
class Ps extends Ju {
    constructor(e, n, r) {
        super(e, "struct", n, r), Object.defineProperty(this, Sn, {
            value: Ug
        })
    }
    format() {
        throw new Error("@TODO")
    }
    static from(e) {
        if (typeof e == "string") try {
            return Ps.from(Ji(e))
        } catch {
            W(!1, "invalid struct fragment", "obj", e)
        } else if (e instanceof Xn) {
            const n = Qu("struct", e),
                r = ni(e);
            return Cs(e), new Ps(Ct, n, r)
        }
        return new Ps(Ct, e.name, e.inputs ? e.inputs.map(vt.from) : [])
    }
    static isFragment(e) {
        return e && e[Sn] === Ug
    }
}
const dr = new Map;
dr.set(0, "GENERIC_PANIC");
dr.set(1, "ASSERT_FALSE");
dr.set(17, "OVERFLOW");
dr.set(18, "DIVIDE_BY_ZERO");
dr.set(33, "ENUM_RANGE_ERROR");
dr.set(34, "BAD_STORAGE_DATA");
dr.set(49, "STACK_UNDERFLOW");
dr.set(50, "ARRAY_RANGE_ERROR");
dr.set(65, "OUT_OF_MEMORY");
dr.set(81, "UNINITIALIZED_FUNCTION_CALL");
const f5 = new RegExp(/^bytes([0-9]*)$/),
    d5 = new RegExp(/^(u?int)([0-9]*)$/);
let Kf = null;

function h5(t, e, n, r) {
    let i = "missing revert data",
        s = null;
    const o = null;
    let a = null;
    if (n) {
        i = "execution reverted";
        const l = qe(n);
        if (n = De(n), l.length === 0) i += " (no data present; likely require(false) occurred", s = "require(false)";
        else if (l.length % 32 !== 4) i += " (could not decode reason; invalid data length)";
        else if (De(l.slice(0, 4)) === "0x08c379a0") try {
            s = r.decode(["string"], l.slice(4))[0], a = {
                signature: "Error(string)",
                name: "Error",
                args: [s]
            }, i += `: ${JSON.stringify(s)}`
        } catch {
            i += " (could not decode reason; invalid string data)"
        } else if (De(l.slice(0, 4)) === "0x4e487b71") try {
            const u = Number(r.decode(["uint256"], l.slice(4))[0]);
            a = {
                signature: "Panic(uint256)",
                name: "Panic",
                args: [u]
            }, s = `Panic due to ${dr.get(u)||"UNKNOWN"}(${u})`, i += `: ${s}`
        } catch {
            i += " (could not decode panic code)"
        } else i += " (unknown custom error)"
    }
    const c = {
        to: e.to ? ct(e.to) : null,
        data: e.data || "0x"
    };
    return e.from && (c.from = ct(e.from)), Wt(i, "CALL_EXCEPTION", {
        action: t,
        data: n,
        reason: s,
        transaction: c,
        invocation: o,
        revert: a
    })
}
class Mo {#
    e(e) {
        if (e.isArray()) return new F6(this.#e(e.arrayChildren), e.arrayLength, e.name);
        if (e.isTuple()) return new ac(e.components.map(r => this.#e(r)), e.name);
        switch (e.baseType) {
            case "address":
                return new L6(e.name);
            case "bool":
                return new U6(e.name);
            case "string":
                return new K6(e.name);
            case "bytes":
                return new H6(e.name);
            case "":
                return new V6(e.name)
        }
        let n = e.type.match(d5);
        if (n) {
            let r = parseInt(n[2] || "256");
            return W(r !== 0 && r <= 256 && r % 8 === 0, "invalid " + n[1] + " bit length", "param", e), new J6(r / 8, n[1] === "int", e.name)
        }
        if (n = e.type.match(f5), n) {
            let r = parseInt(n[1]);
            return W(r !== 0 && r <= 32, "invalid bytes length", "param", e), new z6(r, e.name)
        }
        W(!1, "invalid type", "type", e.type)
    }
    getDefaultValue(e) {
        const n = e.map(i => this.#e(vt.from(i)));
        return new ac(n, "_").defaultValue()
    }
    encode(e, n) {
        $v(n.length, e.length, "types/values length mismatch");
        const r = e.map(o => this.#e(vt.from(o))),
            i = new ac(r, "_"),
            s = new Kd;
        return i.encode(s, n), s.data
    }
    decode(e, n, r) {
        const i = e.map(o => this.#e(vt.from(o)));
        return new ac(i, "_").decode(new wp(n, r))
    }
    static defaultAbiCoder() {
        return Kf == null && (Kf = new Mo), Kf
    }
    static getBuiltinCallException(e, n, r) {
        return h5(e, n, r, Mo.defaultAbiCoder())
    }
}
class p5 {
    fragment;
    name;
    signature;
    topic;
    args;
    constructor(e, n, r) {
        const i = e.name,
            s = e.format();
        Ue(this, {
            fragment: e,
            name: i,
            signature: s,
            topic: n,
            args: r
        })
    }
}
class m5 {
    fragment;
    name;
    args;
    signature;
    selector;
    value;
    constructor(e, n, r, i) {
        const s = e.name,
            o = e.format();
        Ue(this, {
            fragment: e,
            name: s,
            args: r,
            signature: o,
            selector: n,
            value: i
        })
    }
}
class g5 {
    fragment;
    name;
    args;
    signature;
    selector;
    constructor(e, n, r) {
        const i = e.name,
            s = e.format();
        Ue(this, {
            fragment: e,
            name: i,
            args: r,
            signature: s,
            selector: n
        })
    }
}
class Hg {
    hash;
    _isIndexed;
    static isIndexed(e) {
        return !!(e && e._isIndexed)
    }
    constructor(e) {
        Ue(this, {
            hash: e,
            _isIndexed: !0
        })
    }
}
const zg = {
        0: "generic panic",
        1: "assert(false)",
        17: "arithmetic overflow",
        18: "division or modulo by zero",
        33: "enum overflow",
        34: "invalid encoded storage byte array accessed",
        49: "out-of-bounds array access; popping on an empty array",
        50: "out-of-bounds access of an array or bytesN",
        65: "out of memory",
        81: "uninitialized function"
    },
    jg = {
        "0x08c379a0": {
            signature: "Error(string)",
            name: "Error",
            inputs: ["string"],
            reason: t => `reverted with reason string ${JSON.stringify(t)}`
        },
        "0x4e487b71": {
            signature: "Panic(uint256)",
            name: "Panic",
            inputs: ["uint256"],
            reason: t => {
                let e = "unknown panic code";
                return t >= 0 && t <= 255 && zg[t.toString()] && (e = zg[t.toString()]), `reverted with panic code 0x${t.toString(16)} (${e})`
            }
        }
    };
class ho {
    fragments;
    deploy;
    fallback;
    receive;#
    e;#
    t;#
    n;#
    r;
    constructor(e) {
        let n = [];
        typeof e == "string" ? n = JSON.parse(e) : n = e, this.#n = new Map, this.#e = new Map, this.#t = new Map;
        const r = [];
        for (const o of n) try {
            r.push(Os.from(o))
        } catch (a) {
            console.log("EE", a)
        }
        Ue(this, {
            fragments: Object.freeze(r)
        });
        let i = null,
            s = !1;
        this.#r = this.getAbiCoder(), this.fragments.forEach((o, a) => {
            let c;
            switch (o.type) {
                case "constructor":
                    if (this.deploy) {
                        console.log("duplicate definition - constructor");
                        return
                    }
                    Ue(this, {
                        deploy: o
                    });
                    return;
                case "fallback":
                    o.inputs.length === 0 ? s = !0 : (W(!i || o.payable !== i.payable, "conflicting fallback fragments", `fragments[${a}]`, o), i = o, s = i.payable);
                    return;
                case "function":
                    c = this.#n;
                    break;
                case "event":
                    c = this.#t;
                    break;
                case "error":
                    c = this.#e;
                    break;
                default:
                    return
            }
            const l = o.format();
            c.has(l) || c.set(l, o)
        }), this.deploy || Ue(this, {
            deploy: qr.from("constructor()")
        }), Ue(this, {
            fallback: i,
            receive: s
        })
    }
    format(e) {
        const n = e ? "minimal" : "full";
        return this.fragments.map(i => i.format(n))
    }
    formatJson() {
        const e = this.fragments.map(n => n.format("json"));
        return JSON.stringify(e.map(n => JSON.parse(n)))
    }
    getAbiCoder() {
        return Mo.defaultAbiCoder()
    }#
    i(e, n, r) {
        if (Ot(e)) {
            const s = e.toLowerCase();
            for (const o of this.#n.values())
                if (s === o.selector) return o;
            return null
        }
        if (e.indexOf("(") === -1) {
            const s = [];
            for (const [o, a] of this.#n) o.split("(")[0] === e && s.push(a);
            if (n) {
                const o = n.length > 0 ? n[n.length - 1] : null;
                let a = n.length,
                    c = !0;
                Dt.isTyped(o) && o.type === "overrides" && (c = !1, a--);
                for (let l = s.length - 1; l >= 0; l--) {
                    const u = s[l].inputs.length;
                    u !== a && (!c || u !== a - 1) && s.splice(l, 1)
                }
                for (let l = s.length - 1; l >= 0; l--) {
                    const u = s[l].inputs;
                    for (let f = 0; f < n.length; f++)
                        if (Dt.isTyped(n[f])) {
                            if (f >= u.length) {
                                if (n[f].type === "overrides") continue;
                                s.splice(l, 1);
                                break
                            }
                            if (n[f].type !== u[f].baseType) {
                                s.splice(l, 1);
                                break
                            }
                        }
                }
            }
            if (s.length === 1 && n && n.length !== s[0].inputs.length) {
                const o = n[n.length - 1];
                (o == null || Array.isArray(o) || typeof o != "object") && s.splice(0, 1)
            }
            if (s.length === 0) return null;
            if (s.length > 1 && r) {
                const o = s.map(a => JSON.stringify(a.format())).join(", ");
                W(!1, `ambiguous function description (i.e. matches ${o})`, "key", e)
            }
            return s[0]
        }
        const i = this.#n.get(xr.from(e).format());
        return i || null
    }
    getFunctionName(e) {
        const n = this.#i(e, null, !1);
        return W(n, "no matching function", "key", e), n.name
    }
    hasFunction(e) {
        return !!this.#i(e, null, !1)
    }
    getFunction(e, n) {
        return this.#i(e, n || null, !0)
    }
    forEachFunction(e) {
        const n = Array.from(this.#n.keys());
        n.sort((r, i) => r.localeCompare(i));
        for (let r = 0; r < n.length; r++) {
            const i = n[r];
            e(this.#n.get(i), r)
        }
    }#
    s(e, n, r) {
        if (Ot(e)) {
            const s = e.toLowerCase();
            for (const o of this.#t.values())
                if (s === o.topicHash) return o;
            return null
        }
        if (e.indexOf("(") === -1) {
            const s = [];
            for (const [o, a] of this.#t) o.split("(")[0] === e && s.push(a);
            if (n) {
                for (let o = s.length - 1; o >= 0; o--) s[o].inputs.length < n.length && s.splice(o, 1);
                for (let o = s.length - 1; o >= 0; o--) {
                    const a = s[o].inputs;
                    for (let c = 0; c < n.length; c++)
                        if (Dt.isTyped(n[c]) && n[c].type !== a[c].baseType) {
                            s.splice(o, 1);
                            break
                        }
                }
            }
            if (s.length === 0) return null;
            if (s.length > 1 && r) {
                const o = s.map(a => JSON.stringify(a.format())).join(", ");
                W(!1, `ambiguous event description (i.e. matches ${o})`, "key", e)
            }
            return s[0]
        }
        const i = this.#t.get(wr.from(e).format());
        return i || null
    }
    getEventName(e) {
        const n = this.#s(e, null, !1);
        return W(n, "no matching event", "key", e), n.name
    }
    hasEvent(e) {
        return !!this.#s(e, null, !1)
    }
    getEvent(e, n) {
        return this.#s(e, n || null, !0)
    }
    forEachEvent(e) {
        const n = Array.from(this.#t.keys());
        n.sort((r, i) => r.localeCompare(i));
        for (let r = 0; r < n.length; r++) {
            const i = n[r];
            e(this.#t.get(i), r)
        }
    }
    getError(e, n) {
        if (Ot(e)) {
            const i = e.toLowerCase();
            if (jg[i]) return An.from(jg[i].signature);
            for (const s of this.#e.values())
                if (i === s.selector) return s;
            return null
        }
        if (e.indexOf("(") === -1) {
            const i = [];
            for (const [s, o] of this.#e) s.split("(")[0] === e && i.push(o);
            if (i.length === 0) return e === "Error" ? An.from("error Error(string)") : e === "Panic" ? An.from("error Panic(uint256)") : null;
            if (i.length > 1) {
                const s = i.map(o => JSON.stringify(o.format())).join(", ");
                W(!1, `ambiguous error description (i.e. ${s})`, "name", e)
            }
            return i[0]
        }
        if (e = An.from(e).format(), e === "Error(string)") return An.from("error Error(string)");
        if (e === "Panic(uint256)") return An.from("error Panic(uint256)");
        const r = this.#e.get(e);
        return r || null
    }
    forEachError(e) {
        const n = Array.from(this.#e.keys());
        n.sort((r, i) => r.localeCompare(i));
        for (let r = 0; r < n.length; r++) {
            const i = n[r];
            e(this.#e.get(i), r)
        }
    }
    _decodeParams(e, n) {
        return this.#r.decode(e, n)
    }
    _encodeParams(e, n) {
        return this.#r.encode(e, n)
    }
    encodeDeploy(e) {
        return this._encodeParams(this.deploy.inputs, e || [])
    }
    decodeErrorResult(e, n) {
        if (typeof e == "string") {
            const r = this.getError(e);
            W(r, "unknown error", "fragment", e), e = r
        }
        return W(It(n, 0, 4) === e.selector, `data signature does not match error ${e.name}.`, "data", n), this._decodeParams(e.inputs, It(n, 4))
    }
    encodeErrorResult(e, n) {
        if (typeof e == "string") {
            const r = this.getError(e);
            W(r, "unknown error", "fragment", e), e = r
        }
        return Ht([e.selector, this._encodeParams(e.inputs, n || [])])
    }
    decodeFunctionData(e, n) {
        if (typeof e == "string") {
            const r = this.getFunction(e);
            W(r, "unknown function", "fragment", e), e = r
        }
        return W(It(n, 0, 4) === e.selector, `data signature does not match function ${e.name}.`, "data", n), this._decodeParams(e.inputs, It(n, 4))
    }
    encodeFunctionData(e, n) {
        if (typeof e == "string") {
            const r = this.getFunction(e);
            W(r, "unknown function", "fragment", e), e = r
        }
        return Ht([e.selector, this._encodeParams(e.inputs, n || [])])
    }
    decodeFunctionResult(e, n) {
        if (typeof e == "string") {
            const s = this.getFunction(e);
            W(s, "unknown function", "fragment", e), e = s
        }
        let r = "invalid length for result data";
        const i = kn(n);
        if (i.length % 32 === 0) try {
            return this.#r.decode(e.outputs, i)
        } catch {
            r = "could not decode result data"
        }
        re(!1, r, "BAD_DATA", {
            value: De(i),
            info: {
                method: e.name,
                signature: e.format()
            }
        })
    }
    makeError(e, n) {
        const r = qe(e, "data"),
            i = Mo.getBuiltinCallException("call", n, r),
            s = "execution reverted (unknown custom error)";
        if (i.message.startsWith(s)) {
            const a = De(r.slice(0, 4)),
                c = this.getError(a);
            if (c) try {
                const l = this.#r.decode(c.inputs, r.slice(4));
                i.revert = {
                    name: c.name,
                    signature: c.format(),
                    args: l
                }, i.reason = i.revert.signature, i.message = `execution reverted: ${i.reason}`
            } catch {
                i.message = "execution reverted (coult not decode custom error)"
            }
        }
        const o = this.parseTransaction(n);
        return o && (i.invocation = {
            method: o.name,
            signature: o.signature,
            args: o.args
        }), i
    }
    encodeFunctionResult(e, n) {
        if (typeof e == "string") {
            const r = this.getFunction(e);
            W(r, "unknown function", "fragment", e), e = r
        }
        return De(this.#r.encode(e.outputs, n || []))
    }
    encodeFilterTopics(e, n) {
        if (typeof e == "string") {
            const s = this.getEvent(e);
            W(s, "unknown event", "eventFragment", e), e = s
        }
        re(n.length <= e.inputs.length, `too many arguments for ${e.format()}`, "UNEXPECTED_ARGUMENT", {
            count: n.length,
            expectedCount: e.inputs.length
        });
        const r = [];
        e.anonymous || r.push(e.topicHash);
        const i = (s, o) => s.type === "string" ? Rs(o) : s.type === "bytes" ? Pt(De(o)) : (s.type === "bool" && typeof o == "boolean" ? o = o ? "0x01" : "0x00" : s.type.match(/^u?int/) ? o = Vi(o) : s.type.match(/^bytes/) ? o = nb(o, 32) : s.type === "address" && this.#r.encode(["address"], [o]), Sr(De(o), 32));
        for (n.forEach((s, o) => {
                const a = e.inputs[o];
                if (!a.indexed) {
                    W(s == null, "cannot filter non-indexed parameters; must be null", "contract." + a.name, s);
                    return
                }
                s == null ? r.push(null) : a.baseType === "array" || a.baseType === "tuple" ? W(!1, "filtering with tuples or arrays not supported", "contract." + a.name, s) : Array.isArray(s) ? r.push(s.map(c => i(a, c))) : r.push(i(a, s))
            }); r.length && r[r.length - 1] === null;) r.pop();
        return r
    }
    encodeEventLog(e, n) {
        if (typeof e == "string") {
            const o = this.getEvent(e);
            W(o, "unknown event", "eventFragment", e), e = o
        }
        const r = [],
            i = [],
            s = [];
        return e.anonymous || r.push(e.topicHash), W(n.length === e.inputs.length, "event arguments/values mismatch", "values", n), e.inputs.forEach((o, a) => {
            const c = n[a];
            if (o.indexed)
                if (o.type === "string") r.push(Rs(c));
                else if (o.type === "bytes") r.push(Pt(c));
            else {
                if (o.baseType === "tuple" || o.baseType === "array") throw new Error("not implemented");
                r.push(this.#r.encode([o.type], [c]))
            } else i.push(o), s.push(c)
        }), {
            data: this.#r.encode(i, s),
            topics: r
        }
    }
    decodeEventLog(e, n, r) {
        if (typeof e == "string") {
            const h = this.getEvent(e);
            W(h, "unknown event", "eventFragment", e), e = h
        }
        if (r != null && !e.anonymous) {
            const h = e.topicHash;
            W(Ot(r[0], 32) && r[0].toLowerCase() === h, "fragment/topic mismatch", "topics[0]", r[0]), r = r.slice(1)
        }
        const i = [],
            s = [],
            o = [];
        e.inputs.forEach((h, p) => {
            h.indexed ? h.type === "string" || h.type === "bytes" || h.baseType === "tuple" || h.baseType === "array" ? (i.push(vt.from({
                type: "bytes32",
                name: h.name
            })), o.push(!0)) : (i.push(h), o.push(!1)) : (s.push(h), o.push(!1))
        });
        const a = r != null ? this.#r.decode(i, Ht(r)) : null,
            c = this.#r.decode(s, n, !0),
            l = [],
            u = [];
        let f = 0,
            d = 0;
        return e.inputs.forEach((h, p) => {
            let g = null;
            if (h.indexed)
                if (a == null) g = new Hg(null);
                else if (o[p]) g = new Hg(a[d++]);
            else try {
                g = a[d++]
            } catch (b) {
                g = b
            } else try {
                g = c[f++]
            } catch (b) {
                g = b
            }
            l.push(g), u.push(h.name || null)
        }), xo.fromItems(l, u)
    }
    parseTransaction(e) {
        const n = qe(e.data, "tx.data"),
            r = Le(e.value != null ? e.value : 0, "tx.value"),
            i = this.getFunction(De(n.slice(0, 4)));
        if (!i) return null;
        const s = this.#r.decode(i.inputs, n.slice(4));
        return new m5(i, i.selector, s, r)
    }
    parseCallResult(e) {
        throw new Error("@TODO")
    }
    parseLog(e) {
        const n = this.getEvent(e.topics[0]);
        return !n || n.anonymous ? null : new p5(n, n.topicHash, this.decodeEventLog(n, e.data, e.topics))
    }
    parseError(e) {
        const n = De(e),
            r = this.getError(It(n, 0, 4));
        if (!r) return null;
        const i = this.#r.decode(r.inputs, It(n, 4));
        return new g5(r, r.selector, i)
    }
    static from(e) {
        return e instanceof ho ? e : typeof e == "string" ? new ho(JSON.parse(e)) : typeof e.format == "function" ? new ho(e.format("json")) : new ho(e)
    }
}
const bw = BigInt(0);

function Ra(t) {
    return t ? ? null
}

function an(t) {
    return t == null ? null : t.toString()
}
class Vg {
    gasPrice;
    maxFeePerGas;
    maxPriorityFeePerGas;
    constructor(e, n, r) {
        Ue(this, {
            gasPrice: Ra(e),
            maxFeePerGas: Ra(n),
            maxPriorityFeePerGas: Ra(r)
        })
    }
    toJSON() {
        const {
            gasPrice: e,
            maxFeePerGas: n,
            maxPriorityFeePerGas: r
        } = this;
        return {
            _type: "FeeData",
            gasPrice: an(e),
            maxFeePerGas: an(n),
            maxPriorityFeePerGas: an(r)
        }
    }
}

function lu(t) {
    const e = {};
    t.to && (e.to = t.to), t.from && (e.from = t.from), t.data && (e.data = De(t.data));
    const n = "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
    for (const i of n) !(i in t) || t[i] == null || (e[i] = Le(t[i], `request.${i}`));
    const r = "type,nonce".split(/,/);
    for (const i of r) !(i in t) || t[i] == null || (e[i] = $e(t[i], `request.${i}`));
    return t.accessList && (e.accessList = Hs(t.accessList)), "blockTag" in t && (e.blockTag = t.blockTag), "enableCcipRead" in t && (e.enableCcipRead = !!t.enableCcipRead), "customData" in t && (e.customData = t.customData), e
}
class y5 {
    provider;
    number;
    hash;
    timestamp;
    parentHash;
    nonce;
    difficulty;
    gasLimit;
    gasUsed;
    miner;
    extraData;
    baseFeePerGas;#
    e;
    constructor(e, n) {
        this.#e = e.transactions.map(r => typeof r != "string" ? new kl(r, n) : r), Ue(this, {
            provider: n,
            hash: Ra(e.hash),
            number: e.number,
            timestamp: e.timestamp,
            parentHash: e.parentHash,
            nonce: e.nonce,
            difficulty: e.difficulty,
            gasLimit: e.gasLimit,
            gasUsed: e.gasUsed,
            miner: e.miner,
            extraData: e.extraData,
            baseFeePerGas: Ra(e.baseFeePerGas)
        })
    }
    get transactions() {
        return this.#e.map(e => typeof e == "string" ? e : e.hash)
    }
    get prefetchedTransactions() {
        const e = this.#e.slice();
        return e.length === 0 ? [] : (re(typeof e[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
            operation: "transactionResponses()"
        }), e)
    }
    toJSON() {
        const {
            baseFeePerGas: e,
            difficulty: n,
            extraData: r,
            gasLimit: i,
            gasUsed: s,
            hash: o,
            miner: a,
            nonce: c,
            number: l,
            parentHash: u,
            timestamp: f,
            transactions: d
        } = this;
        return {
            _type: "Block",
            baseFeePerGas: an(e),
            difficulty: an(n),
            extraData: r,
            gasLimit: an(i),
            gasUsed: an(s),
            hash: o,
            miner: a,
            nonce: c,
            number: l,
            parentHash: u,
            timestamp: f,
            transactions: d
        }
    }[Symbol.iterator]() {
        let e = 0;
        const n = this.transactions;
        return {
            next: () => e < this.length ? {
                value: n[e++],
                done: !1
            } : {
                value: void 0,
                done: !0
            }
        }
    }
    get length() {
        return this.#e.length
    }
    get date() {
        return this.timestamp == null ? null : new Date(this.timestamp * 1e3)
    }
    async getTransaction(e) {
        let n;
        if (typeof e == "number") n = this.#e[e];
        else {
            const r = e.toLowerCase();
            for (const i of this.#e)
                if (typeof i == "string") {
                    if (i !== r) continue;
                    n = i;
                    break
                } else {
                    if (i.hash === r) continue;
                    n = i;
                    break
                }
        }
        if (n == null) throw new Error("no such tx");
        return typeof n == "string" ? await this.provider.getTransaction(n) : n
    }
    getPrefetchedTransaction(e) {
        const n = this.prefetchedTransactions;
        if (typeof e == "number") return n[e];
        e = e.toLowerCase();
        for (const r of n)
            if (r.hash === e) return r;
        W(!1, "no matching transaction", "indexOrHash", e)
    }
    isMined() {
        return !!this.hash
    }
    isLondon() {
        return !!this.baseFeePerGas
    }
    orphanedEvent() {
        if (!this.isMined()) throw new Error("");
        return v5(this)
    }
}
class Al {
    provider;
    transactionHash;
    blockHash;
    blockNumber;
    removed;
    address;
    data;
    topics;
    index;
    transactionIndex;
    constructor(e, n) {
        this.provider = n;
        const r = Object.freeze(e.topics.slice());
        Ue(this, {
            transactionHash: e.transactionHash,
            blockHash: e.blockHash,
            blockNumber: e.blockNumber,
            removed: e.removed,
            address: e.address,
            data: e.data,
            topics: r,
            index: e.index,
            transactionIndex: e.transactionIndex
        })
    }
    toJSON() {
        const {
            address: e,
            blockHash: n,
            blockNumber: r,
            data: i,
            index: s,
            removed: o,
            topics: a,
            transactionHash: c,
            transactionIndex: l
        } = this;
        return {
            _type: "log",
            address: e,
            blockHash: n,
            blockNumber: r,
            data: i,
            index: s,
            removed: o,
            topics: a,
            transactionHash: c,
            transactionIndex: l
        }
    }
    async getBlock() {
        const e = await this.provider.getBlock(this.blockHash);
        return re(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e
    }
    async getTransaction() {
        const e = await this.provider.getTransaction(this.transactionHash);
        return re(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e
    }
    async getTransactionReceipt() {
        const e = await this.provider.getTransactionReceipt(this.transactionHash);
        return re(!!e, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), e
    }
    removedEvent() {
        return b5(this)
    }
}
class ww {
    provider;
    to;
    from;
    contractAddress;
    hash;
    index;
    blockHash;
    blockNumber;
    logsBloom;
    gasUsed;
    cumulativeGasUsed;
    gasPrice;
    type;
    status;
    root;#
    e;
    constructor(e, n) {
        this.#e = Object.freeze(e.logs.map(i => new Al(i, n)));
        let r = bw;
        e.effectiveGasPrice != null ? r = e.effectiveGasPrice : e.gasPrice != null && (r = e.gasPrice), Ue(this, {
            provider: n,
            to: e.to,
            from: e.from,
            contractAddress: e.contractAddress,
            hash: e.hash,
            index: e.index,
            blockHash: e.blockHash,
            blockNumber: e.blockNumber,
            logsBloom: e.logsBloom,
            gasUsed: e.gasUsed,
            cumulativeGasUsed: e.cumulativeGasUsed,
            gasPrice: r,
            type: e.type,
            status: e.status,
            root: e.root
        })
    }
    get logs() {
        return this.#e
    }
    toJSON() {
        const {
            to: e,
            from: n,
            contractAddress: r,
            hash: i,
            index: s,
            blockHash: o,
            blockNumber: a,
            logsBloom: c,
            logs: l,
            status: u,
            root: f
        } = this;
        return {
            _type: "TransactionReceipt",
            blockHash: o,
            blockNumber: a,
            contractAddress: r,
            cumulativeGasUsed: an(this.cumulativeGasUsed),
            from: n,
            gasPrice: an(this.gasPrice),
            gasUsed: an(this.gasUsed),
            hash: i,
            index: s,
            logs: l,
            logsBloom: c,
            root: f,
            status: u,
            to: e
        }
    }
    get length() {
        return this.logs.length
    }[Symbol.iterator]() {
        let e = 0;
        return {
            next: () => e < this.length ? {
                value: this.logs[e++],
                done: !1
            } : {
                value: void 0,
                done: !0
            }
        }
    }
    get fee() {
        return this.gasUsed * this.gasPrice
    }
    async getBlock() {
        const e = await this.provider.getBlock(this.blockHash);
        if (e == null) throw new Error("TODO");
        return e
    }
    async getTransaction() {
        const e = await this.provider.getTransaction(this.hash);
        if (e == null) throw new Error("TODO");
        return e
    }
    async getResult() {
        return await this.provider.getTransactionResult(this.hash)
    }
    async confirmations() {
        return await this.provider.getBlockNumber() - this.blockNumber + 1
    }
    removedEvent() {
        return Aw(this)
    }
    reorderedEvent(e) {
        return re(!e || e.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "reorderedEvent(other)"
        }), xw(this, e)
    }
}
class kl {
    provider;
    blockNumber;
    blockHash;
    index;
    hash;
    type;
    to;
    from;
    nonce;
    gasLimit;
    gasPrice;
    maxPriorityFeePerGas;
    maxFeePerGas;
    data;
    value;
    chainId;
    signature;
    accessList;#
    e;
    constructor(e, n) {
        this.provider = n, this.blockNumber = e.blockNumber != null ? e.blockNumber : null, this.blockHash = e.blockHash != null ? e.blockHash : null, this.hash = e.hash, this.index = e.index, this.type = e.type, this.from = e.from, this.to = e.to || null, this.gasLimit = e.gasLimit, this.nonce = e.nonce, this.data = e.data, this.value = e.value, this.gasPrice = e.gasPrice, this.maxPriorityFeePerGas = e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null, this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null, this.chainId = e.chainId, this.signature = e.signature, this.accessList = e.accessList != null ? e.accessList : null, this.#e = -1
    }
    toJSON() {
        const {
            blockNumber: e,
            blockHash: n,
            index: r,
            hash: i,
            type: s,
            to: o,
            from: a,
            nonce: c,
            data: l,
            signature: u,
            accessList: f
        } = this;
        return {
            _type: "TransactionReceipt",
            accessList: f,
            blockNumber: e,
            blockHash: n,
            chainId: an(this.chainId),
            data: l,
            from: a,
            gasLimit: an(this.gasLimit),
            gasPrice: an(this.gasPrice),
            hash: i,
            maxFeePerGas: an(this.maxFeePerGas),
            maxPriorityFeePerGas: an(this.maxPriorityFeePerGas),
            nonce: c,
            signature: u,
            to: o,
            index: r,
            type: s,
            value: an(this.value)
        }
    }
    async getBlock() {
        let e = this.blockNumber;
        if (e == null) {
            const r = await this.getTransaction();
            r && (e = r.blockNumber)
        }
        if (e == null) return null;
        const n = this.provider.getBlock(e);
        if (n == null) throw new Error("TODO");
        return n
    }
    async getTransaction() {
        return this.provider.getTransaction(this.hash)
    }
    async confirmations() {
        if (this.blockNumber == null) {
            const {
                tx: n,
                blockNumber: r
            } = await fn({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber()
            });
            return n == null || n.blockNumber == null ? 0 : r - n.blockNumber + 1
        }
        return await this.provider.getBlockNumber() - this.blockNumber + 1
    }
    async wait(e, n) {
        const r = e ? ? 1,
            i = n ? ? 0;
        let s = this.#e,
            o = -1,
            a = s === -1;
        const c = async () => {
                if (a) return null;
                const {
                    blockNumber: d,
                    nonce: h
                } = await fn({
                    blockNumber: this.provider.getBlockNumber(),
                    nonce: this.provider.getTransactionCount(this.from)
                });
                if (h < this.nonce) {
                    s = d;
                    return
                }
                if (a) return null;
                const p = await this.getTransaction();
                if (!(p && p.blockNumber != null))
                    for (o === -1 && (o = s - 3, o < this.#e && (o = this.#e)); o <= d;) {
                        if (a) return null;
                        const g = await this.provider.getBlock(o, !0);
                        if (g == null) return;
                        for (const b of g)
                            if (b === this.hash) return;
                        for (let b = 0; b < g.length; b++) {
                            const x = await g.getTransaction(b);
                            if (x.from === this.from && x.nonce === this.nonce) {
                                if (a) return null;
                                const w = await this.provider.getTransactionReceipt(x.hash);
                                if (w == null || d - w.blockNumber + 1 < r) return;
                                let O = "replaced";
                                x.data === this.data && x.to === this.to && x.value === this.value ? O = "repriced" : x.data === "0x" && x.from === x.to && x.value === bw && (O = "cancelled"), re(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                                    cancelled: O === "replaced" || O === "cancelled",
                                    reason: O,
                                    replacement: x.replaceableTransaction(s),
                                    hash: x.hash,
                                    receipt: w
                                })
                            }
                        }
                        o++
                    }
            },
            l = d => {
                if (d == null || d.status !== 0) return d;
                re(!1, "transaction execution reverted", "CALL_EXCEPTION", {
                    action: "sendTransaction",
                    data: null,
                    reason: null,
                    invocation: null,
                    revert: null,
                    transaction: {
                        to: d.to,
                        from: d.from,
                        data: ""
                    },
                    receipt: d
                })
            },
            u = await this.provider.getTransactionReceipt(this.hash);
        if (r === 0) return l(u);
        if (u) {
            if (await u.confirmations() >= r) return l(u)
        } else if (await c(), r === 0) return null;
        return await new Promise((d, h) => {
            const p = [],
                g = () => {
                    p.forEach(x => x())
                };
            if (p.push(() => {
                    a = !0
                }), i > 0) {
                const x = setTimeout(() => {
                    g(), h(Wt("wait for transaction timeout", "TIMEOUT"))
                }, i);
                p.push(() => {
                    clearTimeout(x)
                })
            }
            const b = async x => {
                if (await x.confirmations() >= r) {
                    g();
                    try {
                        d(l(x))
                    } catch (w) {
                        h(w)
                    }
                }
            };
            if (p.push(() => {
                    this.provider.off(this.hash, b)
                }), this.provider.on(this.hash, b), s >= 0) {
                const x = async () => {
                    try {
                        await c()
                    } catch (w) {
                        if (Wn(w, "TRANSACTION_REPLACED")) {
                            g(), h(w);
                            return
                        }
                    }
                    a || this.provider.once("block", x)
                };
                p.push(() => {
                    this.provider.off("block", x)
                }), this.provider.once("block", x)
            }
        })
    }
    isMined() {
        return this.blockHash != null
    }
    isLegacy() {
        return this.type === 0
    }
    isBerlin() {
        return this.type === 1
    }
    isLondon() {
        return this.type === 2
    }
    removedEvent() {
        return re(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
        }), Aw(this)
    }
    reorderedEvent(e) {
        return re(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
        }), re(!e || e.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
            operation: "removeEvent()"
        }), xw(this, e)
    }
    replaceableTransaction(e) {
        W(Number.isInteger(e) && e >= 0, "invalid startBlock", "startBlock", e);
        const n = new kl(this, this.provider);
        return n.#e = e, n
    }
}

function v5(t) {
    return {
        orphan: "drop-block",
        hash: t.hash,
        number: t.number
    }
}

function xw(t, e) {
    return {
        orphan: "reorder-transaction",
        tx: t,
        other: e
    }
}

function Aw(t) {
    return {
        orphan: "drop-transaction",
        tx: t
    }
}

function b5(t) {
    return {
        orphan: "drop-log",
        log: {
            transactionHash: t.transactionHash,
            blockHash: t.blockHash,
            blockNumber: t.blockNumber,
            address: t.address,
            data: t.data,
            topics: Object.freeze(t.topics.slice()),
            index: t.index
        }
    }
}
class Bp extends Al {
    interface;
    fragment;
    args;
    constructor(e, n, r) {
        super(e, e.provider);
        const i = n.decodeEventLog(r, e.data, e.topics);
        Ue(this, {
            args: i,
            fragment: r,
            interface: n
        })
    }
    get eventName() {
        return this.fragment.name
    }
    get eventSignature() {
        return this.fragment.format()
    }
}
class kw extends Al {
    error;
    constructor(e, n) {
        super(e, e.provider), Ue(this, {
            error: n
        })
    }
}
class w5 extends ww {#
    e;
    constructor(e, n, r) {
        super(r, n), this.#e = e
    }
    get logs() {
        return super.logs.map(e => {
            const n = e.topics.length ? this.#e.getEvent(e.topics[0]) : null;
            if (n) try {
                return new Bp(e, this.#e, n)
            } catch (r) {
                return new kw(e, r)
            }
            return e
        })
    }
}
class Ip extends kl {#
    e;
    constructor(e, n, r) {
        super(r, n), this.#e = e
    }
    async wait(e) {
        const n = await super.wait(e);
        return n == null ? null : new w5(this.#e, this.provider, n)
    }
}
class _w extends ib {
    log;
    constructor(e, n, r, i) {
        super(e, n, r), Ue(this, {
            log: i
        })
    }
    async getBlock() {
        return await this.log.getBlock()
    }
    async getTransaction() {
        return await this.log.getTransaction()
    }
    async getTransactionReceipt() {
        return await this.log.getTransactionReceipt()
    }
}
class x5 extends _w {
    constructor(e, n, r, i, s) {
        super(e, n, r, new Bp(s, e.interface, i));
        const o = e.interface.decodeEventLog(i, this.log.data, this.log.topics);
        Ue(this, {
            args: o,
            fragment: i
        })
    }
    get eventName() {
        return this.fragment.name
    }
    get eventSignature() {
        return this.fragment.format()
    }
}
const Gg = BigInt(0);

function Ew(t) {
    return t && typeof t.call == "function"
}

function Pw(t) {
    return t && typeof t.estimateGas == "function"
}

function Ku(t) {
    return t && typeof t.resolveName == "function"
}

function Sw(t) {
    return t && typeof t.sendTransaction == "function"
}

function Nw(t) {
    if (t != null) {
        if (Ku(t)) return t;
        if (t.provider) return t.provider
    }
}
class A5 {#
    e;
    fragment;
    constructor(e, n, r) {
        if (Ue(this, {
                fragment: n
            }), n.inputs.length < r.length) throw new Error("too many arguments");
        const i = Ts(e.runner, "resolveName"),
            s = Ku(i) ? i : null;
        this.#e = async function() {
            const o = await Promise.all(n.inputs.map((a, c) => r[c] == null ? null : a.walkAsync(r[c], (u, f) => u === "address" ? Array.isArray(f) ? Promise.all(f.map(d => pn(d, s))) : pn(f, s) : f)));
            return e.interface.encodeFilterTopics(n, o)
        }()
    }
    getTopicFilter() {
        return this.#e
    }
}

function Ts(t, e) {
    return t == null ? null : typeof t[e] == "function" ? t : t.provider && typeof t.provider[e] == "function" ? t.provider : null
}

function gs(t) {
    return t == null ? null : t.provider || null
}
async function Rw(t, e) {
    const n = Dt.dereference(t, "overrides");
    W(typeof n == "object", "invalid overrides parameter", "overrides", t);
    const r = lu(n);
    return W(r.to == null || (e || []).indexOf("to") >= 0, "cannot override to", "overrides.to", r.to), W(r.data == null || (e || []).indexOf("data") >= 0, "cannot override data", "overrides.data", r.data), r.from && (r.from = r.from), r
}
async function k5(t, e, n) {
    const r = Ts(t, "resolveName"),
        i = Ku(r) ? r : null;
    return await Promise.all(e.map((s, o) => s.walkAsync(n[o], (a, c) => (c = Dt.dereference(c, a), a === "address" ? pn(c, i) : c))))
}

function _5(t) {
    const e = async function(o) {
            const a = await Rw(o, ["data"]);
            a.to = await t.getAddress(), a.from && (a.from = await pn(a.from, Nw(t.runner)));
            const c = t.interface,
                l = Le(a.value || Gg, "overrides.value") === Gg,
                u = (a.data || "0x") === "0x";
            c.fallback && !c.fallback.payable && c.receive && !u && !l && W(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", o), W(c.fallback || u, "cannot send data to receive-only contract", "overrides.data", a.data);
            const f = c.receive || c.fallback && c.fallback.payable;
            return W(f || l, "cannot send value to non-payable fallback", "overrides.value", a.value), W(c.fallback || u, "cannot send data to receive-only contract", "overrides.data", a.data), a
        },
        n = async function(o) {
            const a = Ts(t.runner, "call");
            re(Ew(a), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
                operation: "call"
            });
            const c = await e(o);
            try {
                return await a.call(c)
            } catch (l) {
                throw gp(l) && l.data ? t.interface.makeError(l.data, c) : l
            }
        },
        r = async function(o) {
            const a = t.runner;
            re(Sw(a), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                operation: "sendTransaction"
            });
            const c = await a.sendTransaction(await e(o)),
                l = gs(t.runner);
            return new Ip(t.interface, l, c)
        },
        i = async function(o) {
            const a = Ts(t.runner, "estimateGas");
            return re(Pw(a), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
                operation: "estimateGas"
            }), await a.estimateGas(await e(o))
        },
        s = async o => await r(o);
    return Ue(s, {
        _contract: t,
        estimateGas: i,
        populateTransaction: e,
        send: r,
        staticCall: n
    }), s
}

function E5(t, e) {
    const n = function(...l) {
            const u = t.interface.getFunction(e, l);
            return re(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: {
                    key: e,
                    args: l
                }
            }), u
        },
        r = async function(...l) {
            const u = n(...l);
            let f = {};
            if (u.inputs.length + 1 === l.length && (f = await Rw(l.pop()), f.from && (f.from = await pn(f.from, Nw(t.runner)))), u.inputs.length !== l.length) throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
            const d = await k5(t.runner, u.inputs, l);
            return Object.assign({}, f, await fn({
                to: t.getAddress(),
                data: t.interface.encodeFunctionData(u, d)
            }))
        },
        i = async function(...l) {
            const u = await a(...l);
            return u.length === 1 ? u[0] : u
        },
        s = async function(...l) {
            const u = t.runner;
            re(Sw(u), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                operation: "sendTransaction"
            });
            const f = await u.sendTransaction(await r(...l)),
                d = gs(t.runner);
            return new Ip(t.interface, d, f)
        },
        o = async function(...l) {
            const u = Ts(t.runner, "estimateGas");
            return re(Pw(u), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
                operation: "estimateGas"
            }), await u.estimateGas(await r(...l))
        },
        a = async function(...l) {
            const u = Ts(t.runner, "call");
            re(Ew(u), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
                operation: "call"
            });
            const f = await r(...l);
            let d = "0x";
            try {
                d = await u.call(f)
            } catch (p) {
                throw gp(p) && p.data ? t.interface.makeError(p.data, f) : p
            }
            const h = n(...l);
            return t.interface.decodeFunctionResult(h, d)
        },
        c = async (...l) => n(...l).constant ? await i(...l) : await s(...l);
    return Ue(c, {
        name: t.interface.getFunctionName(e),
        _contract: t,
        _key: e,
        getFragment: n,
        estimateGas: o,
        populateTransaction: r,
        send: s,
        staticCall: i,
        staticCallResult: a
    }), Object.defineProperty(c, "fragment", {
        configurable: !1,
        enumerable: !0,
        get: () => {
            const l = t.interface.getFunction(e);
            return re(l, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: {
                    key: e
                }
            }), l
        }
    }), c
}

function P5(t, e) {
    const n = function(...i) {
            const s = t.interface.getEvent(e, i);
            return re(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: {
                    key: e,
                    args: i
                }
            }), s
        },
        r = function(...i) {
            return new A5(t, n(...i), i)
        };
    return Ue(r, {
        name: t.interface.getEventName(e),
        _contract: t,
        _key: e,
        getFragment: n
    }), Object.defineProperty(r, "fragment", {
        configurable: !1,
        enumerable: !0,
        get: () => {
            const i = t.interface.getEvent(e);
            return re(i, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: {
                    key: e
                }
            }), i
        }
    }), r
}
const cu = Symbol.for("_ethersInternal_contract"),
    Cw = new WeakMap;

function S5(t, e) {
    Cw.set(t[cu], e)
}

function Rn(t) {
    return Cw.get(t[cu])
}

function N5(t) {
    return t && typeof t == "object" && "getTopicFilter" in t && typeof t.getTopicFilter == "function" && t.fragment
}
async function Dp(t, e) {
    let n, r = null;
    if (Array.isArray(e)) {
        const s = function(o) {
            if (Ot(o, 32)) return o;
            const a = t.interface.getEvent(o);
            return W(a, "unknown fragment", "name", o), a.topicHash
        };
        n = e.map(o => o == null ? null : Array.isArray(o) ? o.map(s) : s(o))
    } else e === "*" ? n = [null] : typeof e == "string" ? Ot(e, 32) ? n = [e] : (r = t.interface.getEvent(e), W(r, "unknown fragment", "event", e), n = [r.topicHash]) : N5(e) ? n = await e.getTopicFilter() : "fragment" in e ? (r = e.fragment, n = [r.topicHash]) : W(!1, "unknown event name", "event", e);
    n = n.map(s => {
        if (s == null) return null;
        if (Array.isArray(s)) {
            const o = Array.from(new Set(s.map(a => a.toLowerCase())).values());
            return o.length === 1 ? o[0] : (o.sort(), o)
        }
        return s.toLowerCase()
    });
    const i = n.map(s => s == null ? "null" : Array.isArray(s) ? s.join("|") : s).join("&");
    return {
        fragment: r,
        tag: i,
        topics: n
    }
}
async function ga(t, e) {
    const {
        subs: n
    } = Rn(t);
    return n.get((await Dp(t, e)).tag) || null
}
async function Wg(t, e, n) {
    const r = gs(t.runner);
    re(r, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", {
        operation: e
    });
    const {
        fragment: i,
        tag: s,
        topics: o
    } = await Dp(t, n), {
        addr: a,
        subs: c
    } = Rn(t);
    let l = c.get(s);
    if (!l) {
        const f = {
                address: a || t,
                topics: o
            },
            d = b => {
                let x = i;
                if (x == null) try {
                    x = t.interface.getEvent(b.topics[0])
                } catch {}
                if (x) {
                    const w = x,
                        O = i ? t.interface.decodeEventLog(i, b.data, b.topics) : [];
                    ah(t, n, O, N => new x5(t, N, n, w, b))
                } else ah(t, n, [], w => new _w(t, w, n, b))
            };
        let h = [];
        l = {
            tag: s,
            listeners: [],
            start: () => {
                h.length || h.push(r.on(f, d))
            },
            stop: async () => {
                if (h.length == 0) return;
                let b = h;
                h = [], await Promise.all(b), r.off(f, d)
            }
        }, c.set(s, l)
    }
    return l
}
let oh = Promise.resolve();
async function R5(t, e, n, r) {
    await oh;
    const i = await ga(t, e);
    if (!i) return !1;
    const s = i.listeners.length;
    return i.listeners = i.listeners.filter(({
        listener: o,
        once: a
    }) => {
        const c = Array.from(n);
        r && c.push(r(a ? null : o));
        try {
            o.call(t, ...c)
        } catch {}
        return !a
    }), i.listeners.length === 0 && (i.stop(), Rn(t).subs.delete(i.tag)), s > 0
}
async function ah(t, e, n, r) {
    try {
        await oh
    } catch {}
    const i = R5(t, e, n, r);
    return oh = i, await i
}
const lc = ["then"];
class Ca {
    target;
    interface;
    runner;
    filters;
    [cu];
    fallback;
    constructor(e, n, r, i) {
        W(typeof e == "string" || Tb(e), "invalid value for Contract target", "target", e), r == null && (r = null);
        const s = ho.from(n);
        Ue(this, {
            target: e,
            runner: r,
            interface: s
        }), Object.defineProperty(this, cu, {
            value: {}
        });
        let o, a = null,
            c = null;
        if (i) {
            const f = gs(r);
            c = new Ip(this.interface, f, i)
        }
        let l = new Map;
        if (typeof e == "string")
            if (Ot(e)) a = e, o = Promise.resolve(e);
            else {
                const f = Ts(r, "resolveName");
                if (!Ku(f)) throw Wt("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
                    operation: "resolveName"
                });
                o = f.resolveName(e).then(d => {
                    if (d == null) throw Wt("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                        value: e
                    });
                    return Rn(this).addr = d, d
                })
            }
        else o = e.getAddress().then(f => {
            if (f == null) throw new Error("TODO");
            return Rn(this).addr = f, f
        });
        S5(this, {
            addrPromise: o,
            addr: a,
            deployTx: c,
            subs: l
        });
        const u = new Proxy({}, {
            get: (f, d, h) => {
                if (typeof d == "symbol" || lc.indexOf(d) >= 0) return Reflect.get(f, d, h);
                try {
                    return this.getEvent(d)
                } catch (p) {
                    if (!Wn(p, "INVALID_ARGUMENT") || p.argument !== "key") throw p
                }
            },
            has: (f, d) => lc.indexOf(d) >= 0 ? Reflect.has(f, d) : Reflect.has(f, d) || this.interface.hasEvent(String(d))
        });
        return Ue(this, {
            filters: u
        }), Ue(this, {
            fallback: s.receive || s.fallback ? _5(this) : null
        }), new Proxy(this, {
            get: (f, d, h) => {
                if (typeof d == "symbol" || d in f || lc.indexOf(d) >= 0) return Reflect.get(f, d, h);
                try {
                    return f.getFunction(d)
                } catch (p) {
                    if (!Wn(p, "INVALID_ARGUMENT") || p.argument !== "key") throw p
                }
            },
            has: (f, d) => typeof d == "symbol" || d in f || lc.indexOf(d) >= 0 ? Reflect.has(f, d) : f.interface.hasFunction(d)
        })
    }
    connect(e) {
        return new Ca(this.target, this.interface, e)
    }
    attach(e) {
        return new Ca(e, this.interface, this.runner)
    }
    async getAddress() {
        return await Rn(this).addrPromise
    }
    async getDeployedCode() {
        const e = gs(this.runner);
        re(e, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
            operation: "getDeployedCode"
        });
        const n = await e.getCode(await this.getAddress());
        return n === "0x" ? null : n
    }
    async waitForDeployment() {
        const e = this.deploymentTransaction();
        if (e) return await e.wait(), this;
        if (await this.getDeployedCode() != null) return this;
        const r = gs(this.runner);
        return re(r != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", {
            operation: "waitForDeployment"
        }), new Promise((i, s) => {
            const o = async () => {
                try {
                    if (await this.getDeployedCode() != null) return i(this);
                    r.once("block", o)
                } catch (a) {
                    s(a)
                }
            };
            o()
        })
    }
    deploymentTransaction() {
        return Rn(this).deployTx
    }
    getFunction(e) {
        return typeof e != "string" && (e = e.format()), E5(this, e)
    }
    getEvent(e) {
        return typeof e != "string" && (e = e.format()), P5(this, e)
    }
    async queryTransaction(e) {
        throw new Error("@TODO")
    }
    async queryFilter(e, n, r) {
        n == null && (n = 0), r == null && (r = "latest");
        const {
            addr: i,
            addrPromise: s
        } = Rn(this), o = i || await s, {
            fragment: a,
            topics: c
        } = await Dp(this, e), l = {
            address: o,
            topics: c,
            fromBlock: n,
            toBlock: r
        }, u = gs(this.runner);
        return re(u, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", {
            operation: "queryFilter"
        }), (await u.getLogs(l)).map(f => {
            let d = a;
            if (d == null) try {
                d = this.interface.getEvent(f.topics[0])
            } catch {}
            if (d) try {
                return new Bp(f, this.interface, d)
            } catch (h) {
                return new kw(f, h)
            }
            return new Al(f, u)
        })
    }
    async on(e, n) {
        const r = await Wg(this, "on", e);
        return r.listeners.push({
            listener: n,
            once: !1
        }), r.start(), this
    }
    async once(e, n) {
        const r = await Wg(this, "once", e);
        return r.listeners.push({
            listener: n,
            once: !0
        }), r.start(), this
    }
    async emit(e, ...n) {
        return await ah(this, e, n, null)
    }
    async listenerCount(e) {
        if (e) {
            const i = await ga(this, e);
            return i ? i.listeners.length : 0
        }
        const {
            subs: n
        } = Rn(this);
        let r = 0;
        for (const {
                listeners: i
            } of n.values()) r += i.length;
        return r
    }
    async listeners(e) {
        if (e) {
            const i = await ga(this, e);
            return i ? i.listeners.map(({
                listener: s
            }) => s) : []
        }
        const {
            subs: n
        } = Rn(this);
        let r = [];
        for (const {
                listeners: i
            } of n.values()) r = r.concat(i.map(({
            listener: s
        }) => s));
        return r
    }
    async off(e, n) {
        const r = await ga(this, e);
        if (!r) return this;
        if (n) {
            const i = r.listeners.map(({
                listener: s
            }) => s).indexOf(n);
            i >= 0 && r.listeners.splice(i, 1)
        }
        return (n == null || r.listeners.length === 0) && (r.stop(), Rn(this).subs.delete(r.tag)), this
    }
    async removeAllListeners(e) {
        if (e) {
            const n = await ga(this, e);
            if (!n) return this;
            n.stop(), Rn(this).subs.delete(n.tag)
        } else {
            const {
                subs: n
            } = Rn(this);
            for (const {
                    tag: r,
                    stop: i
                } of n.values()) i(), n.delete(r)
        }
        return this
    }
    async addListener(e, n) {
        return await this.on(e, n)
    }
    async removeListener(e, n) {
        return await this.off(e, n)
    }
    static buildClass(e) {
        class n extends Ca {
            constructor(i, s = null) {
                super(i, e, s)
            }
        }
        return n
    }
    static from(e, n, r) {
        return r == null && (r = null), new this(e, n, r)
    }
}

function C5() {
    return Ca
}
class Mi extends C5() {}

function Zf(t) {
    return t.match(/^ipfs:\/\/ipfs\//i) ? t = t.substring(12) : t.match(/^ipfs:\/\//i) ? t = t.substring(7) : W(!1, "unsupported IPFS format", "link", t), `https://gateway.ipfs.io/ipfs/${t}`
}
class O5 {
    name;
    constructor(e) {
        Ue(this, {
            name: e
        })
    }
    connect(e) {
        return this
    }
    supportsCoinType(e) {
        return !1
    }
    async encodeAddress(e, n) {
        throw new Error("unsupported coin")
    }
    async decodeAddress(e, n) {
        throw new Error("unsupported coin")
    }
}
const Ow = new RegExp("^(ipfs)://(.*)$", "i"),
    Qg = [new RegExp("^(https)://(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), Ow, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];
class ko {
    provider;
    address;
    name;#
    e;#
    t;
    constructor(e, n, r) {
        Ue(this, {
            provider: e,
            address: n,
            name: r
        }), this.#e = null, this.#t = new Mi(n, ["function supportsInterface(bytes4) view returns (bool)", "function resolve(bytes, bytes) view returns (bytes)", "function addr(bytes32) view returns (address)", "function addr(bytes32, uint) view returns (bytes)", "function text(bytes32, string) view returns (string)", "function contenthash(bytes32) view returns (bytes)"], e)
    }
    async supportsWildcard() {
        return this.#e == null && (this.#e = (async () => {
            try {
                return await this.#t.supportsInterface("0x9061b923")
            } catch (e) {
                if (Wn(e, "CALL_EXCEPTION")) return !1;
                throw this.#e = null, e
            }
        })()), await this.#e
    }
    async# n(e, n) {
        n = (n || []).slice();
        const r = this.#t.interface;
        n.unshift(sh(this.name));
        let i = null;
        await this.supportsWildcard() && (i = r.getFunction(e), re(i, "missing fragment", "UNKNOWN_ERROR", {
            info: {
                funcName: e
            }
        }), n = [T8(this.name), r.encodeFunctionData(i, n)], e = "resolve(bytes,bytes)"), n.push({
            enableCcipRead: !0
        });
        try {
            const s = await this.#t[e](...n);
            return i ? r.decodeFunctionResult(i, s)[0] : s
        } catch (s) {
            if (!Wn(s, "CALL_EXCEPTION")) throw s
        }
        return null
    }
    async getAddress(e) {
        if (e == null && (e = 60), e === 60) try {
            const s = await this.#n("addr(bytes32)");
            return s == null || s === $d ? null : s
        } catch (s) {
            if (Wn(s, "CALL_EXCEPTION")) return null;
            throw s
        }
        if (e >= 0 && e < 2147483648) {
            let s = e + 2147483648;
            const o = await this.#n("addr(bytes32,uint)", [s]);
            if (Ot(o, 20)) return ct(o)
        }
        let n = null;
        for (const s of this.provider.plugins)
            if (s instanceof O5 && s.supportsCoinType(e)) {
                n = s;
                break
            }
        if (n == null) return null;
        const r = await this.#n("addr(bytes32,uint)", [e]);
        if (r == null || r === "0x") return null;
        const i = await n.decodeAddress(e, r);
        if (i != null) return i;
        re(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
            operation: `getAddress(${e})`,
            info: {
                coinType: e,
                data: r
            }
        })
    }
    async getText(e) {
        const n = await this.#n("text(bytes32,string)", [e]);
        return n == null || n === "0x" ? null : n
    }
    async getContentHash() {
        const e = await this.#n("contenthash(bytes32)");
        if (e == null || e === "0x") return null;
        const n = e.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (n) {
            const i = n[1] === "e3010170" ? "ipfs" : "ipns",
                s = parseInt(n[4], 16);
            if (n[5].length === s * 2) return `${i}://${nE("0x"+n[2])}`
        }
        const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
        if (r && r[1].length === 64) return `bzz://${r[1]}`;
        re(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
            operation: "getContentHash()",
            info: {
                data: e
            }
        })
    }
    async getAvatar() {
        return (await this._getAvatar()).url
    }
    async _getAvatar() {
        const e = [{
            type: "name",
            value: this.name
        }];
        try {
            const n = await this.getText("avatar");
            if (n == null) return e.push({
                type: "!avatar",
                value: ""
            }), {
                url: null,
                linkage: e
            };
            e.push({
                type: "avatar",
                value: n
            });
            for (let r = 0; r < Qg.length; r++) {
                const i = n.match(Qg[r]);
                if (i == null) continue;
                const s = i[1].toLowerCase();
                switch (s) {
                    case "https":
                    case "data":
                        return e.push({
                            type: "url",
                            value: n
                        }), {
                            linkage: e,
                            url: n
                        };
                    case "ipfs":
                        {
                            const o = Zf(n);
                            return e.push({
                                type: "ipfs",
                                value: n
                            }),
                            e.push({
                                type: "url",
                                value: o
                            }),
                            {
                                linkage: e,
                                url: o
                            }
                        }
                    case "erc721":
                    case "erc1155":
                        {
                            const o = s === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";e.push({
                                type: s,
                                value: n
                            });
                            const a = await this.getAddress();
                            if (a == null) return e.push({
                                type: "!owner",
                                value: ""
                            }), {
                                url: null,
                                linkage: e
                            };
                            const c = (i[2] || "").split("/");
                            if (c.length !== 2) return e.push({
                                type: `!${s}caip`,
                                value: i[2] || ""
                            }), {
                                url: null,
                                linkage: e
                            };
                            const l = c[1],
                                u = new Mi(c[0], ["function tokenURI(uint) view returns (string)", "function ownerOf(uint) view returns (address)", "function uri(uint) view returns (string)", "function balanceOf(address, uint256) view returns (uint)"], this.provider);
                            if (s === "erc721") {
                                const g = await u.ownerOf(l);
                                if (a !== g) return e.push({
                                    type: "!owner",
                                    value: g
                                }), {
                                    url: null,
                                    linkage: e
                                };
                                e.push({
                                    type: "owner",
                                    value: g
                                })
                            } else if (s === "erc1155") {
                                const g = await u.balanceOf(a, l);
                                if (!g) return e.push({
                                    type: "!balance",
                                    value: "0"
                                }), {
                                    url: null,
                                    linkage: e
                                };
                                e.push({
                                    type: "balance",
                                    value: g.toString()
                                })
                            }
                            let f = await u[o](l);
                            if (f == null || f === "0x") return e.push({
                                type: "!metadata-url",
                                value: ""
                            }), {
                                url: null,
                                linkage: e
                            };e.push({
                                type: "metadata-url-base",
                                value: f
                            }),
                            s === "erc1155" && (f = f.replace("{id}", Vi(l, 32).substring(2)), e.push({
                                type: "metadata-url-expanded",
                                value: f
                            })),
                            f.match(/^ipfs:/i) && (f = Zf(f)),
                            e.push({
                                type: "metadata-url",
                                value: f
                            });
                            let d = {};
                            const h = await new Ir(f).send();h.assertOk();
                            try {
                                d = h.bodyJson
                            } catch {
                                try {
                                    e.push({
                                        type: "!metadata",
                                        value: h.bodyText
                                    })
                                } catch {
                                    const x = h.body;
                                    return x && e.push({
                                        type: "!metadata",
                                        value: De(x)
                                    }), {
                                        url: null,
                                        linkage: e
                                    }
                                }
                                return {
                                    url: null,
                                    linkage: e
                                }
                            }
                            if (!d) return e.push({
                                type: "!metadata",
                                value: ""
                            }), {
                                url: null,
                                linkage: e
                            };e.push({
                                type: "metadata",
                                value: JSON.stringify(d)
                            });
                            let p = d.image;
                            if (typeof p != "string") return e.push({
                                type: "!imageUrl",
                                value: ""
                            }), {
                                url: null,
                                linkage: e
                            };
                            if (!p.match(/^(https:\/\/|data:)/i)) {
                                if (p.match(Ow) == null) return e.push({
                                    type: "!imageUrl-ipfs",
                                    value: p
                                }), {
                                    url: null,
                                    linkage: e
                                };
                                e.push({
                                    type: "imageUrl-ipfs",
                                    value: p
                                }), p = Zf(p)
                            }
                            return e.push({
                                type: "url",
                                value: p
                            }),
                            {
                                linkage: e,
                                url: p
                            }
                        }
                }
            }
        } catch {}
        return {
            linkage: e,
            url: null
        }
    }
    static async getEnsAddress(e) {
        const n = await e.getNetwork(),
            r = n.getPlugin("org.ethers.plugins.network.Ens");
        return re(r, "network does not support ENS", "UNSUPPORTED_OPERATION", {
            operation: "getEnsAddress",
            info: {
                network: n
            }
        }), r.address
    }
    static async# r(e, n) {
        const r = await ko.getEnsAddress(e);
        try {
            const s = await new Mi(r, ["function resolver(bytes32) view returns (address)"], e).resolver(sh(n), {
                enableCcipRead: !0
            });
            return s === $d ? null : s
        } catch (i) {
            throw i
        }
        return null
    }
    static async fromName(e, n) {
        let r = n;
        for (;;) {
            if (r === "" || r === "." || n !== "eth" && r === "eth") return null;
            const i = await ko.#r(e, r);
            if (i != null) {
                const s = new ko(e, i, n);
                return r !== n && !await s.supportsWildcard() ? null : s
            }
            r = r.split(".").slice(1).join(".")
        }
    }
}
const Jg = BigInt(0);

function Nt(t, e) {
    return function(n) {
        return n == null ? e : t(n)
    }
}

function Lp(t) {
    return e => {
        if (!Array.isArray(e)) throw new Error("not an array");
        return e.map(n => t(n))
    }
}

function _l(t, e) {
    return n => {
        const r = {};
        for (const i in t) {
            let s = i;
            if (e && i in e && !(s in n)) {
                for (const o of e[i])
                    if (o in n) {
                        s = o;
                        break
                    }
            }
            try {
                const o = t[i](n[s]);
                o !== void 0 && (r[i] = o)
            } catch (o) {
                const a = o instanceof Error ? o.message : "not-an-error";
                re(!1, `invalid value for value.${i} (${a})`, "BAD_DATA", {
                    value: n
                })
            }
        }
        return r
    }
}

function T5(t) {
    switch (t) {
        case !0:
        case "true":
            return !0;
        case !1:
        case "false":
            return !1
    }
    W(!1, `invalid boolean; ${JSON.stringify(t)}`, "value", t)
}

function Fo(t) {
    return W(Ot(t, !0), "invalid data", "value", t), t
}

function Qn(t) {
    return W(Ot(t, 32), "invalid hash", "value", t), t
}
const B5 = _l({
    address: ct,
    blockHash: Qn,
    blockNumber: $e,
    data: Fo,
    index: $e,
    removed: Nt(T5, !1),
    topics: Lp(Qn),
    transactionHash: Qn,
    transactionIndex: $e
}, {
    index: ["logIndex"]
});

function I5(t) {
    return B5(t)
}
const D5 = _l({
    hash: Nt(Qn),
    parentHash: Qn,
    number: $e,
    timestamp: $e,
    nonce: Nt(Fo),
    difficulty: Le,
    gasLimit: Le,
    gasUsed: Le,
    miner: Nt(ct),
    extraData: Fo,
    baseFeePerGas: Nt(Le)
});

function L5(t) {
    const e = D5(t);
    return e.transactions = t.transactions.map(n => typeof n == "string" ? n : Tw(n)), e
}
const M5 = _l({
    transactionIndex: $e,
    blockNumber: $e,
    transactionHash: Qn,
    address: ct,
    topics: Lp(Qn),
    data: Fo,
    index: $e,
    blockHash: Qn
}, {
    index: ["logIndex"]
});

function F5(t) {
    return M5(t)
}
const U5 = _l({
    to: Nt(ct, null),
    from: Nt(ct, null),
    contractAddress: Nt(ct, null),
    index: $e,
    root: Nt(De),
    gasUsed: Le,
    logsBloom: Nt(Fo),
    blockHash: Qn,
    hash: Qn,
    logs: Lp(F5),
    blockNumber: $e,
    cumulativeGasUsed: Le,
    effectiveGasPrice: Nt(Le),
    status: Nt($e),
    type: Nt($e, 0)
}, {
    effectiveGasPrice: ["gasPrice"],
    hash: ["transactionHash"],
    index: ["transactionIndex"]
});

function H5(t) {
    return U5(t)
}

function Tw(t) {
    t.to && Le(t.to) === Jg && (t.to = "0x0000000000000000000000000000000000000000");
    const e = _l({
        hash: Qn,
        type: n => n === "0x" || n == null ? 0 : $e(n),
        accessList: Nt(Hs, null),
        blockHash: Nt(Qn, null),
        blockNumber: Nt($e, null),
        transactionIndex: Nt($e, null),
        from: ct,
        gasPrice: Nt(Le),
        maxPriorityFeePerGas: Nt(Le),
        maxFeePerGas: Nt(Le),
        gasLimit: Le,
        to: Nt(ct, null),
        value: Le,
        nonce: $e,
        data: Fo,
        creates: Nt(ct, null),
        chainId: Nt(Le, null)
    }, {
        data: ["input"],
        gasLimit: ["gas"]
    })(t);
    if (e.to == null && e.creates == null && (e.creates = D6(e)), (t.type === 1 || t.type === 2) && t.accessList == null && (e.accessList = []), t.signature ? e.signature = Qt.from(t.signature) : e.signature = Qt.from(t), e.chainId == null) {
        const n = e.signature.legacyChainId;
        n != null && (e.chainId = n)
    }
    return e.blockHash && Le(e.blockHash) === Jg && (e.blockHash = null), e
}
const z5 = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
class El {
    name;
    constructor(e) {
        Ue(this, {
            name: e
        })
    }
    clone() {
        return new El(this.name)
    }
}
class Zu extends El {
    effectiveBlock;
    txBase;
    txCreate;
    txDataZero;
    txDataNonzero;
    txAccessListStorageKey;
    txAccessListAddress;
    constructor(e, n) {
        e == null && (e = 0), super(`org.ethers.network.plugins.GasCost#${e||0}`);
        const r = {
            effectiveBlock: e
        };

        function i(s, o) {
            let a = (n || {})[s];
            a == null && (a = o), W(typeof a == "number", `invalud value for ${s}`, "costs", n), r[s] = a
        }
        i("txBase", 21e3), i("txCreate", 32e3), i("txDataZero", 4), i("txDataNonzero", 16), i("txAccessListStorageKey", 1900), i("txAccessListAddress", 2400), Ue(this, r)
    }
    clone() {
        return new Zu(this.effectiveBlock, this)
    }
}
class Yu extends El {
    address;
    targetNetwork;
    constructor(e, n) {
        super("org.ethers.plugins.network.Ens"), Ue(this, {
            address: e || z5,
            targetNetwork: n ? ? 1
        })
    }
    clone() {
        return new Yu(this.address, this.targetNetwork)
    }
}
class Bw extends El {#
    e;#
    t;
    get url() {
        return this.#e
    }
    get processFunc() {
        return this.#t
    }
    constructor(e, n) {
        super("org.ethers.plugins.network.FetchUrlFeeDataPlugin"), this.#e = e, this.#t = n
    }
    clone() {
        return this
    }
}
const Yf = new Map;
class jn {#
    e;#
    t;#
    n;
    constructor(e, n) {
        this.#e = e, this.#t = Le(n), this.#n = new Map
    }
    toJSON() {
        return {
            name: this.name,
            chainId: String(this.chainId)
        }
    }
    get name() {
        return this.#e
    }
    set name(e) {
        this.#e = e
    }
    get chainId() {
        return this.#t
    }
    set chainId(e) {
        this.#t = Le(e, "chainId")
    }
    matches(e) {
        if (e == null) return !1;
        if (typeof e == "string") {
            try {
                return this.chainId === Le(e)
            } catch {}
            return this.name === e
        }
        if (typeof e == "number" || typeof e == "bigint") {
            try {
                return this.chainId === Le(e)
            } catch {}
            return !1
        }
        if (typeof e == "object") {
            if (e.chainId != null) {
                try {
                    return this.chainId === Le(e.chainId)
                } catch {}
                return !1
            }
            return e.name != null ? this.name === e.name : !1
        }
        return !1
    }
    get plugins() {
        return Array.from(this.#n.values())
    }
    attachPlugin(e) {
        if (this.#n.get(e.name)) throw new Error(`cannot replace existing plugin: ${e.name} `);
        return this.#n.set(e.name, e.clone()), this
    }
    getPlugin(e) {
        return this.#n.get(e) || null
    }
    getPlugins(e) {
        return this.plugins.filter(n => n.name.split("#")[0] === e)
    }
    clone() {
        const e = new jn(this.name, this.chainId);
        return this.plugins.forEach(n => {
            e.attachPlugin(n.clone())
        }), e
    }
    computeIntrinsicGas(e) {
        const n = this.getPlugin("org.ethers.plugins.network.GasCost") || new Zu;
        let r = n.txBase;
        if (e.to == null && (r += n.txCreate), e.data)
            for (let i = 2; i < e.data.length; i += 2) e.data.substring(i, i + 2) === "00" ? r += n.txDataZero : r += n.txDataNonzero;
        if (e.accessList) {
            const i = Hs(e.accessList);
            for (const s in i) r += n.txAccessListAddress + n.txAccessListStorageKey * i[s].storageKeys.length
        }
        return r
    }
    static from(e) {
        if (V5(), e == null) return jn.from("mainnet");
        if (typeof e == "number" && (e = BigInt(e)), typeof e == "string" || typeof e == "bigint") {
            const n = Yf.get(e);
            if (n) return n();
            if (typeof e == "bigint") return new jn("unknown", e);
            W(!1, "unknown network", "network", e)
        }
        if (typeof e.clone == "function") return e.clone();
        if (typeof e == "object") {
            W(typeof e.name == "string" && typeof e.chainId == "number", "invalid network object name or chainId", "network", e);
            const n = new jn(e.name, e.chainId);
            return (e.ensAddress || e.ensNetwork != null) && n.attachPlugin(new Yu(e.ensAddress, e.ensNetwork)), n
        }
        W(!1, "invalid network", "network", e)
    }
    static register(e, n) {
        typeof e == "number" && (e = BigInt(e));
        const r = Yf.get(e);
        r && W(!1, `conflicting network for ${JSON.stringify(r.name)}`, "nameOrChainId", e), Yf.set(e, n)
    }
}

function Kg(t, e) {
    const n = String(t);
    if (!n.match(/^[0-9.]+$/)) throw new Error(`invalid gwei value: ${t}`);
    const r = n.split(".");
    if (r.length === 1 && r.push(""), r.length !== 2) throw new Error(`invalid gwei value: ${t}`);
    for (; r[1].length < e;) r[1] += "0";
    if (r[1].length > 9) {
        let i = BigInt(r[1].substring(0, 9));
        r[1].substring(9).match(/^0+$/) || i++, r[1] = i.toString()
    }
    return BigInt(r[0] + r[1])
}

function Zg(t) {
    return new Bw(t, async (e, n, r) => {
        r.setHeader("User-Agent", "ethers");
        let i;
        try {
            const [s, o] = await Promise.all([r.send(), e()]);
            i = s;
            const a = i.bodyJson.standard;
            return {
                gasPrice: o.gasPrice,
                maxFeePerGas: Kg(a.maxFee, 9),
                maxPriorityFeePerGas: Kg(a.maxPriorityFee, 9)
            }
        } catch (s) {
            re(!1, `error encountered with polygon gas station (${JSON.stringify(r.url)})`, "SERVER_ERROR", {
                request: r,
                response: i,
                error: s
            })
        }
    })
}

function j5(t) {
    return new Bw("data:", async (e, n, r) => {
        const i = await e();
        if (i.maxFeePerGas == null || i.maxPriorityFeePerGas == null) return i;
        const s = i.maxFeePerGas - i.maxPriorityFeePerGas;
        return {
            gasPrice: i.gasPrice,
            maxFeePerGas: s + t,
            maxPriorityFeePerGas: t
        }
    })
}
let Yg = !1;

function V5() {
    if (Yg) return;
    Yg = !0;

    function t(e, n, r) {
        const i = function() {
            const s = new jn(e, n);
            return r.ensNetwork != null && s.attachPlugin(new Yu(null, r.ensNetwork)), s.attachPlugin(new Zu), (r.plugins || []).forEach(o => {
                s.attachPlugin(o)
            }), s
        };
        jn.register(e, i), jn.register(n, i), r.altNames && r.altNames.forEach(s => {
            jn.register(s, i)
        })
    }
    t("mainnet", 1, {
        ensNetwork: 1,
        altNames: ["homestead"]
    }), t("ropsten", 3, {
        ensNetwork: 3
    }), t("rinkeby", 4, {
        ensNetwork: 4
    }), t("goerli", 5, {
        ensNetwork: 5
    }), t("kovan", 42, {
        ensNetwork: 42
    }), t("sepolia", 11155111, {
        ensNetwork: 11155111
    }), t("classic", 61, {}), t("classicKotti", 6, {}), t("arbitrum", 42161, {
        ensNetwork: 1
    }), t("arbitrum-goerli", 421613, {}), t("bnb", 56, {
        ensNetwork: 1
    }), t("bnbt", 97, {}), t("linea", 59144, {
        ensNetwork: 1
    }), t("linea-goerli", 59140, {}), t("matic", 137, {
        ensNetwork: 1,
        plugins: [Zg("https://gasstation.polygon.technology/v2")]
    }), t("matic-mumbai", 80001, {
        altNames: ["maticMumbai", "maticmum"],
        plugins: [Zg("https://gasstation-testnet.polygon.technology/v2")]
    }), t("optimism", 10, {
        ensNetwork: 1,
        plugins: [j5(BigInt("1000000"))]
    }), t("optimism-goerli", 420, {}), t("xdai", 100, {
        ensNetwork: 1
    })
}

function lh(t) {
    return JSON.parse(JSON.stringify(t))
}
class G5 {#
    e;#
    t;#
    n;#
    r;
    constructor(e) {
        this.#e = e, this.#t = null, this.#n = 4e3, this.#r = -2
    }
    get pollingInterval() {
        return this.#n
    }
    set pollingInterval(e) {
        this.#n = e
    }
    async# i() {
        try {
            const e = await this.#e.getBlockNumber();
            if (this.#r === -2) {
                this.#r = e;
                return
            }
            if (e !== this.#r) {
                for (let n = this.#r + 1; n <= e; n++) {
                    if (this.#t == null) return;
                    await this.#e.emit("block", n)
                }
                this.#r = e
            }
        } catch {}
        this.#t != null && (this.#t = this.#e._setTimeout(this.#i.bind(this), this.#n))
    }
    start() {
        this.#t || (this.#t = this.#e._setTimeout(this.#i.bind(this), this.#n), this.#i())
    }
    stop() {
        this.#t && (this.#e._clearTimeout(this.#t), this.#t = null)
    }
    pause(e) {
        this.stop(), e && (this.#r = -2)
    }
    resume() {
        this.start()
    }
}
class Iw {#
    e;#
    t;#
    n;
    constructor(e) {
        this.#e = e, this.#n = !1, this.#t = n => {
            this._poll(n, this.#e)
        }
    }
    async _poll(e, n) {
        throw new Error("sub-classes must override this")
    }
    start() {
        this.#n || (this.#n = !0, this.#t(-2), this.#e.on("block", this.#t))
    }
    stop() {
        this.#n && (this.#n = !1, this.#e.off("block", this.#t))
    }
    pause(e) {
        this.stop()
    }
    resume() {
        this.start()
    }
}
class W5 extends Iw {#
    e;
    constructor(e, n) {
        super(e), this.#e = lh(n)
    }
    async _poll(e, n) {
        throw new Error("@TODO")
    }
}
class Q5 extends Iw {#
    e;
    constructor(e, n) {
        super(e), this.#e = n
    }
    async _poll(e, n) {
        const r = await n.getTransactionReceipt(this.#e);
        r && n.emit(this.#e, r)
    }
}
class Mp {#
    e;#
    t;#
    n;#
    r;#
    i;
    constructor(e, n) {
        this.#e = e, this.#t = lh(n), this.#n = this.#s.bind(this), this.#r = !1, this.#i = -2
    }
    async# s(e) {
        if (this.#i === -2) return;
        const n = lh(this.#t);
        n.fromBlock = this.#i + 1, n.toBlock = e;
        const r = await this.#e.getLogs(n);
        if (r.length === 0) {
            this.#i < e - 60 && (this.#i = e - 60);
            return
        }
        for (const i of r) this.#e.emit(this.#t, i), this.#i = i.blockNumber
    }
    start() {
        this.#r || (this.#r = !0, this.#i === -2 && this.#e.getBlockNumber().then(e => {
            this.#i = e
        }), this.#e.on("block", this.#n))
    }
    stop() {
        this.#r && (this.#r = !1, this.#e.off("block", this.#n))
    }
    pause(e) {
        this.stop(), e && (this.#i = -2)
    }
    resume() {
        this.start()
    }
}
const J5 = BigInt(2),
    K5 = 10;

function cc(t) {
    return t && typeof t.then == "function"
}

function Ic(t, e) {
    return t + ":" + JSON.stringify(e, (n, r) => {
        if (r == null) return "null";
        if (typeof r == "bigint") return `bigint:${r.toString()}`;
        if (typeof r == "string") return r.toLowerCase();
        if (typeof r == "object" && !Array.isArray(r)) {
            const i = Object.keys(r);
            return i.sort(), i.reduce((s, o) => (s[o] = r[o], s), {})
        }
        return r
    })
}
class Dw {
    name;
    constructor(e) {
        Ue(this, {
            name: e
        })
    }
    start() {}
    stop() {}
    pause(e) {}
    resume() {}
}

function Z5(t) {
    return JSON.parse(JSON.stringify(t))
}

function ch(t) {
    return t = Array.from(new Set(t).values()), t.sort(), t
}
async function Xf(t, e) {
    if (t == null) throw new Error("invalid event");
    if (Array.isArray(t) && (t = {
            topics: t
        }), typeof t == "string") switch (t) {
        case "block":
        case "pending":
        case "debug":
        case "error":
        case "network":
            return {
                type: t,
                tag: t
            }
    }
    if (Ot(t, 32)) {
        const n = t.toLowerCase();
        return {
            type: "transaction",
            tag: Ic("tx", {
                hash: n
            }),
            hash: n
        }
    }
    if (t.orphan) {
        const n = t;
        return {
            type: "orphan",
            tag: Ic("orphan", n),
            filter: Z5(n)
        }
    }
    if (t.address || t.topics) {
        const n = t,
            r = {
                topics: (n.topics || []).map(i => i == null ? null : Array.isArray(i) ? ch(i.map(s => s.toLowerCase())) : i.toLowerCase())
            };
        if (n.address) {
            const i = [],
                s = [],
                o = a => {
                    Ot(a) ? i.push(a) : s.push((async () => {
                        i.push(await pn(a, e))
                    })())
                };
            Array.isArray(n.address) ? n.address.forEach(o) : o(n.address), s.length && await Promise.all(s), r.address = ch(i.map(a => a.toLowerCase()))
        }
        return {
            filter: r,
            tag: Ic("event", r),
            type: "event"
        }
    }
    W(!1, "unknown ProviderEvent", "event", t)
}

function qf() {
    return new Date().getTime()
}
const Y5 = {
    cacheTimeout: 250,
    pollingInterval: 4e3
};
class X5 {#
    e;#
    t;#
    n;#
    r;#
    i;#
    s;#
    o;#
    a;#
    u;#
    c;#
    f;#
    d;
    constructor(e, n) {
        if (this.#d = Object.assign({}, Y5, n || {}), e === "any") this.#s = !0, this.#i = null;
        else if (e) {
            const r = jn.from(e);
            this.#s = !1, this.#i = Promise.resolve(r), setTimeout(() => {
                this.emit("network", r, null)
            }, 0)
        } else this.#s = !1, this.#i = null;
        this.#a = -1, this.#o = new Map, this.#e = new Map, this.#t = new Map, this.#n = null, this.#r = !1, this.#u = 1, this.#c = new Map, this.#f = !1
    }
    get pollingInterval() {
        return this.#d.pollingInterval
    }
    get provider() {
        return this
    }
    get plugins() {
        return Array.from(this.#t.values())
    }
    attachPlugin(e) {
        if (this.#t.get(e.name)) throw new Error(`cannot replace existing plugin: ${e.name} `);
        return this.#t.set(e.name, e.connect(this)), this
    }
    getPlugin(e) {
        return this.#t.get(e) || null
    }
    get disableCcipRead() {
        return this.#f
    }
    set disableCcipRead(e) {
        this.#f = !!e
    }
    async# l(e) {
        const n = this.#d.cacheTimeout;
        if (n < 0) return await this._perform(e);
        const r = Ic(e.method, e);
        let i = this.#o.get(r);
        return i || (i = this._perform(e), this.#o.set(r, i), setTimeout(() => {
            this.#o.get(r) === i && this.#o.delete(r)
        }, n)), await i
    }
    async ccipReadFetch(e, n, r) {
        if (this.disableCcipRead || r.length === 0 || e.to == null) return null;
        const i = e.to.toLowerCase(),
            s = n.toLowerCase(),
            o = [];
        for (let a = 0; a < r.length; a++) {
            const c = r[a],
                l = c.replace("{sender}", i).replace("{data}", s),
                u = new Ir(l);
            c.indexOf("{data}") === -1 && (u.body = {
                data: s,
                sender: i
            }), this.emit("debug", {
                action: "sendCcipReadFetchRequest",
                request: u,
                index: a,
                urls: r
            });
            let f = "unknown error";
            const d = await u.send();
            try {
                const h = d.bodyJson;
                if (h.data) return this.emit("debug", {
                    action: "receiveCcipReadFetchResult",
                    request: u,
                    result: h
                }), h.data;
                h.message && (f = h.message), this.emit("debug", {
                    action: "receiveCcipReadFetchError",
                    request: u,
                    result: h
                })
            } catch {}
            re(d.statusCode < 400 || d.statusCode >= 500, `response not found during CCIP fetch: ${f}`, "OFFCHAIN_FAULT", {
                reason: "404_MISSING_RESOURCE",
                transaction: e,
                info: {
                    url: c,
                    errorMessage: f
                }
            }), o.push(f)
        }
        re(!1, `error encountered during CCIP fetch: ${o.map(a=>JSON.stringify(a)).join(", ")}`, "OFFCHAIN_FAULT", {
            reason: "500_SERVER_ERROR",
            transaction: e,
            info: {
                urls: r,
                errorMessages: o
            }
        })
    }
    _wrapBlock(e, n) {
        return new y5(L5(e), this)
    }
    _wrapLog(e, n) {
        return new Al(I5(e), this)
    }
    _wrapTransactionReceipt(e, n) {
        return new ww(H5(e), this)
    }
    _wrapTransactionResponse(e, n) {
        return new kl(Tw(e), this)
    }
    _detectNetwork() {
        re(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
            operation: "_detectNetwork"
        })
    }
    async _perform(e) {
        re(!1, `unsupported method: ${e.method}`, "UNSUPPORTED_OPERATION", {
            operation: e.method,
            info: e
        })
    }
    async getBlockNumber() {
        const e = $e(await this.#l({
            method: "getBlockNumber"
        }), "%response");
        return this.#a >= 0 && (this.#a = e), e
    }
    _getAddress(e) {
        return pn(e, this)
    }
    _getBlockTag(e) {
        if (e == null) return "latest";
        switch (e) {
            case "earliest":
                return "0x0";
            case "latest":
            case "pending":
            case "safe":
            case "finalized":
                return e
        }
        if (Ot(e)) return Ot(e, 32) ? e : co(e);
        if (typeof e == "bigint" && (e = $e(e, "blockTag")), typeof e == "number") return e >= 0 ? co(e) : this.#a >= 0 ? co(this.#a + e) : this.getBlockNumber().then(n => co(n + e));
        W(!1, "invalid blockTag", "blockTag", e)
    }
    _getFilter(e) {
        const n = (e.topics || []).map(c => c == null ? null : Array.isArray(c) ? ch(c.map(l => l.toLowerCase())) : c.toLowerCase()),
            r = "blockHash" in e ? e.blockHash : void 0,
            i = (c, l, u) => {
                let f;
                switch (c.length) {
                    case 0:
                        break;
                    case 1:
                        f = c[0];
                        break;
                    default:
                        c.sort(), f = c
                }
                if (r && (l != null || u != null)) throw new Error("invalid filter");
                const d = {};
                return f && (d.address = f), n.length && (d.topics = n), l && (d.fromBlock = l), u && (d.toBlock = u), r && (d.blockHash = r), d
            };
        let s = [];
        if (e.address)
            if (Array.isArray(e.address))
                for (const c of e.address) s.push(this._getAddress(c));
            else s.push(this._getAddress(e.address));
        let o;
        "fromBlock" in e && (o = this._getBlockTag(e.fromBlock));
        let a;
        return "toBlock" in e && (a = this._getBlockTag(e.toBlock)), s.filter(c => typeof c != "string").length || o != null && typeof o != "string" || a != null && typeof a != "string" ? Promise.all([Promise.all(s), o, a]).then(c => i(c[0], c[1], c[2])) : i(s, o, a)
    }
    _getTransactionRequest(e) {
        const n = lu(e),
            r = [];
        if (["to", "from"].forEach(i => {
                if (n[i] == null) return;
                const s = pn(n[i], this);
                cc(s) ? r.push(async function() {
                    n[i] = await s
                }()) : n[i] = s
            }), n.blockTag != null) {
            const i = this._getBlockTag(n.blockTag);
            cc(i) ? r.push(async function() {
                n.blockTag = await i
            }()) : n.blockTag = i
        }
        return r.length ? async function() {
            return await Promise.all(r), n
        }() : n
    }
    async getNetwork() {
        if (this.#i == null) {
            const i = this._detectNetwork().then(s => (this.emit("network", s, null), s), s => {
                throw this.#i === i && (this.#i = null), s
            });
            return this.#i = i, (await i).clone()
        }
        const e = this.#i,
            [n, r] = await Promise.all([e, this._detectNetwork()]);
        return n.chainId !== r.chainId && (this.#s ? (this.emit("network", r, n), this.#i === e && (this.#i = Promise.resolve(r))) : re(!1, `network changed: ${n.chainId} => ${r.chainId} `, "NETWORK_ERROR", {
            event: "changed"
        })), n.clone()
    }
    async getFeeData() {
        const e = await this.getNetwork(),
            n = async () => {
                const {
                    _block: i,
                    gasPrice: s
                } = await fn({
                    _block: this.#v("latest", !1),
                    gasPrice: (async () => {
                        try {
                            const l = await this.#l({
                                method: "getGasPrice"
                            });
                            return Le(l, "%response")
                        } catch {}
                        return null
                    })()
                });
                let o = null,
                    a = null;
                const c = this._wrapBlock(i, e);
                return c && c.baseFeePerGas && (a = BigInt("1000000000"), o = c.baseFeePerGas * J5 + a), new Vg(s, o, a)
            },
            r = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
        if (r) {
            const i = new Ir(r.url),
                s = await r.processFunc(n, this, i);
            return new Vg(s.gasPrice, s.maxFeePerGas, s.maxPriorityFeePerGas)
        }
        return await n()
    }
    async estimateGas(e) {
        let n = this._getTransactionRequest(e);
        return cc(n) && (n = await n), Le(await this.#l({
            method: "estimateGas",
            transaction: n
        }), "%response")
    }
    async# h(e, n, r) {
        re(r < K5, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
            reason: "TOO_MANY_REDIRECTS",
            transaction: Object.assign({}, e, {
                blockTag: n,
                enableCcipRead: !0
            })
        });
        const i = lu(e);
        try {
            return De(await this._perform({
                method: "call",
                transaction: i,
                blockTag: n
            }))
        } catch (s) {
            if (!this.disableCcipRead && gp(s) && s.data && r >= 0 && n === "latest" && i.to != null && It(s.data, 0, 4) === "0x556f1830") {
                const o = s.data,
                    a = await pn(i.to, this);
                let c;
                try {
                    c = nP(It(s.data, 4))
                } catch (f) {
                    re(!1, f.message, "OFFCHAIN_FAULT", {
                        reason: "BAD_DATA",
                        transaction: i,
                        info: {
                            data: o
                        }
                    })
                }
                re(c.sender.toLowerCase() === a.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
                    action: "call",
                    data: o,
                    reason: "OffchainLookup",
                    transaction: i,
                    invocation: null,
                    revert: {
                        signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                        name: "OffchainLookup",
                        args: c.errorArgs
                    }
                });
                const l = await this.ccipReadFetch(i, c.calldata, c.urls);
                re(l != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
                    reason: "FETCH_FAILED",
                    transaction: i,
                    info: {
                        data: s.data,
                        errorArgs: c.errorArgs
                    }
                });
                const u = {
                    to: a,
                    data: Ht([c.selector, tP([l, c.extraData])])
                };
                this.emit("debug", {
                    action: "sendCcipReadCall",
                    transaction: u
                });
                try {
                    const f = await this.#h(u, n, r + 1);
                    return this.emit("debug", {
                        action: "receiveCcipReadCallResult",
                        transaction: Object.assign({}, u),
                        result: f
                    }), f
                } catch (f) {
                    throw this.emit("debug", {
                        action: "receiveCcipReadCallError",
                        transaction: Object.assign({}, u),
                        error: f
                    }), f
                }
            }
            throw s
        }
    }
    async# m(e) {
        const {
            value: n
        } = await fn({
            network: this.getNetwork(),
            value: e
        });
        return n
    }
    async call(e) {
        const {
            tx: n,
            blockTag: r
        } = await fn({
            tx: this._getTransactionRequest(e),
            blockTag: this._getBlockTag(e.blockTag)
        });
        return await this.#m(this.#h(n, r, e.enableCcipRead ? 0 : -1))
    }
    async# p(e, n, r) {
        let i = this._getAddress(n),
            s = this._getBlockTag(r);
        return (typeof i != "string" || typeof s != "string") && ([i, s] = await Promise.all([i, s])), await this.#m(this.#l(Object.assign(e, {
            address: i,
            blockTag: s
        })))
    }
    async getBalance(e, n) {
        return Le(await this.#p({
            method: "getBalance"
        }, e, n), "%response")
    }
    async getTransactionCount(e, n) {
        return $e(await this.#p({
            method: "getTransactionCount"
        }, e, n), "%response")
    }
    async getCode(e, n) {
        return De(await this.#p({
            method: "getCode"
        }, e, n))
    }
    async getStorage(e, n, r) {
        const i = Le(n, "position");
        return De(await this.#p({
            method: "getStorage",
            position: i
        }, e, r))
    }
    async broadcastTransaction(e) {
        const {
            blockNumber: n,
            hash: r,
            network: i
        } = await fn({
            blockNumber: this.getBlockNumber(),
            hash: this._perform({
                method: "broadcastTransaction",
                signedTransaction: e
            }),
            network: this.getNetwork()
        }), s = Wr.from(e);
        if (s.hash !== r) throw new Error("@TODO: the returned hash did not match");
        return this._wrapTransactionResponse(s, i).replaceableTransaction(n)
    }
    async# v(e, n) {
        if (Ot(e, 32)) return await this.#l({
            method: "getBlock",
            blockHash: e,
            includeTransactions: n
        });
        let r = this._getBlockTag(e);
        return typeof r != "string" && (r = await r), await this.#l({
            method: "getBlock",
            blockTag: r,
            includeTransactions: n
        })
    }
    async getBlock(e, n) {
        const {
            network: r,
            params: i
        } = await fn({
            network: this.getNetwork(),
            params: this.#v(e, !!n)
        });
        return i == null ? null : this._wrapBlock(i, r)
    }
    async getTransaction(e) {
        const {
            network: n,
            params: r
        } = await fn({
            network: this.getNetwork(),
            params: this.#l({
                method: "getTransaction",
                hash: e
            })
        });
        return r == null ? null : this._wrapTransactionResponse(r, n)
    }
    async getTransactionReceipt(e) {
        const {
            network: n,
            params: r
        } = await fn({
            network: this.getNetwork(),
            params: this.#l({
                method: "getTransactionReceipt",
                hash: e
            })
        });
        if (r == null) return null;
        if (r.gasPrice == null && r.effectiveGasPrice == null) {
            const i = await this.#l({
                method: "getTransaction",
                hash: e
            });
            if (i == null) throw new Error("report this; could not find tx or effectiveGasPrice");
            r.effectiveGasPrice = i.gasPrice
        }
        return this._wrapTransactionReceipt(r, n)
    }
    async getTransactionResult(e) {
        const {
            result: n
        } = await fn({
            network: this.getNetwork(),
            result: this.#l({
                method: "getTransactionResult",
                hash: e
            })
        });
        return n == null ? null : De(n)
    }
    async getLogs(e) {
        let n = this._getFilter(e);
        cc(n) && (n = await n);
        const {
            network: r,
            params: i
        } = await fn({
            network: this.getNetwork(),
            params: this.#l({
                method: "getLogs",
                filter: n
            })
        });
        return i.map(s => this._wrapLog(s, r))
    }
    _getProvider(e) {
        re(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
            operation: "_getProvider()"
        })
    }
    async getResolver(e) {
        return await ko.fromName(this, e)
    }
    async getAvatar(e) {
        const n = await this.getResolver(e);
        return n ? await n.getAvatar() : null
    }
    async resolveName(e) {
        const n = await this.getResolver(e);
        return n ? await n.getAddress() : null
    }
    async lookupAddress(e) {
        e = ct(e);
        const n = sh(e.substring(2).toLowerCase() + ".addr.reverse");
        try {
            const r = await ko.getEnsAddress(this),
                s = await new Mi(r, ["function resolver(bytes32) view returns (address)"], this).resolver(n);
            if (s == null || s === $d) return null;
            const a = await new Mi(s, ["function name(bytes32) view returns (string)"], this).name(n);
            return await this.resolveName(a) !== e ? null : a
        } catch (r) {
            if (Wn(r, "BAD_DATA") && r.value === "0x" || Wn(r, "CALL_EXCEPTION")) return null;
            throw r
        }
        return null
    }
    async waitForTransaction(e, n, r) {
        const i = n ? ? 1;
        return i === 0 ? this.getTransactionReceipt(e) : new Promise(async (s, o) => {
            let a = null;
            const c = async l => {
                try {
                    const u = await this.getTransactionReceipt(e);
                    if (u != null && l - u.blockNumber + 1 >= i) {
                        s(u), a && (clearTimeout(a), a = null);
                        return
                    }
                } catch (u) {
                    console.log("EEE", u)
                }
                this.once("block", c)
            };
            r != null && (a = setTimeout(() => {
                a != null && (a = null, this.off("block", c), o(Wt("timeout", "TIMEOUT", {
                    reason: "timeout"
                })))
            }, r)), c(await this.getBlockNumber())
        })
    }
    async waitForBlock(e) {
        re(!1, "not implemented yet", "NOT_IMPLEMENTED", {
            operation: "waitForBlock"
        })
    }
    _clearTimeout(e) {
        const n = this.#c.get(e);
        n && (n.timer && clearTimeout(n.timer), this.#c.delete(e))
    }
    _setTimeout(e, n) {
        n == null && (n = 0);
        const r = this.#u++,
            i = () => {
                this.#c.delete(r), e()
            };
        if (this.paused) this.#c.set(r, {
            timer: null,
            func: i,
            time: n
        });
        else {
            const s = setTimeout(i, n);
            this.#c.set(r, {
                timer: s,
                func: i,
                time: qf()
            })
        }
        return r
    }
    _forEachSubscriber(e) {
        for (const n of this.#e.values()) e(n.subscriber)
    }
    _getSubscriber(e) {
        switch (e.type) {
            case "debug":
            case "error":
            case "network":
                return new Dw(e.type);
            case "block":
                {
                    const n = new G5(this);
                    return n.pollingInterval = this.pollingInterval,
                    n
                }
            case "event":
                return new Mp(this, e.filter);
            case "transaction":
                return new Q5(this, e.hash);
            case "orphan":
                return new W5(this, e.filter)
        }
        throw new Error(`unsupported event: ${e.type}`)
    }
    _recoverSubscriber(e, n) {
        for (const r of this.#e.values())
            if (r.subscriber === e) {
                r.started && r.subscriber.stop(), r.subscriber = n, r.started && n.start(), this.#n != null && n.pause(this.#n);
                break
            }
    }
    async# g(e, n) {
        let r = await Xf(e, this);
        return r.type === "event" && n && n.length > 0 && n[0].removed === !0 && (r = await Xf({
            orphan: "drop-log",
            log: n[0]
        }, this)), this.#e.get(r.tag) || null
    }
    async# y(e) {
        const n = await Xf(e, this),
            r = n.tag;
        let i = this.#e.get(r);
        return i || (i = {
            subscriber: this._getSubscriber(n),
            tag: r,
            addressableMap: new WeakMap,
            nameMap: new Map,
            started: !1,
            listeners: []
        }, this.#e.set(r, i)), i
    }
    async on(e, n) {
        const r = await this.#y(e);
        return r.listeners.push({
            listener: n,
            once: !1
        }), r.started || (r.subscriber.start(), r.started = !0, this.#n != null && r.subscriber.pause(this.#n)), this
    }
    async once(e, n) {
        const r = await this.#y(e);
        return r.listeners.push({
            listener: n,
            once: !0
        }), r.started || (r.subscriber.start(), r.started = !0, this.#n != null && r.subscriber.pause(this.#n)), this
    }
    async emit(e, ...n) {
        const r = await this.#g(e, n);
        if (!r || r.listeners.length === 0) return !1;
        const i = r.listeners.length;
        return r.listeners = r.listeners.filter(({
            listener: s,
            once: o
        }) => {
            const a = new ib(this, o ? null : s, e);
            try {
                s.call(this, ...n, a)
            } catch {}
            return !o
        }), r.listeners.length === 0 && (r.started && r.subscriber.stop(), this.#e.delete(r.tag)), i > 0
    }
    async listenerCount(e) {
        if (e) {
            const r = await this.#g(e);
            return r ? r.listeners.length : 0
        }
        let n = 0;
        for (const {
                listeners: r
            } of this.#e.values()) n += r.length;
        return n
    }
    async listeners(e) {
        if (e) {
            const r = await this.#g(e);
            return r ? r.listeners.map(({
                listener: i
            }) => i) : []
        }
        let n = [];
        for (const {
                listeners: r
            } of this.#e.values()) n = n.concat(r.map(({
            listener: i
        }) => i));
        return n
    }
    async off(e, n) {
        const r = await this.#g(e);
        if (!r) return this;
        if (n) {
            const i = r.listeners.map(({
                listener: s
            }) => s).indexOf(n);
            i >= 0 && r.listeners.splice(i, 1)
        }
        return (!n || r.listeners.length === 0) && (r.started && r.subscriber.stop(), this.#e.delete(r.tag)), this
    }
    async removeAllListeners(e) {
        if (e) {
            const {
                tag: n,
                started: r,
                subscriber: i
            } = await this.#y(e);
            r && i.stop(), this.#e.delete(n)
        } else
            for (const [n, {
                    started: r,
                    subscriber: i
                }] of this.#e) r && i.stop(), this.#e.delete(n);
        return this
    }
    async addListener(e, n) {
        return await this.on(e, n)
    }
    async removeListener(e, n) {
        return this.off(e, n)
    }
    get destroyed() {
        return this.#r
    }
    destroy() {
        this.removeAllListeners();
        for (const e of this.#c.keys()) this._clearTimeout(e);
        this.#r = !0
    }
    get paused() {
        return this.#n != null
    }
    set paused(e) {
        !!e !== this.paused && (this.paused ? this.resume() : this.pause(!1))
    }
    pause(e) {
        if (this.#a = -1, this.#n != null) {
            if (this.#n == !!e) return;
            re(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
                operation: "pause"
            })
        }
        this._forEachSubscriber(n => n.pause(e)), this.#n = !!e;
        for (const n of this.#c.values()) n.timer && clearTimeout(n.timer), n.time = qf() - n.time
    }
    resume() {
        if (this.#n != null) {
            this._forEachSubscriber(e => e.resume()), this.#n = null;
            for (const e of this.#c.values()) {
                let n = e.time;
                n < 0 && (n = 0), e.time = qf(), setTimeout(e.func, n)
            }
        }
    }
}

function q5(t, e) {
    try {
        const n = uh(t, e);
        if (n) return vp(n)
    } catch {}
    return null
}

function uh(t, e) {
    if (t === "0x") return null;
    try {
        const n = $e(It(t, e, e + 32)),
            r = $e(It(t, n, n + 32));
        return It(t, n + 32, n + 32 + r)
    } catch {}
    return null
}

function Xg(t) {
    const e = _n(t);
    if (e.length > 32) throw new Error("internal; should not happen");
    const n = new Uint8Array(32);
    return n.set(e, 32 - e.length), n
}

function $5(t) {
    if (t.length % 32 === 0) return t;
    const e = new Uint8Array(Math.ceil(t.length / 32) * 32);
    return e.set(t), e
}
const eP = new Uint8Array([]);

function tP(t) {
    const e = [];
    let n = 0;
    for (let r = 0; r < t.length; r++) e.push(eP), n += 32;
    for (let r = 0; r < t.length; r++) {
        const i = qe(t[r]);
        e[r] = Xg(n), e.push(Xg(i.length)), e.push($5(i)), n += 32 + Math.ceil(i.length / 32) * 32
    }
    return Ht(e)
}
const qg = "0x0000000000000000000000000000000000000000000000000000000000000000";

function nP(t) {
    const e = {
        sender: "",
        urls: [],
        calldata: "",
        selector: "",
        extraData: "",
        errorArgs: []
    };
    re(_s(t) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
        reason: "insufficient OffchainLookup data"
    });
    const n = It(t, 0, 32);
    re(It(n, 0, 12) === It(qg, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup sender"
    }), e.sender = It(n, 12);
    try {
        const r = [],
            i = $e(It(t, 32, 64)),
            s = $e(It(t, i, i + 32)),
            o = It(t, i + 32);
        for (let a = 0; a < s; a++) {
            const c = q5(o, a * 32);
            if (c == null) throw new Error("abort");
            r.push(c)
        }
        e.urls = r
    } catch {
        re(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup urls"
        })
    }
    try {
        const r = uh(t, 64);
        if (r == null) throw new Error("abort");
        e.calldata = r
    } catch {
        re(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup calldata"
        })
    }
    re(It(t, 100, 128) === It(qg, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup callbaackSelector"
    }), e.selector = It(t, 96, 100);
    try {
        const r = uh(t, 128);
        if (r == null) throw new Error("abort");
        e.extraData = r
    } catch {
        re(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup extraData"
        })
    }
    return e.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map(r => e[r]), e
}

function eo(t, e) {
    if (t.provider) return t.provider;
    re(!1, "missing provider", "UNSUPPORTED_OPERATION", {
        operation: e
    })
}
async function $g(t, e) {
    let n = lu(e);
    if (n.to != null && (n.to = pn(n.to, t)), n.from != null) {
        const r = n.from;
        n.from = Promise.all([t.getAddress(), pn(r, t)]).then(([i, s]) => (W(i.toLowerCase() === s.toLowerCase(), "transaction from mismatch", "tx.from", s), i))
    } else n.from = t.getAddress();
    return await fn(n)
}
class rP {
    provider;
    constructor(e) {
        Ue(this, {
            provider: e || null
        })
    }
    async getNonce(e) {
        return eo(this, "getTransactionCount").getTransactionCount(await this.getAddress(), e)
    }
    async populateCall(e) {
        return await $g(this, e)
    }
    async populateTransaction(e) {
        const n = eo(this, "populateTransaction"),
            r = await $g(this, e);
        r.nonce == null && (r.nonce = await this.getNonce("pending")), r.gasLimit == null && (r.gasLimit = await this.estimateGas(r));
        const i = await this.provider.getNetwork();
        if (r.chainId != null) {
            const o = Le(r.chainId);
            W(o === i.chainId, "transaction chainId mismatch", "tx.chainId", e.chainId)
        } else r.chainId = i.chainId;
        const s = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
        if (r.gasPrice != null && (r.type === 2 || s) ? W(!1, "eip-1559 transaction do not support gasPrice", "tx", e) : (r.type === 0 || r.type === 1) && s && W(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", e), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null) r.type = 2;
        else if (r.type === 0 || r.type === 1) {
            const o = await n.getFeeData();
            re(o.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
                operation: "getGasPrice"
            }), r.gasPrice == null && (r.gasPrice = o.gasPrice)
        } else {
            const o = await n.getFeeData();
            if (r.type == null)
                if (o.maxFeePerGas != null && o.maxPriorityFeePerGas != null)
                    if (r.type = 2, r.gasPrice != null) {
                        const a = r.gasPrice;
                        delete r.gasPrice, r.maxFeePerGas = a, r.maxPriorityFeePerGas = a
                    } else r.maxFeePerGas == null && (r.maxFeePerGas = o.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = o.maxPriorityFeePerGas);
            else o.gasPrice != null ? (re(!s, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                operation: "populateTransaction"
            }), r.gasPrice == null && (r.gasPrice = o.gasPrice), r.type = 0) : re(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                operation: "signer.getFeeData"
            });
            else r.type === 2 && (r.maxFeePerGas == null && (r.maxFeePerGas = o.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = o.maxPriorityFeePerGas))
        }
        return await fn(r)
    }
    async estimateGas(e) {
        return eo(this, "estimateGas").estimateGas(await this.populateCall(e))
    }
    async call(e) {
        return eo(this, "call").call(await this.populateCall(e))
    }
    async resolveName(e) {
        return await eo(this, "resolveName").resolveName(e)
    }
    async sendTransaction(e) {
        const n = eo(this, "sendTransaction"),
            r = await this.populateTransaction(e);
        delete r.from;
        const i = Wr.from(r);
        return await n.broadcastTransaction(await this.signTransaction(i))
    }
}

function iP(t) {
    return JSON.parse(JSON.stringify(t))
}
class Lw {#
    e;#
    t;#
    n;#
    r;#
    i;#
    s;
    constructor(e) {
        this.#e = e, this.#t = null, this.#n = this.#o.bind(this), this.#r = !1, this.#i = null, this.#s = !1
    }
    _subscribe(e) {
        throw new Error("subclasses must override this")
    }
    _emitResults(e, n) {
        throw new Error("subclasses must override this")
    }
    _recover(e) {
        throw new Error("subclasses must override this")
    }
    async# o(e) {
        try {
            this.#t == null && (this.#t = this._subscribe(this.#e));
            let n = null;
            try {
                n = await this.#t
            } catch (s) {
                if (!Wn(s, "UNSUPPORTED_OPERATION") || s.operation !== "eth_newFilter") throw s
            }
            if (n == null) {
                this.#t = null, this.#e._recoverSubscriber(this, this._recover(this.#e));
                return
            }
            const r = await this.#e.getNetwork();
            if (this.#i || (this.#i = r), this.#i.chainId !== r.chainId) throw new Error("chaid changed");
            if (this.#s) return;
            const i = await this.#e.send("eth_getFilterChanges", [n]);
            await this._emitResults(this.#e, i)
        } catch (n) {
            console.log("@TODO", n)
        }
        this.#e.once("block", this.#n)
    }#
    a() {
        const e = this.#t;
        e && (this.#t = null, e.then(n => {
            this.#e.send("eth_uninstallFilter", [n])
        }))
    }
    start() {
        this.#r || (this.#r = !0, this.#o(-2))
    }
    stop() {
        this.#r && (this.#r = !1, this.#s = !0, this.#a(), this.#e.off("block", this.#n))
    }
    pause(e) {
        e && this.#a(), this.#e.off("block", this.#n)
    }
    resume() {
        this.start()
    }
}
class sP extends Lw {#
    e;
    constructor(e, n) {
        super(e), this.#e = iP(n)
    }
    _recover(e) {
        return new Mp(e, this.#e)
    }
    async _subscribe(e) {
        return await e.send("eth_newFilter", [this.#e])
    }
    async _emitResults(e, n) {
        for (const r of n) e.emit(this.#e, e._wrapLog(r, e._network))
    }
}
class oP extends Lw {
    async _subscribe(e) {
        return await e.send("eth_newPendingTransactionFilter", [])
    }
    async _emitResults(e, n) {
        for (const r of n) e.emit("pending", r)
    }
}
const aP = "bigint,boolean,function,number,string,symbol".split(/,/g);

function Dc(t) {
    if (t == null || aP.indexOf(typeof t) >= 0 || typeof t.getAddress == "function") return t;
    if (Array.isArray(t)) return t.map(Dc);
    if (typeof t == "object") return Object.keys(t).reduce((e, n) => (e[n] = t[n], e), {});
    throw new Error(`should not happen: ${t} (${typeof t})`)
}

function lP(t) {
    return new Promise(e => {
        setTimeout(e, t)
    })
}

function to(t) {
    return t && t.toLowerCase()
}

function e1(t) {
    return t && typeof t.pollingInterval == "number"
}
const cP = {
    polling: !1,
    staticNetwork: null,
    batchStallTime: 10,
    batchMaxSize: 1 << 20,
    batchMaxCount: 100,
    cacheTimeout: 250,
    pollingInterval: 4e3
};
class $f extends rP {
    address;
    constructor(e, n) {
        super(e), n = ct(n), Ue(this, {
            address: n
        })
    }
    connect(e) {
        re(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
            operation: "signer.connect"
        })
    }
    async getAddress() {
        return this.address
    }
    async populateTransaction(e) {
        return await this.populateCall(e)
    }
    async sendUncheckedTransaction(e) {
        const n = Dc(e),
            r = [];
        if (n.from) {
            const s = n.from;
            r.push((async () => {
                const o = await pn(s, this.provider);
                W(o != null && o.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), n.from = o
            })())
        } else n.from = this.address;
        if (n.gasLimit == null && r.push((async () => {
                n.gasLimit = await this.provider.estimateGas({ ...n,
                    from: this.address
                })
            })()), n.to != null) {
            const s = n.to;
            r.push((async () => {
                n.to = await pn(s, this.provider)
            })())
        }
        r.length && await Promise.all(r);
        const i = this.provider.getRpcTransaction(n);
        return this.provider.send("eth_sendTransaction", [i])
    }
    async sendTransaction(e) {
        const n = await this.provider.getBlockNumber(),
            r = await this.sendUncheckedTransaction(e);
        return await new Promise((i, s) => {
            const o = [1e3, 100],
                a = async () => {
                    const c = await this.provider.getTransaction(r);
                    if (c != null) {
                        i(c.replaceableTransaction(n));
                        return
                    }
                    this.provider._setTimeout(() => {
                        a()
                    }, o.pop() || 4e3)
                };
            a()
        })
    }
    async signTransaction(e) {
        const n = Dc(e);
        if (n.from) {
            const i = await pn(n.from, this.provider);
            W(i != null && i.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), n.from = i
        } else n.from = this.address;
        const r = this.provider.getRpcTransaction(n);
        return await this.provider.send("eth_signTransaction", [r])
    }
    async signMessage(e) {
        const n = typeof e == "string" ? Nr(e) : e;
        return await this.provider.send("personal_sign", [De(n), this.address.toLowerCase()])
    }
    async signTypedData(e, n, r) {
        const i = Dc(r),
            s = await Nn.resolveNames(e, n, i, async o => {
                const a = await pn(o);
                return W(a != null, "TypedData does not support null address", "value", o), a
            });
        return await this.provider.send("eth_signTypedData_v4", [this.address.toLowerCase(), JSON.stringify(Nn.getPayload(s.domain, n, s.value))])
    }
    async unlock(e) {
        return this.provider.send("personal_unlockAccount", [this.address.toLowerCase(), e, null])
    }
    async _legacySignMessage(e) {
        const n = typeof e == "string" ? Nr(e) : e;
        return await this.provider.send("eth_sign", [this.address.toLowerCase(), De(n)])
    }
}
class uP extends X5 {#
    e;#
    t;#
    n;#
    r;#
    i;#
    s;#
    o() {
        if (this.#r) return;
        const e = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
        this.#r = setTimeout(() => {
            this.#r = null;
            const n = this.#n;
            for (this.#n = []; n.length;) {
                const r = [n.shift()];
                for (; n.length && r.length !== this.#e.batchMaxCount;)
                    if (r.push(n.shift()), JSON.stringify(r.map(s => s.payload)).length > this.#e.batchMaxSize) {
                        n.unshift(r.pop());
                        break
                    }(async () => {
                        const i = r.length === 1 ? r[0].payload : r.map(s => s.payload);
                        this.emit("debug", {
                            action: "sendRpcPayload",
                            payload: i
                        });
                        try {
                            const s = await this._send(i);
                            this.emit("debug", {
                                action: "receiveRpcResult",
                                result: s
                            });
                            for (const {
                                    resolve: o,
                                    reject: a,
                                    payload: c
                                } of r) {
                                if (this.destroyed) {
                                    a(Wt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                                        operation: c.method
                                    }));
                                    continue
                                }
                                const l = s.filter(u => u.id === c.id)[0];
                                if (l == null) {
                                    const u = Wt("missing response for request", "BAD_DATA", {
                                        value: s,
                                        info: {
                                            payload: c
                                        }
                                    });
                                    this.emit("error", u), a(u);
                                    continue
                                }
                                if ("error" in l) {
                                    a(this.getRpcError(c, l));
                                    continue
                                }
                                o(l.result)
                            }
                        } catch (s) {
                            this.emit("debug", {
                                action: "receiveRpcError",
                                error: s
                            });
                            for (const {
                                    reject: o
                                } of r) o(s)
                        }
                    })()
            }
        }, e)
    }
    constructor(e, n) {
        super(e, n), this.#t = 1, this.#e = Object.assign({}, cP, n || {}), this.#n = [], this.#r = null, this.#s = null; {
            let i = null;
            const s = new Promise(o => {
                i = o
            });
            this.#i = {
                promise: s,
                resolve: i
            }
        }
        const r = this._getOption("staticNetwork");
        r && (W(e == null || r.matches(e), "staticNetwork MUST match network object", "options", n), this.#s = r)
    }
    _getOption(e) {
        return this.#e[e]
    }
    get _network() {
        return re(this.#s, "network is not available yet", "NETWORK_ERROR"), this.#s
    }
    async _perform(e) {
        if (e.method === "call" || e.method === "estimateGas") {
            let r = e.transaction;
            if (r && r.type != null && Le(r.type) && r.maxFeePerGas == null && r.maxPriorityFeePerGas == null) {
                const i = await this.getFeeData();
                i.maxFeePerGas == null && i.maxPriorityFeePerGas == null && (e = Object.assign({}, e, {
                    transaction: Object.assign({}, r, {
                        type: void 0
                    })
                }))
            }
        }
        const n = this.getRpcRequest(e);
        return n != null ? await this.send(n.method, n.args) : super._perform(e)
    }
    async _detectNetwork() {
        const e = this._getOption("staticNetwork");
        if (e) return e;
        if (this.ready) return jn.from(Le(await this.send("eth_chainId", [])));
        const n = {
            id: this.#t++,
            method: "eth_chainId",
            params: [],
            jsonrpc: "2.0"
        };
        this.emit("debug", {
            action: "sendRpcPayload",
            payload: n
        });
        let r;
        try {
            r = (await this._send(n))[0]
        } catch (i) {
            throw this.emit("debug", {
                action: "receiveRpcError",
                error: i
            }), i
        }
        if (this.emit("debug", {
                action: "receiveRpcResult",
                result: r
            }), "result" in r) return jn.from(Le(r.result));
        throw this.getRpcError(n, r)
    }
    _start() {
        this.#i == null || this.#i.resolve == null || (this.#i.resolve(), this.#i = null, (async () => {
            for (; this.#s == null && !this.destroyed;) try {
                this.#s = await this._detectNetwork()
            } catch (e) {
                if (this.destroyed) break;
                console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", Wt("failed to bootstrap network detection", "NETWORK_ERROR", {
                    event: "initial-network-discovery",
                    info: {
                        error: e
                    }
                })), await lP(1e3)
            }
            this.#o()
        })())
    }
    async _waitUntilReady() {
        if (this.#i != null) return await this.#i.promise
    }
    _getSubscriber(e) {
        return e.type === "pending" ? new oP(this) : e.type === "event" ? this._getOption("polling") ? new Mp(this, e.filter) : new sP(this, e.filter) : e.type === "orphan" && e.filter.orphan === "drop-log" ? new Dw("orphan") : super._getSubscriber(e)
    }
    get ready() {
        return this.#i == null
    }
    getRpcTransaction(e) {
        const n = {};
        return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(r => {
            if (e[r] == null) return;
            let i = r;
            r === "gasLimit" && (i = "gas"), n[i] = co(Le(e[r], `tx.${r}`))
        }), ["from", "to", "data"].forEach(r => {
            e[r] != null && (n[r] = De(e[r]))
        }), e.accessList && (n.accessList = Hs(e.accessList)), n
    }
    getRpcRequest(e) {
        switch (e.method) {
            case "chainId":
                return {
                    method: "eth_chainId",
                    args: []
                };
            case "getBlockNumber":
                return {
                    method: "eth_blockNumber",
                    args: []
                };
            case "getGasPrice":
                return {
                    method: "eth_gasPrice",
                    args: []
                };
            case "getBalance":
                return {
                    method: "eth_getBalance",
                    args: [to(e.address), e.blockTag]
                };
            case "getTransactionCount":
                return {
                    method: "eth_getTransactionCount",
                    args: [to(e.address), e.blockTag]
                };
            case "getCode":
                return {
                    method: "eth_getCode",
                    args: [to(e.address), e.blockTag]
                };
            case "getStorage":
                return {
                    method: "eth_getStorageAt",
                    args: [to(e.address), "0x" + e.position.toString(16), e.blockTag]
                };
            case "broadcastTransaction":
                return {
                    method: "eth_sendRawTransaction",
                    args: [e.signedTransaction]
                };
            case "getBlock":
                if ("blockTag" in e) return {
                    method: "eth_getBlockByNumber",
                    args: [e.blockTag, !!e.includeTransactions]
                };
                if ("blockHash" in e) return {
                    method: "eth_getBlockByHash",
                    args: [e.blockHash, !!e.includeTransactions]
                };
                break;
            case "getTransaction":
                return {
                    method: "eth_getTransactionByHash",
                    args: [e.hash]
                };
            case "getTransactionReceipt":
                return {
                    method: "eth_getTransactionReceipt",
                    args: [e.hash]
                };
            case "call":
                return {
                    method: "eth_call",
                    args: [this.getRpcTransaction(e.transaction), e.blockTag]
                };
            case "estimateGas":
                return {
                    method: "eth_estimateGas",
                    args: [this.getRpcTransaction(e.transaction)]
                };
            case "getLogs":
                return e.filter && e.filter.address != null && (Array.isArray(e.filter.address) ? e.filter.address = e.filter.address.map(to) : e.filter.address = to(e.filter.address)), {
                    method: "eth_getLogs",
                    args: [e.filter]
                }
        }
        return null
    }
    getRpcError(e, n) {
        const {
            method: r
        } = e, {
            error: i
        } = n;
        if (r === "eth_estimateGas" && i.message) {
            const a = i.message;
            if (!a.match(/revert/i) && a.match(/insufficient funds/i)) return Wt("insufficient funds", "INSUFFICIENT_FUNDS", {
                transaction: e.params[0],
                info: {
                    payload: e,
                    error: i
                }
            })
        }
        if (r === "eth_call" || r === "eth_estimateGas") {
            const a = fh(i),
                c = Mo.getBuiltinCallException(r === "eth_call" ? "call" : "estimateGas", e.params[0], a ? a.data : null);
            return c.info = {
                error: i,
                payload: e
            }, c
        }
        const s = JSON.stringify(hP(i));
        if (typeof i.message == "string" && i.message.match(/user denied|ethers-user-denied/i)) return Wt("user rejected action", "ACTION_REJECTED", {
            action: {
                eth_sign: "signMessage",
                personal_sign: "signMessage",
                eth_signTypedData_v4: "signTypedData",
                eth_signTransaction: "signTransaction",
                eth_sendTransaction: "sendTransaction",
                eth_requestAccounts: "requestAccess",
                wallet_requestAccounts: "requestAccess"
            }[r] || "unknown",
            reason: "rejected",
            info: {
                payload: e,
                error: i
            }
        });
        if (r === "eth_sendRawTransaction" || r === "eth_sendTransaction") {
            const a = e.params[0];
            if (s.match(/insufficient funds|base fee exceeds gas limit/i)) return Wt("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                transaction: a,
                info: {
                    error: i
                }
            });
            if (s.match(/nonce/i) && s.match(/too low/i)) return Wt("nonce has already been used", "NONCE_EXPIRED", {
                transaction: a,
                info: {
                    error: i
                }
            });
            if (s.match(/replacement transaction/i) && s.match(/underpriced/i)) return Wt("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                transaction: a,
                info: {
                    error: i
                }
            });
            if (s.match(/only replay-protected/i)) return Wt("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
                operation: r,
                info: {
                    transaction: a,
                    info: {
                        error: i
                    }
                }
            })
        }
        let o = !!s.match(/the method .* does not exist/i);
        return o || i && i.details && i.details.startsWith("Unauthorized method:") && (o = !0), o ? Wt("unsupported operation", "UNSUPPORTED_OPERATION", {
            operation: e.method,
            info: {
                error: i,
                payload: e
            }
        }) : Wt("could not coalesce error", "UNKNOWN_ERROR", {
            error: i,
            payload: e
        })
    }
    send(e, n) {
        if (this.destroyed) return Promise.reject(Wt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
            operation: e
        }));
        const r = this.#t++,
            i = new Promise((s, o) => {
                this.#n.push({
                    resolve: s,
                    reject: o,
                    payload: {
                        method: e,
                        params: n,
                        id: r,
                        jsonrpc: "2.0"
                    }
                })
            });
        return this.#o(), i
    }
    async getSigner(e) {
        e == null && (e = 0);
        const n = this.send("eth_accounts", []);
        if (typeof e == "number") {
            const i = await n;
            if (e >= i.length) throw new Error("no such account");
            return new $f(this, i[e])
        }
        const {
            accounts: r
        } = await fn({
            network: this.getNetwork(),
            accounts: n
        });
        e = ct(e);
        for (const i of r)
            if (ct(i) === e) return new $f(this, e);
        throw new Error("invalid account")
    }
    async listAccounts() {
        return (await this.send("eth_accounts", [])).map(n => new $f(this, n))
    }
    destroy() {
        this.#r && (clearTimeout(this.#r), this.#r = null);
        for (const {
                payload: e,
                reject: n
            } of this.#n) n(Wt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
            operation: e.method
        }));
        this.#n = [], super.destroy()
    }
}
class fP extends uP {#
    e;
    constructor(e, n) {
        super(e, n), this.#e = 4e3
    }
    _getSubscriber(e) {
        const n = super._getSubscriber(e);
        return e1(n) && (n.pollingInterval = this.#e), n
    }
    get pollingInterval() {
        return this.#e
    }
    set pollingInterval(e) {
        if (!Number.isInteger(e) || e < 0) throw new Error("invalid interval");
        this.#e = e, this._forEachSubscriber(n => {
            e1(n) && (n.pollingInterval = this.#e)
        })
    }
}
class dP extends fP {#
    e;
    constructor(e, n, r) {
        e == null && (e = "http://localhost:8545"), super(n, r), typeof e == "string" ? this.#e = new Ir(e) : this.#e = e.clone()
    }
    _getConnection() {
        return this.#e.clone()
    }
    async send(e, n) {
        return await this._start(), await super.send(e, n)
    }
    async _send(e) {
        const n = this._getConnection();
        n.body = JSON.stringify(e), n.setHeader("content-type", "application/json");
        const r = await n.send();
        r.assertOk();
        let i = r.bodyJson;
        return Array.isArray(i) || (i = [i]), i
    }
}

function fh(t) {
    if (t == null) return null;
    if (typeof t.message == "string" && t.message.match(/revert/i) && Ot(t.data)) return {
        message: t.message,
        data: t.data
    };
    if (typeof t == "object") {
        for (const e in t) {
            const n = fh(t[e]);
            if (n) return n
        }
        return null
    }
    if (typeof t == "string") try {
        return fh(JSON.parse(t))
    } catch {}
    return null
}

function dh(t, e) {
    if (t != null) {
        if (typeof t.message == "string" && e.push(t.message), typeof t == "object")
            for (const n in t) dh(t[n], e);
        if (typeof t == "string") try {
            return dh(JSON.parse(t), e)
        } catch {}
    }
}

function hP(t) {
    const e = [];
    return dh(t, e), e
}
var pP = {
    VITE_WEB3_RPC_URL: "/rpc/mainnet",
    VITE_API_URL: "/api",
    VITE_ROCKET_STORAGE_ADDRESS: "0x1d8f8f00cfa6758d7bE78336684788Fb0ee0Fa46",
    VITE_DEPOSIT_CONTRACT_ADDRESS: "0x00000000219ab540356cbb839cbe05303d7705fa",
    BASE_URL: "/",
    MODE: "production",
    DEV: !1,
    PROD: !0,
    SSR: !1
};

function hh(t) {
    return pP[t]
}
const mP = [{
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !1,
        internalType: "address",
        name: "oldGuardian",
        type: "address"
    }, {
        indexed: !1,
        internalType: "address",
        name: "newGuardian",
        type: "address"
    }],
    name: "GuardianChanged",
    type: "event"
}, {
    anonymous: !1,
    inputs: [{
        indexed: !0,
        internalType: "address",
        name: "node",
        type: "address"
    }, {
        indexed: !0,
        internalType: "address",
        name: "withdrawalAddress",
        type: "address"
    }, {
        indexed: !1,
        internalType: "uint256",
        name: "time",
        type: "uint256"
    }],
    name: "NodeWithdrawalAddressSet",
    type: "event"
}, {
    inputs: [],
    name: "getGuardian",
    outputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    stateMutability: "view",
    type: "function",
    constant: !0
}, {
    inputs: [{
        internalType: "address",
        name: "_newAddress",
        type: "address"
    }],
    name: "setGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "confirmGuardian",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [],
    name: "getDeployedStatus",
    outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
    }],
    stateMutability: "view",
    type: "function",
    constant: !0
}, {
    inputs: [],
    name: "setDeployedStatus",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "_nodeAddress",
        type: "address"
    }],
    name: "getNodeWithdrawalAddress",
    outputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    stateMutability: "view",
    type: "function",
    constant: !0
}, {
    inputs: [{
        internalType: "address",
        name: "_nodeAddress",
        type: "address"
    }],
    name: "getNodePendingWithdrawalAddress",
    outputs: [{
        internalType: "address",
        name: "",
        type: "address"
    }],
    stateMutability: "view",
    type: "function",
    constant: !0
}, {
    inputs: [{
        internalType: "address",
        name: "_nodeAddress",
        type: "address"
    }, {
        internalType: "address",
        name: "_newWithdrawalAddress",
        type: "address"
    }, {
        internalType: "bool",
        name: "_confirm",
        type: "bool"
    }],
    name: "setWithdrawalAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "address",
        name: "_nodeAddress",
        type: "address"
    }],
    name: "confirmWithdrawalAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "getAddress",
    outputs: [{
        internalType: "address",
        name: "r",
        type: "address"
    }],
    stateMutability: "view",
    type: "function",
    constant: !0
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "getUint",
    outputs: [{
        internalType: "uint256",
        name: "r",
        type: "uint256"
    }],
    stateMutability: "view",
    type: "function",
    constant: !0
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "getString",
    outputs: [{
        internalType: "string",
        name: "",
        type: "string"
    }],
    stateMutability: "view",
    type: "function",
    constant: !0
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "getBytes",
    outputs: [{
        internalType: "bytes",
        name: "",
        type: "bytes"
    }],
    stateMutability: "view",
    type: "function",
    constant: !0
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "getBool",
    outputs: [{
        internalType: "bool",
        name: "r",
        type: "bool"
    }],
    stateMutability: "view",
    type: "function",
    constant: !0
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "getInt",
    outputs: [{
        internalType: "int256",
        name: "r",
        type: "int256"
    }],
    stateMutability: "view",
    type: "function",
    constant: !0
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "getBytes32",
    outputs: [{
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
    }],
    stateMutability: "view",
    type: "function",
    constant: !0
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }, {
        internalType: "address",
        name: "_value",
        type: "address"
    }],
    name: "setAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }, {
        internalType: "uint256",
        name: "_value",
        type: "uint256"
    }],
    name: "setUint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }, {
        internalType: "string",
        name: "_value",
        type: "string"
    }],
    name: "setString",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }, {
        internalType: "bytes",
        name: "_value",
        type: "bytes"
    }],
    name: "setBytes",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }, {
        internalType: "bool",
        name: "_value",
        type: "bool"
    }],
    name: "setBool",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }, {
        internalType: "int256",
        name: "_value",
        type: "int256"
    }],
    name: "setInt",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }, {
        internalType: "bytes32",
        name: "_value",
        type: "bytes32"
    }],
    name: "setBytes32",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "deleteAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "deleteUint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "deleteString",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "deleteBytes",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "deleteBool",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "deleteInt",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }],
    name: "deleteBytes32",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }, {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
    }],
    name: "addUint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}, {
    inputs: [{
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
    }, {
        internalType: "uint256",
        name: "_amount",
        type: "uint256"
    }],
    name: "subUint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
}]; /*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const gP = 4,
    t1 = 0,
    n1 = 1,
    yP = 2;

function Yo(t) {
    let e = t.length;
    for (; --e >= 0;) t[e] = 0
}
const vP = 0,
    Mw = 1,
    bP = 2,
    wP = 3,
    xP = 258,
    Fp = 29,
    Pl = 256,
    Xa = Pl + 1 + Fp,
    _o = 30,
    Up = 19,
    Fw = 2 * Xa + 1,
    ys = 15,
    ed = 16,
    AP = 7,
    Hp = 256,
    Uw = 16,
    Hw = 17,
    zw = 18,
    ph = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
    Lc = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
    kP = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
    jw = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
    _P = 512,
    Jr = new Array((Xa + 2) * 2);
Yo(Jr);
const Oa = new Array(_o * 2);
Yo(Oa);
const qa = new Array(_P);
Yo(qa);
const $a = new Array(xP - wP + 1);
Yo($a);
const zp = new Array(Fp);
Yo(zp);
const uu = new Array(_o);
Yo(uu);

function td(t, e, n, r, i) {
    this.static_tree = t, this.extra_bits = e, this.extra_base = n, this.elems = r, this.max_length = i, this.has_stree = t && t.length
}
let Vw, Gw, Ww;

function nd(t, e) {
    this.dyn_tree = t, this.max_code = 0, this.stat_desc = e
}
const Qw = t => t < 256 ? qa[t] : qa[256 + (t >>> 7)],
    el = (t, e) => {
        t.pending_buf[t.pending++] = e & 255, t.pending_buf[t.pending++] = e >>> 8 & 255
    },
    En = (t, e, n) => {
        t.bi_valid > ed - n ? (t.bi_buf |= e << t.bi_valid & 65535, el(t, t.bi_buf), t.bi_buf = e >> ed - t.bi_valid, t.bi_valid += n - ed) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += n)
    },
    Ar = (t, e, n) => {
        En(t, n[e * 2], n[e * 2 + 1])
    },
    Jw = (t, e) => {
        let n = 0;
        do n |= t & 1, t >>>= 1, n <<= 1; while (--e > 0);
        return n >>> 1
    },
    EP = t => {
        t.bi_valid === 16 ? (el(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = t.bi_buf & 255, t.bi_buf >>= 8, t.bi_valid -= 8)
    },
    PP = (t, e) => {
        const n = e.dyn_tree,
            r = e.max_code,
            i = e.stat_desc.static_tree,
            s = e.stat_desc.has_stree,
            o = e.stat_desc.extra_bits,
            a = e.stat_desc.extra_base,
            c = e.stat_desc.max_length;
        let l, u, f, d, h, p, g = 0;
        for (d = 0; d <= ys; d++) t.bl_count[d] = 0;
        for (n[t.heap[t.heap_max] * 2 + 1] = 0, l = t.heap_max + 1; l < Fw; l++) u = t.heap[l], d = n[n[u * 2 + 1] * 2 + 1] + 1, d > c && (d = c, g++), n[u * 2 + 1] = d, !(u > r) && (t.bl_count[d]++, h = 0, u >= a && (h = o[u - a]), p = n[u * 2], t.opt_len += p * (d + h), s && (t.static_len += p * (i[u * 2 + 1] + h)));
        if (g !== 0) {
            do {
                for (d = c - 1; t.bl_count[d] === 0;) d--;
                t.bl_count[d]--, t.bl_count[d + 1] += 2, t.bl_count[c]--, g -= 2
            } while (g > 0);
            for (d = c; d !== 0; d--)
                for (u = t.bl_count[d]; u !== 0;) f = t.heap[--l], !(f > r) && (n[f * 2 + 1] !== d && (t.opt_len += (d - n[f * 2 + 1]) * n[f * 2], n[f * 2 + 1] = d), u--)
        }
    },
    Kw = (t, e, n) => {
        const r = new Array(ys + 1);
        let i = 0,
            s, o;
        for (s = 1; s <= ys; s++) i = i + n[s - 1] << 1, r[s] = i;
        for (o = 0; o <= e; o++) {
            let a = t[o * 2 + 1];
            a !== 0 && (t[o * 2] = Jw(r[a]++, a))
        }
    },
    SP = () => {
        let t, e, n, r, i;
        const s = new Array(ys + 1);
        for (n = 0, r = 0; r < Fp - 1; r++)
            for (zp[r] = n, t = 0; t < 1 << ph[r]; t++) $a[n++] = r;
        for ($a[n - 1] = r, i = 0, r = 0; r < 16; r++)
            for (uu[r] = i, t = 0; t < 1 << Lc[r]; t++) qa[i++] = r;
        for (i >>= 7; r < _o; r++)
            for (uu[r] = i << 7, t = 0; t < 1 << Lc[r] - 7; t++) qa[256 + i++] = r;
        for (e = 0; e <= ys; e++) s[e] = 0;
        for (t = 0; t <= 143;) Jr[t * 2 + 1] = 8, t++, s[8]++;
        for (; t <= 255;) Jr[t * 2 + 1] = 9, t++, s[9]++;
        for (; t <= 279;) Jr[t * 2 + 1] = 7, t++, s[7]++;
        for (; t <= 287;) Jr[t * 2 + 1] = 8, t++, s[8]++;
        for (Kw(Jr, Xa + 1, s), t = 0; t < _o; t++) Oa[t * 2 + 1] = 5, Oa[t * 2] = Jw(t, 5);
        Vw = new td(Jr, ph, Pl + 1, Xa, ys), Gw = new td(Oa, Lc, 0, _o, ys), Ww = new td(new Array(0), kP, 0, Up, AP)
    },
    Zw = t => {
        let e;
        for (e = 0; e < Xa; e++) t.dyn_ltree[e * 2] = 0;
        for (e = 0; e < _o; e++) t.dyn_dtree[e * 2] = 0;
        for (e = 0; e < Up; e++) t.bl_tree[e * 2] = 0;
        t.dyn_ltree[Hp * 2] = 1, t.opt_len = t.static_len = 0, t.sym_next = t.matches = 0
    },
    Yw = t => {
        t.bi_valid > 8 ? el(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0
    },
    r1 = (t, e, n, r) => {
        const i = e * 2,
            s = n * 2;
        return t[i] < t[s] || t[i] === t[s] && r[e] <= r[n]
    },
    rd = (t, e, n) => {
        const r = t.heap[n];
        let i = n << 1;
        for (; i <= t.heap_len && (i < t.heap_len && r1(e, t.heap[i + 1], t.heap[i], t.depth) && i++, !r1(e, r, t.heap[i], t.depth));) t.heap[n] = t.heap[i], n = i, i <<= 1;
        t.heap[n] = r
    },
    i1 = (t, e, n) => {
        let r, i, s = 0,
            o, a;
        if (t.sym_next !== 0)
            do r = t.pending_buf[t.sym_buf + s++] & 255, r += (t.pending_buf[t.sym_buf + s++] & 255) << 8, i = t.pending_buf[t.sym_buf + s++], r === 0 ? Ar(t, i, e) : (o = $a[i], Ar(t, o + Pl + 1, e), a = ph[o], a !== 0 && (i -= zp[o], En(t, i, a)), r--, o = Qw(r), Ar(t, o, n), a = Lc[o], a !== 0 && (r -= uu[o], En(t, r, a))); while (s < t.sym_next);
        Ar(t, Hp, e)
    },
    mh = (t, e) => {
        const n = e.dyn_tree,
            r = e.stat_desc.static_tree,
            i = e.stat_desc.has_stree,
            s = e.stat_desc.elems;
        let o, a, c = -1,
            l;
        for (t.heap_len = 0, t.heap_max = Fw, o = 0; o < s; o++) n[o * 2] !== 0 ? (t.heap[++t.heap_len] = c = o, t.depth[o] = 0) : n[o * 2 + 1] = 0;
        for (; t.heap_len < 2;) l = t.heap[++t.heap_len] = c < 2 ? ++c : 0, n[l * 2] = 1, t.depth[l] = 0, t.opt_len--, i && (t.static_len -= r[l * 2 + 1]);
        for (e.max_code = c, o = t.heap_len >> 1; o >= 1; o--) rd(t, n, o);
        l = s;
        do o = t.heap[1], t.heap[1] = t.heap[t.heap_len--], rd(t, n, 1), a = t.heap[1], t.heap[--t.heap_max] = o, t.heap[--t.heap_max] = a, n[l * 2] = n[o * 2] + n[a * 2], t.depth[l] = (t.depth[o] >= t.depth[a] ? t.depth[o] : t.depth[a]) + 1, n[o * 2 + 1] = n[a * 2 + 1] = l, t.heap[1] = l++, rd(t, n, 1); while (t.heap_len >= 2);
        t.heap[--t.heap_max] = t.heap[1], PP(t, e), Kw(n, c, t.bl_count)
    },
    s1 = (t, e, n) => {
        let r, i = -1,
            s, o = e[0 * 2 + 1],
            a = 0,
            c = 7,
            l = 4;
        for (o === 0 && (c = 138, l = 3), e[(n + 1) * 2 + 1] = 65535, r = 0; r <= n; r++) s = o, o = e[(r + 1) * 2 + 1], !(++a < c && s === o) && (a < l ? t.bl_tree[s * 2] += a : s !== 0 ? (s !== i && t.bl_tree[s * 2]++, t.bl_tree[Uw * 2]++) : a <= 10 ? t.bl_tree[Hw * 2]++ : t.bl_tree[zw * 2]++, a = 0, i = s, o === 0 ? (c = 138, l = 3) : s === o ? (c = 6, l = 3) : (c = 7, l = 4))
    },
    o1 = (t, e, n) => {
        let r, i = -1,
            s, o = e[0 * 2 + 1],
            a = 0,
            c = 7,
            l = 4;
        for (o === 0 && (c = 138, l = 3), r = 0; r <= n; r++)
            if (s = o, o = e[(r + 1) * 2 + 1], !(++a < c && s === o)) {
                if (a < l)
                    do Ar(t, s, t.bl_tree); while (--a !== 0);
                else s !== 0 ? (s !== i && (Ar(t, s, t.bl_tree), a--), Ar(t, Uw, t.bl_tree), En(t, a - 3, 2)) : a <= 10 ? (Ar(t, Hw, t.bl_tree), En(t, a - 3, 3)) : (Ar(t, zw, t.bl_tree), En(t, a - 11, 7));
                a = 0, i = s, o === 0 ? (c = 138, l = 3) : s === o ? (c = 6, l = 3) : (c = 7, l = 4)
            }
    },
    NP = t => {
        let e;
        for (s1(t, t.dyn_ltree, t.l_desc.max_code), s1(t, t.dyn_dtree, t.d_desc.max_code), mh(t, t.bl_desc), e = Up - 1; e >= 3 && t.bl_tree[jw[e] * 2 + 1] === 0; e--);
        return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e
    },
    RP = (t, e, n, r) => {
        let i;
        for (En(t, e - 257, 5), En(t, n - 1, 5), En(t, r - 4, 4), i = 0; i < r; i++) En(t, t.bl_tree[jw[i] * 2 + 1], 3);
        o1(t, t.dyn_ltree, e - 1), o1(t, t.dyn_dtree, n - 1)
    },
    CP = t => {
        let e = 4093624447,
            n;
        for (n = 0; n <= 31; n++, e >>>= 1)
            if (e & 1 && t.dyn_ltree[n * 2] !== 0) return t1;
        if (t.dyn_ltree[9 * 2] !== 0 || t.dyn_ltree[10 * 2] !== 0 || t.dyn_ltree[13 * 2] !== 0) return n1;
        for (n = 32; n < Pl; n++)
            if (t.dyn_ltree[n * 2] !== 0) return n1;
        return t1
    };
let a1 = !1;
const OP = t => {
        a1 || (SP(), a1 = !0), t.l_desc = new nd(t.dyn_ltree, Vw), t.d_desc = new nd(t.dyn_dtree, Gw), t.bl_desc = new nd(t.bl_tree, Ww), t.bi_buf = 0, t.bi_valid = 0, Zw(t)
    },
    Xw = (t, e, n, r) => {
        En(t, (vP << 1) + (r ? 1 : 0), 3), Yw(t), el(t, n), el(t, ~n), n && t.pending_buf.set(t.window.subarray(e, e + n), t.pending), t.pending += n
    },
    TP = t => {
        En(t, Mw << 1, 3), Ar(t, Hp, Jr), EP(t)
    },
    BP = (t, e, n, r) => {
        let i, s, o = 0;
        t.level > 0 ? (t.strm.data_type === yP && (t.strm.data_type = CP(t)), mh(t, t.l_desc), mh(t, t.d_desc), o = NP(t), i = t.opt_len + 3 + 7 >>> 3, s = t.static_len + 3 + 7 >>> 3, s <= i && (i = s)) : i = s = n + 5, n + 4 <= i && e !== -1 ? Xw(t, e, n, r) : t.strategy === gP || s === i ? (En(t, (Mw << 1) + (r ? 1 : 0), 3), i1(t, Jr, Oa)) : (En(t, (bP << 1) + (r ? 1 : 0), 3), RP(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, o + 1), i1(t, t.dyn_ltree, t.dyn_dtree)), Zw(t), r && Yw(t)
    },
    IP = (t, e, n) => (t.pending_buf[t.sym_buf + t.sym_next++] = e, t.pending_buf[t.sym_buf + t.sym_next++] = e >> 8, t.pending_buf[t.sym_buf + t.sym_next++] = n, e === 0 ? t.dyn_ltree[n * 2]++ : (t.matches++, e--, t.dyn_ltree[($a[n] + Pl + 1) * 2]++, t.dyn_dtree[Qw(e) * 2]++), t.sym_next === t.sym_end);
var DP = OP,
    LP = Xw,
    MP = BP,
    FP = IP,
    UP = TP,
    HP = {
        _tr_init: DP,
        _tr_stored_block: LP,
        _tr_flush_block: MP,
        _tr_tally: FP,
        _tr_align: UP
    };
const zP = (t, e, n, r) => {
    let i = t & 65535 | 0,
        s = t >>> 16 & 65535 | 0,
        o = 0;
    for (; n !== 0;) {
        o = n > 2e3 ? 2e3 : n, n -= o;
        do i = i + e[r++] | 0, s = s + i | 0; while (--o);
        i %= 65521, s %= 65521
    }
    return i | s << 16 | 0
};
var tl = zP;
const jP = () => {
        let t, e = [];
        for (var n = 0; n < 256; n++) {
            t = n;
            for (var r = 0; r < 8; r++) t = t & 1 ? 3988292384 ^ t >>> 1 : t >>> 1;
            e[n] = t
        }
        return e
    },
    VP = new Uint32Array(jP()),
    GP = (t, e, n, r) => {
        const i = VP,
            s = r + n;
        t ^= -1;
        for (let o = r; o < s; o++) t = t >>> 8 ^ i[(t ^ e[o]) & 255];
        return t ^ -1
    };
var Xt = GP,
    Bs = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
    },
    zs = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
    };
const {
    _tr_init: WP,
    _tr_stored_block: gh,
    _tr_flush_block: QP,
    _tr_tally: Fi,
    _tr_align: JP
} = HP, {
    Z_NO_FLUSH: Ui,
    Z_PARTIAL_FLUSH: KP,
    Z_FULL_FLUSH: ZP,
    Z_FINISH: zn,
    Z_BLOCK: l1,
    Z_OK: tn,
    Z_STREAM_END: c1,
    Z_STREAM_ERROR: Rr,
    Z_DATA_ERROR: YP,
    Z_BUF_ERROR: id,
    Z_DEFAULT_COMPRESSION: XP,
    Z_FILTERED: qP,
    Z_HUFFMAN_ONLY: uc,
    Z_RLE: $P,
    Z_FIXED: eS,
    Z_DEFAULT_STRATEGY: tS,
    Z_UNKNOWN: nS,
    Z_DEFLATED: Xu
} = zs, rS = 9, iS = 15, sS = 8, oS = 29, aS = 256, yh = aS + 1 + oS, lS = 30, cS = 19, uS = 2 * yh + 1, fS = 15, tt = 3, Bi = 258, Cr = Bi + tt + 1, dS = 32, Uo = 42, jp = 57, vh = 69, bh = 73, wh = 91, xh = 103, vs = 113, ya = 666, gn = 1, Xo = 2, Is = 3, qo = 4, hS = 3, bs = (t, e) => (t.msg = Bs[e], e), u1 = t => t * 2 - (t > 4 ? 9 : 0), Oi = t => {
    let e = t.length;
    for (; --e >= 0;) t[e] = 0
}, pS = t => {
    let e, n, r, i = t.w_size;
    e = t.hash_size, r = e;
    do n = t.head[--r], t.head[r] = n >= i ? n - i : 0; while (--e);
    e = i, r = e;
    do n = t.prev[--r], t.prev[r] = n >= i ? n - i : 0; while (--e)
};
let mS = (t, e, n) => (e << t.hash_shift ^ n) & t.hash_mask,
    Hi = mS;
const Cn = t => {
        const e = t.state;
        let n = e.pending;
        n > t.avail_out && (n = t.avail_out), n !== 0 && (t.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + n), t.next_out), t.next_out += n, e.pending_out += n, t.total_out += n, t.avail_out -= n, e.pending -= n, e.pending === 0 && (e.pending_out = 0))
    },
    Tn = (t, e) => {
        QP(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, Cn(t.strm)
    },
    ut = (t, e) => {
        t.pending_buf[t.pending++] = e
    },
    ua = (t, e) => {
        t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = e & 255
    },
    Ah = (t, e, n, r) => {
        let i = t.avail_in;
        return i > r && (i = r), i === 0 ? 0 : (t.avail_in -= i, e.set(t.input.subarray(t.next_in, t.next_in + i), n), t.state.wrap === 1 ? t.adler = tl(t.adler, e, i, n) : t.state.wrap === 2 && (t.adler = Xt(t.adler, e, i, n)), t.next_in += i, t.total_in += i, i)
    },
    qw = (t, e) => {
        let n = t.max_chain_length,
            r = t.strstart,
            i, s, o = t.prev_length,
            a = t.nice_match;
        const c = t.strstart > t.w_size - Cr ? t.strstart - (t.w_size - Cr) : 0,
            l = t.window,
            u = t.w_mask,
            f = t.prev,
            d = t.strstart + Bi;
        let h = l[r + o - 1],
            p = l[r + o];
        t.prev_length >= t.good_match && (n >>= 2), a > t.lookahead && (a = t.lookahead);
        do
            if (i = e, !(l[i + o] !== p || l[i + o - 1] !== h || l[i] !== l[r] || l[++i] !== l[r + 1])) {
                r += 2, i++;
                do; while (l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && l[++r] === l[++i] && r < d);
                if (s = Bi - (d - r), r = d - Bi, s > o) {
                    if (t.match_start = e, o = s, s >= a) break;
                    h = l[r + o - 1], p = l[r + o]
                }
            }
        while ((e = f[e & u]) > c && --n !== 0);
        return o <= t.lookahead ? o : t.lookahead
    },
    Ho = t => {
        const e = t.w_size;
        let n, r, i;
        do {
            if (r = t.window_size - t.lookahead - t.strstart, t.strstart >= e + (e - Cr) && (t.window.set(t.window.subarray(e, e + e - r), 0), t.match_start -= e, t.strstart -= e, t.block_start -= e, t.insert > t.strstart && (t.insert = t.strstart), pS(t), r += e), t.strm.avail_in === 0) break;
            if (n = Ah(t.strm, t.window, t.strstart + t.lookahead, r), t.lookahead += n, t.lookahead + t.insert >= tt)
                for (i = t.strstart - t.insert, t.ins_h = t.window[i], t.ins_h = Hi(t, t.ins_h, t.window[i + 1]); t.insert && (t.ins_h = Hi(t, t.ins_h, t.window[i + tt - 1]), t.prev[i & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = i, i++, t.insert--, !(t.lookahead + t.insert < tt)););
        } while (t.lookahead < Cr && t.strm.avail_in !== 0)
    },
    $w = (t, e) => {
        let n = t.pending_buf_size - 5 > t.w_size ? t.w_size : t.pending_buf_size - 5,
            r, i, s, o = 0,
            a = t.strm.avail_in;
        do {
            if (r = 65535, s = t.bi_valid + 42 >> 3, t.strm.avail_out < s || (s = t.strm.avail_out - s, i = t.strstart - t.block_start, r > i + t.strm.avail_in && (r = i + t.strm.avail_in), r > s && (r = s), r < n && (r === 0 && e !== zn || e === Ui || r !== i + t.strm.avail_in))) break;
            o = e === zn && r === i + t.strm.avail_in ? 1 : 0, gh(t, 0, 0, o), t.pending_buf[t.pending - 4] = r, t.pending_buf[t.pending - 3] = r >> 8, t.pending_buf[t.pending - 2] = ~r, t.pending_buf[t.pending - 1] = ~r >> 8, Cn(t.strm), i && (i > r && (i = r), t.strm.output.set(t.window.subarray(t.block_start, t.block_start + i), t.strm.next_out), t.strm.next_out += i, t.strm.avail_out -= i, t.strm.total_out += i, t.block_start += i, r -= i), r && (Ah(t.strm, t.strm.output, t.strm.next_out, r), t.strm.next_out += r, t.strm.avail_out -= r, t.strm.total_out += r)
        } while (o === 0);
        return a -= t.strm.avail_in, a && (a >= t.w_size ? (t.matches = 2, t.window.set(t.strm.input.subarray(t.strm.next_in - t.w_size, t.strm.next_in), 0), t.strstart = t.w_size, t.insert = t.strstart) : (t.window_size - t.strstart <= a && (t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, t.insert > t.strstart && (t.insert = t.strstart)), t.window.set(t.strm.input.subarray(t.strm.next_in - a, t.strm.next_in), t.strstart), t.strstart += a, t.insert += a > t.w_size - t.insert ? t.w_size - t.insert : a), t.block_start = t.strstart), t.high_water < t.strstart && (t.high_water = t.strstart), o ? qo : e !== Ui && e !== zn && t.strm.avail_in === 0 && t.strstart === t.block_start ? Xo : (s = t.window_size - t.strstart, t.strm.avail_in > s && t.block_start >= t.w_size && (t.block_start -= t.w_size, t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, s += t.w_size, t.insert > t.strstart && (t.insert = t.strstart)), s > t.strm.avail_in && (s = t.strm.avail_in), s && (Ah(t.strm, t.window, t.strstart, s), t.strstart += s, t.insert += s > t.w_size - t.insert ? t.w_size - t.insert : s), t.high_water < t.strstart && (t.high_water = t.strstart), s = t.bi_valid + 42 >> 3, s = t.pending_buf_size - s > 65535 ? 65535 : t.pending_buf_size - s, n = s > t.w_size ? t.w_size : s, i = t.strstart - t.block_start, (i >= n || (i || e === zn) && e !== Ui && t.strm.avail_in === 0 && i <= s) && (r = i > s ? s : i, o = e === zn && t.strm.avail_in === 0 && r === i ? 1 : 0, gh(t, t.block_start, r, o), t.block_start += r, Cn(t.strm)), o ? Is : gn)
    },
    sd = (t, e) => {
        let n, r;
        for (;;) {
            if (t.lookahead < Cr) {
                if (Ho(t), t.lookahead < Cr && e === Ui) return gn;
                if (t.lookahead === 0) break
            }
            if (n = 0, t.lookahead >= tt && (t.ins_h = Hi(t, t.ins_h, t.window[t.strstart + tt - 1]), n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), n !== 0 && t.strstart - n <= t.w_size - Cr && (t.match_length = qw(t, n)), t.match_length >= tt)
                if (r = Fi(t, t.strstart - t.match_start, t.match_length - tt), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= tt) {
                    t.match_length--;
                    do t.strstart++, t.ins_h = Hi(t, t.ins_h, t.window[t.strstart + tt - 1]), n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart; while (--t.match_length !== 0);
                    t.strstart++
                } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = Hi(t, t.ins_h, t.window[t.strstart + 1]);
            else r = Fi(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
            if (r && (Tn(t, !1), t.strm.avail_out === 0)) return gn
        }
        return t.insert = t.strstart < tt - 1 ? t.strstart : tt - 1, e === zn ? (Tn(t, !0), t.strm.avail_out === 0 ? Is : qo) : t.sym_next && (Tn(t, !1), t.strm.avail_out === 0) ? gn : Xo
    },
    no = (t, e) => {
        let n, r, i;
        for (;;) {
            if (t.lookahead < Cr) {
                if (Ho(t), t.lookahead < Cr && e === Ui) return gn;
                if (t.lookahead === 0) break
            }
            if (n = 0, t.lookahead >= tt && (t.ins_h = Hi(t, t.ins_h, t.window[t.strstart + tt - 1]), n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = tt - 1, n !== 0 && t.prev_length < t.max_lazy_match && t.strstart - n <= t.w_size - Cr && (t.match_length = qw(t, n), t.match_length <= 5 && (t.strategy === qP || t.match_length === tt && t.strstart - t.match_start > 4096) && (t.match_length = tt - 1)), t.prev_length >= tt && t.match_length <= t.prev_length) {
                i = t.strstart + t.lookahead - tt, r = Fi(t, t.strstart - 1 - t.prev_match, t.prev_length - tt), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
                do ++t.strstart <= i && (t.ins_h = Hi(t, t.ins_h, t.window[t.strstart + tt - 1]), n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart); while (--t.prev_length !== 0);
                if (t.match_available = 0, t.match_length = tt - 1, t.strstart++, r && (Tn(t, !1), t.strm.avail_out === 0)) return gn
            } else if (t.match_available) {
                if (r = Fi(t, 0, t.window[t.strstart - 1]), r && Tn(t, !1), t.strstart++, t.lookahead--, t.strm.avail_out === 0) return gn
            } else t.match_available = 1, t.strstart++, t.lookahead--
        }
        return t.match_available && (r = Fi(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < tt - 1 ? t.strstart : tt - 1, e === zn ? (Tn(t, !0), t.strm.avail_out === 0 ? Is : qo) : t.sym_next && (Tn(t, !1), t.strm.avail_out === 0) ? gn : Xo
    },
    gS = (t, e) => {
        let n, r, i, s;
        const o = t.window;
        for (;;) {
            if (t.lookahead <= Bi) {
                if (Ho(t), t.lookahead <= Bi && e === Ui) return gn;
                if (t.lookahead === 0) break
            }
            if (t.match_length = 0, t.lookahead >= tt && t.strstart > 0 && (i = t.strstart - 1, r = o[i], r === o[++i] && r === o[++i] && r === o[++i])) {
                s = t.strstart + Bi;
                do; while (r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && r === o[++i] && i < s);
                t.match_length = Bi - (s - i), t.match_length > t.lookahead && (t.match_length = t.lookahead)
            }
            if (t.match_length >= tt ? (n = Fi(t, 1, t.match_length - tt), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (n = Fi(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), n && (Tn(t, !1), t.strm.avail_out === 0)) return gn
        }
        return t.insert = 0, e === zn ? (Tn(t, !0), t.strm.avail_out === 0 ? Is : qo) : t.sym_next && (Tn(t, !1), t.strm.avail_out === 0) ? gn : Xo
    },
    yS = (t, e) => {
        let n;
        for (;;) {
            if (t.lookahead === 0 && (Ho(t), t.lookahead === 0)) {
                if (e === Ui) return gn;
                break
            }
            if (t.match_length = 0, n = Fi(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, n && (Tn(t, !1), t.strm.avail_out === 0)) return gn
        }
        return t.insert = 0, e === zn ? (Tn(t, !0), t.strm.avail_out === 0 ? Is : qo) : t.sym_next && (Tn(t, !1), t.strm.avail_out === 0) ? gn : Xo
    };

function gr(t, e, n, r, i) {
    this.good_length = t, this.max_lazy = e, this.nice_length = n, this.max_chain = r, this.func = i
}
const va = [new gr(0, 0, 0, 0, $w), new gr(4, 4, 8, 4, sd), new gr(4, 5, 16, 8, sd), new gr(4, 6, 32, 32, sd), new gr(4, 4, 16, 16, no), new gr(8, 16, 32, 32, no), new gr(8, 16, 128, 128, no), new gr(8, 32, 128, 256, no), new gr(32, 128, 258, 1024, no), new gr(32, 258, 258, 4096, no)],
    vS = t => {
        t.window_size = 2 * t.w_size, Oi(t.head), t.max_lazy_match = va[t.level].max_lazy, t.good_match = va[t.level].good_length, t.nice_match = va[t.level].nice_length, t.max_chain_length = va[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = tt - 1, t.match_available = 0, t.ins_h = 0
    };

function bS() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Xu, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(uS * 2), this.dyn_dtree = new Uint16Array((2 * lS + 1) * 2), this.bl_tree = new Uint16Array((2 * cS + 1) * 2), Oi(this.dyn_ltree), Oi(this.dyn_dtree), Oi(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(fS + 1), this.heap = new Uint16Array(2 * yh + 1), Oi(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * yh + 1), Oi(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
}
const Sl = t => {
        if (!t) return 1;
        const e = t.state;
        return !e || e.strm !== t || e.status !== Uo && e.status !== jp && e.status !== vh && e.status !== bh && e.status !== wh && e.status !== xh && e.status !== vs && e.status !== ya ? 1 : 0
    },
    e2 = t => {
        if (Sl(t)) return bs(t, Rr);
        t.total_in = t.total_out = 0, t.data_type = nS;
        const e = t.state;
        return e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap === 2 ? jp : e.wrap ? Uo : vs, t.adler = e.wrap === 2 ? 0 : 1, e.last_flush = -2, WP(e), tn
    },
    t2 = t => {
        const e = e2(t);
        return e === tn && vS(t.state), e
    },
    wS = (t, e) => Sl(t) || t.state.wrap !== 2 ? Rr : (t.state.gzhead = e, tn),
    n2 = (t, e, n, r, i, s) => {
        if (!t) return Rr;
        let o = 1;
        if (e === XP && (e = 6), r < 0 ? (o = 0, r = -r) : r > 15 && (o = 2, r -= 16), i < 1 || i > rS || n !== Xu || r < 8 || r > 15 || e < 0 || e > 9 || s < 0 || s > eS || r === 8 && o !== 1) return bs(t, Rr);
        r === 8 && (r = 9);
        const a = new bS;
        return t.state = a, a.strm = t, a.status = Uo, a.wrap = o, a.gzhead = null, a.w_bits = r, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = i + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + tt - 1) / tt), a.window = new Uint8Array(a.w_size * 2), a.head = new Uint16Array(a.hash_size), a.prev = new Uint16Array(a.w_size), a.lit_bufsize = 1 << i + 6, a.pending_buf_size = a.lit_bufsize * 4, a.pending_buf = new Uint8Array(a.pending_buf_size), a.sym_buf = a.lit_bufsize, a.sym_end = (a.lit_bufsize - 1) * 3, a.level = e, a.strategy = s, a.method = n, t2(t)
    },
    xS = (t, e) => n2(t, e, Xu, iS, sS, tS),
    AS = (t, e) => {
        if (Sl(t) || e > l1 || e < 0) return t ? bs(t, Rr) : Rr;
        const n = t.state;
        if (!t.output || t.avail_in !== 0 && !t.input || n.status === ya && e !== zn) return bs(t, t.avail_out === 0 ? id : Rr);
        const r = n.last_flush;
        if (n.last_flush = e, n.pending !== 0) {
            if (Cn(t), t.avail_out === 0) return n.last_flush = -1, tn
        } else if (t.avail_in === 0 && u1(e) <= u1(r) && e !== zn) return bs(t, id);
        if (n.status === ya && t.avail_in !== 0) return bs(t, id);
        if (n.status === Uo && n.wrap === 0 && (n.status = vs), n.status === Uo) {
            let i = Xu + (n.w_bits - 8 << 4) << 8,
                s = -1;
            if (n.strategy >= uc || n.level < 2 ? s = 0 : n.level < 6 ? s = 1 : n.level === 6 ? s = 2 : s = 3, i |= s << 6, n.strstart !== 0 && (i |= dS), i += 31 - i % 31, ua(n, i), n.strstart !== 0 && (ua(n, t.adler >>> 16), ua(n, t.adler & 65535)), t.adler = 1, n.status = vs, Cn(t), n.pending !== 0) return n.last_flush = -1, tn
        }
        if (n.status === jp) {
            if (t.adler = 0, ut(n, 31), ut(n, 139), ut(n, 8), n.gzhead) ut(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)), ut(n, n.gzhead.time & 255), ut(n, n.gzhead.time >> 8 & 255), ut(n, n.gzhead.time >> 16 & 255), ut(n, n.gzhead.time >> 24 & 255), ut(n, n.level === 9 ? 2 : n.strategy >= uc || n.level < 2 ? 4 : 0), ut(n, n.gzhead.os & 255), n.gzhead.extra && n.gzhead.extra.length && (ut(n, n.gzhead.extra.length & 255), ut(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (t.adler = Xt(t.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = vh;
            else if (ut(n, 0), ut(n, 0), ut(n, 0), ut(n, 0), ut(n, 0), ut(n, n.level === 9 ? 2 : n.strategy >= uc || n.level < 2 ? 4 : 0), ut(n, hS), n.status = vs, Cn(t), n.pending !== 0) return n.last_flush = -1, tn
        }
        if (n.status === vh) {
            if (n.gzhead.extra) {
                let i = n.pending,
                    s = (n.gzhead.extra.length & 65535) - n.gzindex;
                for (; n.pending + s > n.pending_buf_size;) {
                    let a = n.pending_buf_size - n.pending;
                    if (n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex, n.gzindex + a), n.pending), n.pending = n.pending_buf_size, n.gzhead.hcrc && n.pending > i && (t.adler = Xt(t.adler, n.pending_buf, n.pending - i, i)), n.gzindex += a, Cn(t), n.pending !== 0) return n.last_flush = -1, tn;
                    i = 0, s -= a
                }
                let o = new Uint8Array(n.gzhead.extra);
                n.pending_buf.set(o.subarray(n.gzindex, n.gzindex + s), n.pending), n.pending += s, n.gzhead.hcrc && n.pending > i && (t.adler = Xt(t.adler, n.pending_buf, n.pending - i, i)), n.gzindex = 0
            }
            n.status = bh
        }
        if (n.status === bh) {
            if (n.gzhead.name) {
                let i = n.pending,
                    s;
                do {
                    if (n.pending === n.pending_buf_size) {
                        if (n.gzhead.hcrc && n.pending > i && (t.adler = Xt(t.adler, n.pending_buf, n.pending - i, i)), Cn(t), n.pending !== 0) return n.last_flush = -1, tn;
                        i = 0
                    }
                    n.gzindex < n.gzhead.name.length ? s = n.gzhead.name.charCodeAt(n.gzindex++) & 255 : s = 0, ut(n, s)
                } while (s !== 0);
                n.gzhead.hcrc && n.pending > i && (t.adler = Xt(t.adler, n.pending_buf, n.pending - i, i)), n.gzindex = 0
            }
            n.status = wh
        }
        if (n.status === wh) {
            if (n.gzhead.comment) {
                let i = n.pending,
                    s;
                do {
                    if (n.pending === n.pending_buf_size) {
                        if (n.gzhead.hcrc && n.pending > i && (t.adler = Xt(t.adler, n.pending_buf, n.pending - i, i)), Cn(t), n.pending !== 0) return n.last_flush = -1, tn;
                        i = 0
                    }
                    n.gzindex < n.gzhead.comment.length ? s = n.gzhead.comment.charCodeAt(n.gzindex++) & 255 : s = 0, ut(n, s)
                } while (s !== 0);
                n.gzhead.hcrc && n.pending > i && (t.adler = Xt(t.adler, n.pending_buf, n.pending - i, i))
            }
            n.status = xh
        }
        if (n.status === xh) {
            if (n.gzhead.hcrc) {
                if (n.pending + 2 > n.pending_buf_size && (Cn(t), n.pending !== 0)) return n.last_flush = -1, tn;
                ut(n, t.adler & 255), ut(n, t.adler >> 8 & 255), t.adler = 0
            }
            if (n.status = vs, Cn(t), n.pending !== 0) return n.last_flush = -1, tn
        }
        if (t.avail_in !== 0 || n.lookahead !== 0 || e !== Ui && n.status !== ya) {
            let i = n.level === 0 ? $w(n, e) : n.strategy === uc ? yS(n, e) : n.strategy === $P ? gS(n, e) : va[n.level].func(n, e);
            if ((i === Is || i === qo) && (n.status = ya), i === gn || i === Is) return t.avail_out === 0 && (n.last_flush = -1), tn;
            if (i === Xo && (e === KP ? JP(n) : e !== l1 && (gh(n, 0, 0, !1), e === ZP && (Oi(n.head), n.lookahead === 0 && (n.strstart = 0, n.block_start = 0, n.insert = 0))), Cn(t), t.avail_out === 0)) return n.last_flush = -1, tn
        }
        return e !== zn ? tn : n.wrap <= 0 ? c1 : (n.wrap === 2 ? (ut(n, t.adler & 255), ut(n, t.adler >> 8 & 255), ut(n, t.adler >> 16 & 255), ut(n, t.adler >> 24 & 255), ut(n, t.total_in & 255), ut(n, t.total_in >> 8 & 255), ut(n, t.total_in >> 16 & 255), ut(n, t.total_in >> 24 & 255)) : (ua(n, t.adler >>> 16), ua(n, t.adler & 65535)), Cn(t), n.wrap > 0 && (n.wrap = -n.wrap), n.pending !== 0 ? tn : c1)
    },
    kS = t => {
        if (Sl(t)) return Rr;
        const e = t.state.status;
        return t.state = null, e === vs ? bs(t, YP) : tn
    },
    _S = (t, e) => {
        let n = e.length;
        if (Sl(t)) return Rr;
        const r = t.state,
            i = r.wrap;
        if (i === 2 || i === 1 && r.status !== Uo || r.lookahead) return Rr;
        if (i === 1 && (t.adler = tl(t.adler, e, n, 0)), r.wrap = 0, n >= r.w_size) {
            i === 0 && (Oi(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0);
            let c = new Uint8Array(r.w_size);
            c.set(e.subarray(n - r.w_size, n), 0), e = c, n = r.w_size
        }
        const s = t.avail_in,
            o = t.next_in,
            a = t.input;
        for (t.avail_in = n, t.next_in = 0, t.input = e, Ho(r); r.lookahead >= tt;) {
            let c = r.strstart,
                l = r.lookahead - (tt - 1);
            do r.ins_h = Hi(r, r.ins_h, r.window[c + tt - 1]), r.prev[c & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = c, c++; while (--l);
            r.strstart = c, r.lookahead = tt - 1, Ho(r)
        }
        return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = tt - 1, r.match_available = 0, t.next_in = o, t.input = a, t.avail_in = s, r.wrap = i, tn
    };
var ES = xS,
    PS = n2,
    SS = t2,
    NS = e2,
    RS = wS,
    CS = AS,
    OS = kS,
    TS = _S,
    BS = "pako deflate (from Nodeca project)",
    Ta = {
        deflateInit: ES,
        deflateInit2: PS,
        deflateReset: SS,
        deflateResetKeep: NS,
        deflateSetHeader: RS,
        deflate: CS,
        deflateEnd: OS,
        deflateSetDictionary: TS,
        deflateInfo: BS
    };
const IS = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
var DS = function(t) {
        const e = Array.prototype.slice.call(arguments, 1);
        for (; e.length;) {
            const n = e.shift();
            if (n) {
                if (typeof n != "object") throw new TypeError(n + "must be non-object");
                for (const r in n) IS(n, r) && (t[r] = n[r])
            }
        }
        return t
    },
    LS = t => {
        let e = 0;
        for (let r = 0, i = t.length; r < i; r++) e += t[r].length;
        const n = new Uint8Array(e);
        for (let r = 0, i = 0, s = t.length; r < s; r++) {
            let o = t[r];
            n.set(o, i), i += o.length
        }
        return n
    },
    qu = {
        assign: DS,
        flattenChunks: LS
    };
let r2 = !0;
try {
    String.fromCharCode.apply(null, new Uint8Array(1))
} catch {
    r2 = !1
}
const nl = new Uint8Array(256);
for (let t = 0; t < 256; t++) nl[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1;
nl[254] = nl[254] = 1;
var MS = t => {
    if (typeof TextEncoder == "function" && TextEncoder.prototype.encode) return new TextEncoder().encode(t);
    let e, n, r, i, s, o = t.length,
        a = 0;
    for (i = 0; i < o; i++) n = t.charCodeAt(i), (n & 64512) === 55296 && i + 1 < o && (r = t.charCodeAt(i + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), i++)), a += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
    for (e = new Uint8Array(a), s = 0, i = 0; s < a; i++) n = t.charCodeAt(i), (n & 64512) === 55296 && i + 1 < o && (r = t.charCodeAt(i + 1), (r & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (r - 56320), i++)), n < 128 ? e[s++] = n : n < 2048 ? (e[s++] = 192 | n >>> 6, e[s++] = 128 | n & 63) : n < 65536 ? (e[s++] = 224 | n >>> 12, e[s++] = 128 | n >>> 6 & 63, e[s++] = 128 | n & 63) : (e[s++] = 240 | n >>> 18, e[s++] = 128 | n >>> 12 & 63, e[s++] = 128 | n >>> 6 & 63, e[s++] = 128 | n & 63);
    return e
};
const FS = (t, e) => {
    if (e < 65534 && t.subarray && r2) return String.fromCharCode.apply(null, t.length === e ? t : t.subarray(0, e));
    let n = "";
    for (let r = 0; r < e; r++) n += String.fromCharCode(t[r]);
    return n
};
var US = (t, e) => {
        const n = e || t.length;
        if (typeof TextDecoder == "function" && TextDecoder.prototype.decode) return new TextDecoder().decode(t.subarray(0, e));
        let r, i;
        const s = new Array(n * 2);
        for (i = 0, r = 0; r < n;) {
            let o = t[r++];
            if (o < 128) {
                s[i++] = o;
                continue
            }
            let a = nl[o];
            if (a > 4) {
                s[i++] = 65533, r += a - 1;
                continue
            }
            for (o &= a === 2 ? 31 : a === 3 ? 15 : 7; a > 1 && r < n;) o = o << 6 | t[r++] & 63, a--;
            if (a > 1) {
                s[i++] = 65533;
                continue
            }
            o < 65536 ? s[i++] = o : (o -= 65536, s[i++] = 55296 | o >> 10 & 1023, s[i++] = 56320 | o & 1023)
        }
        return FS(s, i)
    },
    HS = (t, e) => {
        e = e || t.length, e > t.length && (e = t.length);
        let n = e - 1;
        for (; n >= 0 && (t[n] & 192) === 128;) n--;
        return n < 0 || n === 0 ? e : n + nl[t[n]] > e ? n : e
    },
    rl = {
        string2buf: MS,
        buf2string: US,
        utf8border: HS
    };

function zS() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
}
var i2 = zS;
const s2 = Object.prototype.toString,
    {
        Z_NO_FLUSH: jS,
        Z_SYNC_FLUSH: VS,
        Z_FULL_FLUSH: GS,
        Z_FINISH: WS,
        Z_OK: fu,
        Z_STREAM_END: QS,
        Z_DEFAULT_COMPRESSION: JS,
        Z_DEFAULT_STRATEGY: KS,
        Z_DEFLATED: ZS
    } = zs;

function Nl(t) {
    this.options = qu.assign({
        level: JS,
        method: ZS,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: KS
    }, t || {});
    let e = this.options;
    e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new i2, this.strm.avail_out = 0;
    let n = Ta.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
    if (n !== fu) throw new Error(Bs[n]);
    if (e.header && Ta.deflateSetHeader(this.strm, e.header), e.dictionary) {
        let r;
        if (typeof e.dictionary == "string" ? r = rl.string2buf(e.dictionary) : s2.call(e.dictionary) === "[object ArrayBuffer]" ? r = new Uint8Array(e.dictionary) : r = e.dictionary, n = Ta.deflateSetDictionary(this.strm, r), n !== fu) throw new Error(Bs[n]);
        this._dict_set = !0
    }
}
Nl.prototype.push = function(t, e) {
    const n = this.strm,
        r = this.options.chunkSize;
    let i, s;
    if (this.ended) return !1;
    for (e === ~~e ? s = e : s = e === !0 ? WS : jS, typeof t == "string" ? n.input = rl.string2buf(t) : s2.call(t) === "[object ArrayBuffer]" ? n.input = new Uint8Array(t) : n.input = t, n.next_in = 0, n.avail_in = n.input.length;;) {
        if (n.avail_out === 0 && (n.output = new Uint8Array(r), n.next_out = 0, n.avail_out = r), (s === VS || s === GS) && n.avail_out <= 6) {
            this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
            continue
        }
        if (i = Ta.deflate(n, s), i === QS) return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)), i = Ta.deflateEnd(this.strm), this.onEnd(i), this.ended = !0, i === fu;
        if (n.avail_out === 0) {
            this.onData(n.output);
            continue
        }
        if (s > 0 && n.next_out > 0) {
            this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
            continue
        }
        if (n.avail_in === 0) break
    }
    return !0
};
Nl.prototype.onData = function(t) {
    this.chunks.push(t)
};
Nl.prototype.onEnd = function(t) {
    t === fu && (this.result = qu.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
};

function Vp(t, e) {
    const n = new Nl(e);
    if (n.push(t, !0), n.err) throw n.msg || Bs[n.err];
    return n.result
}

function YS(t, e) {
    return e = e || {}, e.raw = !0, Vp(t, e)
}

function XS(t, e) {
    return e = e || {}, e.gzip = !0, Vp(t, e)
}
var qS = Nl,
    $S = Vp,
    eN = YS,
    tN = XS,
    nN = zs,
    rN = {
        Deflate: qS,
        deflate: $S,
        deflateRaw: eN,
        gzip: tN,
        constants: nN
    };
const fc = 16209,
    iN = 16191;
var sN = function(e, n) {
    let r, i, s, o, a, c, l, u, f, d, h, p, g, b, x, w, O, N, U, H, M, y, v, A;
    const E = e.state;
    r = e.next_in, v = e.input, i = r + (e.avail_in - 5), s = e.next_out, A = e.output, o = s - (n - e.avail_out), a = s + (e.avail_out - 257), c = E.dmax, l = E.wsize, u = E.whave, f = E.wnext, d = E.window, h = E.hold, p = E.bits, g = E.lencode, b = E.distcode, x = (1 << E.lenbits) - 1, w = (1 << E.distbits) - 1;
    e: do {
        p < 15 && (h += v[r++] << p, p += 8, h += v[r++] << p, p += 8), O = g[h & x];
        t: for (;;) {
            if (N = O >>> 24, h >>>= N, p -= N, N = O >>> 16 & 255, N === 0) A[s++] = O & 65535;
            else if (N & 16) {
                U = O & 65535, N &= 15, N && (p < N && (h += v[r++] << p, p += 8), U += h & (1 << N) - 1, h >>>= N, p -= N), p < 15 && (h += v[r++] << p, p += 8, h += v[r++] << p, p += 8), O = b[h & w];
                n: for (;;) {
                    if (N = O >>> 24, h >>>= N, p -= N, N = O >>> 16 & 255, N & 16) {
                        if (H = O & 65535, N &= 15, p < N && (h += v[r++] << p, p += 8, p < N && (h += v[r++] << p, p += 8)), H += h & (1 << N) - 1, H > c) {
                            e.msg = "invalid distance too far back", E.mode = fc;
                            break e
                        }
                        if (h >>>= N, p -= N, N = s - o, H > N) {
                            if (N = H - N, N > u && E.sane) {
                                e.msg = "invalid distance too far back", E.mode = fc;
                                break e
                            }
                            if (M = 0, y = d, f === 0) {
                                if (M += l - N, N < U) {
                                    U -= N;
                                    do A[s++] = d[M++]; while (--N);
                                    M = s - H, y = A
                                }
                            } else if (f < N) {
                                if (M += l + f - N, N -= f, N < U) {
                                    U -= N;
                                    do A[s++] = d[M++]; while (--N);
                                    if (M = 0, f < U) {
                                        N = f, U -= N;
                                        do A[s++] = d[M++]; while (--N);
                                        M = s - H, y = A
                                    }
                                }
                            } else if (M += f - N, N < U) {
                                U -= N;
                                do A[s++] = d[M++]; while (--N);
                                M = s - H, y = A
                            }
                            for (; U > 2;) A[s++] = y[M++], A[s++] = y[M++], A[s++] = y[M++], U -= 3;
                            U && (A[s++] = y[M++], U > 1 && (A[s++] = y[M++]))
                        } else {
                            M = s - H;
                            do A[s++] = A[M++], A[s++] = A[M++], A[s++] = A[M++], U -= 3; while (U > 2);
                            U && (A[s++] = A[M++], U > 1 && (A[s++] = A[M++]))
                        }
                    } else if (N & 64) {
                        e.msg = "invalid distance code", E.mode = fc;
                        break e
                    } else {
                        O = b[(O & 65535) + (h & (1 << N) - 1)];
                        continue n
                    }
                    break
                }
            } else if (N & 64)
                if (N & 32) {
                    E.mode = iN;
                    break e
                } else {
                    e.msg = "invalid literal/length code", E.mode = fc;
                    break e
                }
            else {
                O = g[(O & 65535) + (h & (1 << N) - 1)];
                continue t
            }
            break
        }
    } while (r < i && s < a);
    U = p >> 3, r -= U, p -= U << 3, h &= (1 << p) - 1, e.next_in = r, e.next_out = s, e.avail_in = r < i ? 5 + (i - r) : 5 - (r - i), e.avail_out = s < a ? 257 + (a - s) : 257 - (s - a), E.hold = h, E.bits = p
};
const ro = 15,
    f1 = 852,
    d1 = 592,
    h1 = 0,
    od = 1,
    p1 = 2,
    oN = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
    aN = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
    lN = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
    cN = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]),
    uN = (t, e, n, r, i, s, o, a) => {
        const c = a.bits;
        let l = 0,
            u = 0,
            f = 0,
            d = 0,
            h = 0,
            p = 0,
            g = 0,
            b = 0,
            x = 0,
            w = 0,
            O, N, U, H, M, y = null,
            v;
        const A = new Uint16Array(ro + 1),
            E = new Uint16Array(ro + 1);
        let P = null,
            R, F, _;
        for (l = 0; l <= ro; l++) A[l] = 0;
        for (u = 0; u < r; u++) A[e[n + u]]++;
        for (h = c, d = ro; d >= 1 && A[d] === 0; d--);
        if (h > d && (h = d), d === 0) return i[s++] = 1 << 24 | 64 << 16 | 0, i[s++] = 1 << 24 | 64 << 16 | 0, a.bits = 1, 0;
        for (f = 1; f < d && A[f] === 0; f++);
        for (h < f && (h = f), b = 1, l = 1; l <= ro; l++)
            if (b <<= 1, b -= A[l], b < 0) return -1;
        if (b > 0 && (t === h1 || d !== 1)) return -1;
        for (E[1] = 0, l = 1; l < ro; l++) E[l + 1] = E[l] + A[l];
        for (u = 0; u < r; u++) e[n + u] !== 0 && (o[E[e[n + u]]++] = u);
        if (t === h1 ? (y = P = o, v = 20) : t === od ? (y = oN, P = aN, v = 257) : (y = lN, P = cN, v = 0), w = 0, u = 0, l = f, M = s, p = h, g = 0, U = -1, x = 1 << h, H = x - 1, t === od && x > f1 || t === p1 && x > d1) return 1;
        for (;;) {
            R = l - g, o[u] + 1 < v ? (F = 0, _ = o[u]) : o[u] >= v ? (F = P[o[u] - v], _ = y[o[u] - v]) : (F = 32 + 64, _ = 0), O = 1 << l - g, N = 1 << p, f = N;
            do N -= O, i[M + (w >> g) + N] = R << 24 | F << 16 | _ | 0; while (N !== 0);
            for (O = 1 << l - 1; w & O;) O >>= 1;
            if (O !== 0 ? (w &= O - 1, w += O) : w = 0, u++, --A[l] === 0) {
                if (l === d) break;
                l = e[n + o[u]]
            }
            if (l > h && (w & H) !== U) {
                for (g === 0 && (g = h), M += f, p = l - g, b = 1 << p; p + g < d && (b -= A[p + g], !(b <= 0));) p++, b <<= 1;
                if (x += 1 << p, t === od && x > f1 || t === p1 && x > d1) return 1;
                U = w & H, i[U] = h << 24 | p << 16 | M - s | 0
            }
        }
        return w !== 0 && (i[M + w] = l - g << 24 | 64 << 16 | 0), a.bits = h, 0
    };
var Ba = uN;
const fN = 0,
    o2 = 1,
    a2 = 2,
    {
        Z_FINISH: m1,
        Z_BLOCK: dN,
        Z_TREES: dc,
        Z_OK: Ds,
        Z_STREAM_END: hN,
        Z_NEED_DICT: pN,
        Z_STREAM_ERROR: qn,
        Z_DATA_ERROR: l2,
        Z_MEM_ERROR: c2,
        Z_BUF_ERROR: mN,
        Z_DEFLATED: g1
    } = zs,
    $u = 16180,
    y1 = 16181,
    v1 = 16182,
    b1 = 16183,
    w1 = 16184,
    x1 = 16185,
    A1 = 16186,
    k1 = 16187,
    _1 = 16188,
    E1 = 16189,
    du = 16190,
    jr = 16191,
    ad = 16192,
    P1 = 16193,
    ld = 16194,
    S1 = 16195,
    N1 = 16196,
    R1 = 16197,
    C1 = 16198,
    hc = 16199,
    pc = 16200,
    O1 = 16201,
    T1 = 16202,
    B1 = 16203,
    I1 = 16204,
    D1 = 16205,
    cd = 16206,
    L1 = 16207,
    M1 = 16208,
    Et = 16209,
    u2 = 16210,
    f2 = 16211,
    gN = 852,
    yN = 592,
    vN = 15,
    bN = vN,
    F1 = t => (t >>> 24 & 255) + (t >>> 8 & 65280) + ((t & 65280) << 8) + ((t & 255) << 24);

function wN() {
    this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
}
const js = t => {
        if (!t) return 1;
        const e = t.state;
        return !e || e.strm !== t || e.mode < $u || e.mode > f2 ? 1 : 0
    },
    d2 = t => {
        if (js(t)) return qn;
        const e = t.state;
        return t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = e.wrap & 1), e.mode = $u, e.last = 0, e.havedict = 0, e.flags = -1, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Int32Array(gN), e.distcode = e.distdyn = new Int32Array(yN), e.sane = 1, e.back = -1, Ds
    },
    h2 = t => {
        if (js(t)) return qn;
        const e = t.state;
        return e.wsize = 0, e.whave = 0, e.wnext = 0, d2(t)
    },
    p2 = (t, e) => {
        let n;
        if (js(t)) return qn;
        const r = t.state;
        return e < 0 ? (n = 0, e = -e) : (n = (e >> 4) + 5, e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? qn : (r.window !== null && r.wbits !== e && (r.window = null), r.wrap = n, r.wbits = e, h2(t))
    },
    m2 = (t, e) => {
        if (!t) return qn;
        const n = new wN;
        t.state = n, n.strm = t, n.window = null, n.mode = $u;
        const r = p2(t, e);
        return r !== Ds && (t.state = null), r
    },
    xN = t => m2(t, bN);
let U1 = !0,
    ud, fd;
const AN = t => {
        if (U1) {
            ud = new Int32Array(512), fd = new Int32Array(32);
            let e = 0;
            for (; e < 144;) t.lens[e++] = 8;
            for (; e < 256;) t.lens[e++] = 9;
            for (; e < 280;) t.lens[e++] = 7;
            for (; e < 288;) t.lens[e++] = 8;
            for (Ba(o2, t.lens, 0, 288, ud, 0, t.work, {
                    bits: 9
                }), e = 0; e < 32;) t.lens[e++] = 5;
            Ba(a2, t.lens, 0, 32, fd, 0, t.work, {
                bits: 5
            }), U1 = !1
        }
        t.lencode = ud, t.lenbits = 9, t.distcode = fd, t.distbits = 5
    },
    g2 = (t, e, n, r) => {
        let i;
        const s = t.state;
        return s.window === null && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new Uint8Array(s.wsize)), r >= s.wsize ? (s.window.set(e.subarray(n - s.wsize, n), 0), s.wnext = 0, s.whave = s.wsize) : (i = s.wsize - s.wnext, i > r && (i = r), s.window.set(e.subarray(n - r, n - r + i), s.wnext), r -= i, r ? (s.window.set(e.subarray(n - r, n), 0), s.wnext = r, s.whave = s.wsize) : (s.wnext += i, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += i))), 0
    },
    kN = (t, e) => {
        let n, r, i, s, o, a, c, l, u, f, d, h, p, g, b = 0,
            x, w, O, N, U, H, M, y;
        const v = new Uint8Array(4);
        let A, E;
        const P = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        if (js(t) || !t.output || !t.input && t.avail_in !== 0) return qn;
        n = t.state, n.mode === jr && (n.mode = ad), o = t.next_out, i = t.output, c = t.avail_out, s = t.next_in, r = t.input, a = t.avail_in, l = n.hold, u = n.bits, f = a, d = c, y = Ds;
        e: for (;;) switch (n.mode) {
            case $u:
                if (n.wrap === 0) {
                    n.mode = ad;
                    break
                }
                for (; u < 16;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                if (n.wrap & 2 && l === 35615) {
                    n.wbits === 0 && (n.wbits = 15), n.check = 0, v[0] = l & 255, v[1] = l >>> 8 & 255, n.check = Xt(n.check, v, 2, 0), l = 0, u = 0, n.mode = y1;
                    break
                }
                if (n.head && (n.head.done = !1), !(n.wrap & 1) || (((l & 255) << 8) + (l >> 8)) % 31) {
                    t.msg = "incorrect header check", n.mode = Et;
                    break
                }
                if ((l & 15) !== g1) {
                    t.msg = "unknown compression method", n.mode = Et;
                    break
                }
                if (l >>>= 4, u -= 4, M = (l & 15) + 8, n.wbits === 0 && (n.wbits = M), M > 15 || M > n.wbits) {
                    t.msg = "invalid window size", n.mode = Et;
                    break
                }
                n.dmax = 1 << n.wbits, n.flags = 0, t.adler = n.check = 1, n.mode = l & 512 ? E1 : jr, l = 0, u = 0;
                break;
            case y1:
                for (; u < 16;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                if (n.flags = l, (n.flags & 255) !== g1) {
                    t.msg = "unknown compression method", n.mode = Et;
                    break
                }
                if (n.flags & 57344) {
                    t.msg = "unknown header flags set", n.mode = Et;
                    break
                }
                n.head && (n.head.text = l >> 8 & 1), n.flags & 512 && n.wrap & 4 && (v[0] = l & 255, v[1] = l >>> 8 & 255, n.check = Xt(n.check, v, 2, 0)), l = 0, u = 0, n.mode = v1;
            case v1:
                for (; u < 32;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                n.head && (n.head.time = l), n.flags & 512 && n.wrap & 4 && (v[0] = l & 255, v[1] = l >>> 8 & 255, v[2] = l >>> 16 & 255, v[3] = l >>> 24 & 255, n.check = Xt(n.check, v, 4, 0)), l = 0, u = 0, n.mode = b1;
            case b1:
                for (; u < 16;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                n.head && (n.head.xflags = l & 255, n.head.os = l >> 8), n.flags & 512 && n.wrap & 4 && (v[0] = l & 255, v[1] = l >>> 8 & 255, n.check = Xt(n.check, v, 2, 0)), l = 0, u = 0, n.mode = w1;
            case w1:
                if (n.flags & 1024) {
                    for (; u < 16;) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    n.length = l, n.head && (n.head.extra_len = l), n.flags & 512 && n.wrap & 4 && (v[0] = l & 255, v[1] = l >>> 8 & 255, n.check = Xt(n.check, v, 2, 0)), l = 0, u = 0
                } else n.head && (n.head.extra = null);
                n.mode = x1;
            case x1:
                if (n.flags & 1024 && (h = n.length, h > a && (h = a), h && (n.head && (M = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)), n.head.extra.set(r.subarray(s, s + h), M)), n.flags & 512 && n.wrap & 4 && (n.check = Xt(n.check, r, h, s)), a -= h, s += h, n.length -= h), n.length)) break e;
                n.length = 0, n.mode = A1;
            case A1:
                if (n.flags & 2048) {
                    if (a === 0) break e;
                    h = 0;
                    do M = r[s + h++], n.head && M && n.length < 65536 && (n.head.name += String.fromCharCode(M)); while (M && h < a);
                    if (n.flags & 512 && n.wrap & 4 && (n.check = Xt(n.check, r, h, s)), a -= h, s += h, M) break e
                } else n.head && (n.head.name = null);
                n.length = 0, n.mode = k1;
            case k1:
                if (n.flags & 4096) {
                    if (a === 0) break e;
                    h = 0;
                    do M = r[s + h++], n.head && M && n.length < 65536 && (n.head.comment += String.fromCharCode(M)); while (M && h < a);
                    if (n.flags & 512 && n.wrap & 4 && (n.check = Xt(n.check, r, h, s)), a -= h, s += h, M) break e
                } else n.head && (n.head.comment = null);
                n.mode = _1;
            case _1:
                if (n.flags & 512) {
                    for (; u < 16;) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    if (n.wrap & 4 && l !== (n.check & 65535)) {
                        t.msg = "header crc mismatch", n.mode = Et;
                        break
                    }
                    l = 0, u = 0
                }
                n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), t.adler = n.check = 0, n.mode = jr;
                break;
            case E1:
                for (; u < 32;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                t.adler = n.check = F1(l), l = 0, u = 0, n.mode = du;
            case du:
                if (n.havedict === 0) return t.next_out = o, t.avail_out = c, t.next_in = s, t.avail_in = a, n.hold = l, n.bits = u, pN;
                t.adler = n.check = 1, n.mode = jr;
            case jr:
                if (e === dN || e === dc) break e;
            case ad:
                if (n.last) {
                    l >>>= u & 7, u -= u & 7, n.mode = cd;
                    break
                }
                for (; u < 3;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                switch (n.last = l & 1, l >>>= 1, u -= 1, l & 3) {
                    case 0:
                        n.mode = P1;
                        break;
                    case 1:
                        if (AN(n), n.mode = hc, e === dc) {
                            l >>>= 2, u -= 2;
                            break e
                        }
                        break;
                    case 2:
                        n.mode = N1;
                        break;
                    case 3:
                        t.msg = "invalid block type", n.mode = Et
                }
                l >>>= 2, u -= 2;
                break;
            case P1:
                for (l >>>= u & 7, u -= u & 7; u < 32;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                if ((l & 65535) !== (l >>> 16 ^ 65535)) {
                    t.msg = "invalid stored block lengths", n.mode = Et;
                    break
                }
                if (n.length = l & 65535, l = 0, u = 0, n.mode = ld, e === dc) break e;
            case ld:
                n.mode = S1;
            case S1:
                if (h = n.length, h) {
                    if (h > a && (h = a), h > c && (h = c), h === 0) break e;
                    i.set(r.subarray(s, s + h), o), a -= h, s += h, c -= h, o += h, n.length -= h;
                    break
                }
                n.mode = jr;
                break;
            case N1:
                for (; u < 14;) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                if (n.nlen = (l & 31) + 257, l >>>= 5, u -= 5, n.ndist = (l & 31) + 1, l >>>= 5, u -= 5, n.ncode = (l & 15) + 4, l >>>= 4, u -= 4, n.nlen > 286 || n.ndist > 30) {
                    t.msg = "too many length or distance symbols", n.mode = Et;
                    break
                }
                n.have = 0, n.mode = R1;
            case R1:
                for (; n.have < n.ncode;) {
                    for (; u < 3;) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    n.lens[P[n.have++]] = l & 7, l >>>= 3, u -= 3
                }
                for (; n.have < 19;) n.lens[P[n.have++]] = 0;
                if (n.lencode = n.lendyn, n.lenbits = 7, A = {
                        bits: n.lenbits
                    }, y = Ba(fN, n.lens, 0, 19, n.lencode, 0, n.work, A), n.lenbits = A.bits, y) {
                    t.msg = "invalid code lengths set", n.mode = Et;
                    break
                }
                n.have = 0, n.mode = C1;
            case C1:
                for (; n.have < n.nlen + n.ndist;) {
                    for (; b = n.lencode[l & (1 << n.lenbits) - 1], x = b >>> 24, w = b >>> 16 & 255, O = b & 65535, !(x <= u);) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    if (O < 16) l >>>= x, u -= x, n.lens[n.have++] = O;
                    else {
                        if (O === 16) {
                            for (E = x + 2; u < E;) {
                                if (a === 0) break e;
                                a--, l += r[s++] << u, u += 8
                            }
                            if (l >>>= x, u -= x, n.have === 0) {
                                t.msg = "invalid bit length repeat", n.mode = Et;
                                break
                            }
                            M = n.lens[n.have - 1], h = 3 + (l & 3), l >>>= 2, u -= 2
                        } else if (O === 17) {
                            for (E = x + 3; u < E;) {
                                if (a === 0) break e;
                                a--, l += r[s++] << u, u += 8
                            }
                            l >>>= x, u -= x, M = 0, h = 3 + (l & 7), l >>>= 3, u -= 3
                        } else {
                            for (E = x + 7; u < E;) {
                                if (a === 0) break e;
                                a--, l += r[s++] << u, u += 8
                            }
                            l >>>= x, u -= x, M = 0, h = 11 + (l & 127), l >>>= 7, u -= 7
                        }
                        if (n.have + h > n.nlen + n.ndist) {
                            t.msg = "invalid bit length repeat", n.mode = Et;
                            break
                        }
                        for (; h--;) n.lens[n.have++] = M
                    }
                }
                if (n.mode === Et) break;
                if (n.lens[256] === 0) {
                    t.msg = "invalid code -- missing end-of-block", n.mode = Et;
                    break
                }
                if (n.lenbits = 9, A = {
                        bits: n.lenbits
                    }, y = Ba(o2, n.lens, 0, n.nlen, n.lencode, 0, n.work, A), n.lenbits = A.bits, y) {
                    t.msg = "invalid literal/lengths set", n.mode = Et;
                    break
                }
                if (n.distbits = 6, n.distcode = n.distdyn, A = {
                        bits: n.distbits
                    }, y = Ba(a2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, A), n.distbits = A.bits, y) {
                    t.msg = "invalid distances set", n.mode = Et;
                    break
                }
                if (n.mode = hc, e === dc) break e;
            case hc:
                n.mode = pc;
            case pc:
                if (a >= 6 && c >= 258) {
                    t.next_out = o, t.avail_out = c, t.next_in = s, t.avail_in = a, n.hold = l, n.bits = u, sN(t, d), o = t.next_out, i = t.output, c = t.avail_out, s = t.next_in, r = t.input, a = t.avail_in, l = n.hold, u = n.bits, n.mode === jr && (n.back = -1);
                    break
                }
                for (n.back = 0; b = n.lencode[l & (1 << n.lenbits) - 1], x = b >>> 24, w = b >>> 16 & 255, O = b & 65535, !(x <= u);) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                if (w && !(w & 240)) {
                    for (N = x, U = w, H = O; b = n.lencode[H + ((l & (1 << N + U) - 1) >> N)], x = b >>> 24, w = b >>> 16 & 255, O = b & 65535, !(N + x <= u);) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    l >>>= N, u -= N, n.back += N
                }
                if (l >>>= x, u -= x, n.back += x, n.length = O, w === 0) {
                    n.mode = D1;
                    break
                }
                if (w & 32) {
                    n.back = -1, n.mode = jr;
                    break
                }
                if (w & 64) {
                    t.msg = "invalid literal/length code", n.mode = Et;
                    break
                }
                n.extra = w & 15, n.mode = O1;
            case O1:
                if (n.extra) {
                    for (E = n.extra; u < E;) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    n.length += l & (1 << n.extra) - 1, l >>>= n.extra, u -= n.extra, n.back += n.extra
                }
                n.was = n.length, n.mode = T1;
            case T1:
                for (; b = n.distcode[l & (1 << n.distbits) - 1], x = b >>> 24, w = b >>> 16 & 255, O = b & 65535, !(x <= u);) {
                    if (a === 0) break e;
                    a--, l += r[s++] << u, u += 8
                }
                if (!(w & 240)) {
                    for (N = x, U = w, H = O; b = n.distcode[H + ((l & (1 << N + U) - 1) >> N)], x = b >>> 24, w = b >>> 16 & 255, O = b & 65535, !(N + x <= u);) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    l >>>= N, u -= N, n.back += N
                }
                if (l >>>= x, u -= x, n.back += x, w & 64) {
                    t.msg = "invalid distance code", n.mode = Et;
                    break
                }
                n.offset = O, n.extra = w & 15, n.mode = B1;
            case B1:
                if (n.extra) {
                    for (E = n.extra; u < E;) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    n.offset += l & (1 << n.extra) - 1, l >>>= n.extra, u -= n.extra, n.back += n.extra
                }
                if (n.offset > n.dmax) {
                    t.msg = "invalid distance too far back", n.mode = Et;
                    break
                }
                n.mode = I1;
            case I1:
                if (c === 0) break e;
                if (h = d - c, n.offset > h) {
                    if (h = n.offset - h, h > n.whave && n.sane) {
                        t.msg = "invalid distance too far back", n.mode = Et;
                        break
                    }
                    h > n.wnext ? (h -= n.wnext, p = n.wsize - h) : p = n.wnext - h, h > n.length && (h = n.length), g = n.window
                } else g = i, p = o - n.offset, h = n.length;
                h > c && (h = c), c -= h, n.length -= h;
                do i[o++] = g[p++]; while (--h);
                n.length === 0 && (n.mode = pc);
                break;
            case D1:
                if (c === 0) break e;
                i[o++] = n.length, c--, n.mode = pc;
                break;
            case cd:
                if (n.wrap) {
                    for (; u < 32;) {
                        if (a === 0) break e;
                        a--, l |= r[s++] << u, u += 8
                    }
                    if (d -= c, t.total_out += d, n.total += d, n.wrap & 4 && d && (t.adler = n.check = n.flags ? Xt(n.check, i, d, o - d) : tl(n.check, i, d, o - d)), d = c, n.wrap & 4 && (n.flags ? l : F1(l)) !== n.check) {
                        t.msg = "incorrect data check", n.mode = Et;
                        break
                    }
                    l = 0, u = 0
                }
                n.mode = L1;
            case L1:
                if (n.wrap && n.flags) {
                    for (; u < 32;) {
                        if (a === 0) break e;
                        a--, l += r[s++] << u, u += 8
                    }
                    if (n.wrap & 4 && l !== (n.total & 4294967295)) {
                        t.msg = "incorrect length check", n.mode = Et;
                        break
                    }
                    l = 0, u = 0
                }
                n.mode = M1;
            case M1:
                y = hN;
                break e;
            case Et:
                y = l2;
                break e;
            case u2:
                return c2;
            case f2:
            default:
                return qn
        }
        return t.next_out = o, t.avail_out = c, t.next_in = s, t.avail_in = a, n.hold = l, n.bits = u, (n.wsize || d !== t.avail_out && n.mode < Et && (n.mode < cd || e !== m1)) && g2(t, t.output, t.next_out, d - t.avail_out), f -= t.avail_in, d -= t.avail_out, t.total_in += f, t.total_out += d, n.total += d, n.wrap & 4 && d && (t.adler = n.check = n.flags ? Xt(n.check, i, d, t.next_out - d) : tl(n.check, i, d, t.next_out - d)), t.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === jr ? 128 : 0) + (n.mode === hc || n.mode === ld ? 256 : 0), (f === 0 && d === 0 || e === m1) && y === Ds && (y = mN), y
    },
    _N = t => {
        if (js(t)) return qn;
        let e = t.state;
        return e.window && (e.window = null), t.state = null, Ds
    },
    EN = (t, e) => {
        if (js(t)) return qn;
        const n = t.state;
        return n.wrap & 2 ? (n.head = e, e.done = !1, Ds) : qn
    },
    PN = (t, e) => {
        const n = e.length;
        let r, i, s;
        return js(t) || (r = t.state, r.wrap !== 0 && r.mode !== du) ? qn : r.mode === du && (i = 1, i = tl(i, e, n, 0), i !== r.check) ? l2 : (s = g2(t, e, n, n), s ? (r.mode = u2, c2) : (r.havedict = 1, Ds))
    };
var SN = h2,
    NN = p2,
    RN = d2,
    CN = xN,
    ON = m2,
    TN = kN,
    BN = _N,
    IN = EN,
    DN = PN,
    LN = "pako inflate (from Nodeca project)",
    Kr = {
        inflateReset: SN,
        inflateReset2: NN,
        inflateResetKeep: RN,
        inflateInit: CN,
        inflateInit2: ON,
        inflate: TN,
        inflateEnd: BN,
        inflateGetHeader: IN,
        inflateSetDictionary: DN,
        inflateInfo: LN
    };

function MN() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
}
var FN = MN;
const y2 = Object.prototype.toString,
    {
        Z_NO_FLUSH: UN,
        Z_FINISH: HN,
        Z_OK: il,
        Z_STREAM_END: dd,
        Z_NEED_DICT: hd,
        Z_STREAM_ERROR: zN,
        Z_DATA_ERROR: H1,
        Z_MEM_ERROR: jN
    } = zs;

function Rl(t) {
    this.options = qu.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
    }, t || {});
    const e = this.options;
    e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, e.windowBits === 0 && (e.windowBits = -15)), e.windowBits >= 0 && e.windowBits < 16 && !(t && t.windowBits) && (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && (e.windowBits & 15 || (e.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new i2, this.strm.avail_out = 0;
    let n = Kr.inflateInit2(this.strm, e.windowBits);
    if (n !== il) throw new Error(Bs[n]);
    if (this.header = new FN, Kr.inflateGetHeader(this.strm, this.header), e.dictionary && (typeof e.dictionary == "string" ? e.dictionary = rl.string2buf(e.dictionary) : y2.call(e.dictionary) === "[object ArrayBuffer]" && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (n = Kr.inflateSetDictionary(this.strm, e.dictionary), n !== il))) throw new Error(Bs[n])
}
Rl.prototype.push = function(t, e) {
    const n = this.strm,
        r = this.options.chunkSize,
        i = this.options.dictionary;
    let s, o, a;
    if (this.ended) return !1;
    for (e === ~~e ? o = e : o = e === !0 ? HN : UN, y2.call(t) === "[object ArrayBuffer]" ? n.input = new Uint8Array(t) : n.input = t, n.next_in = 0, n.avail_in = n.input.length;;) {
        for (n.avail_out === 0 && (n.output = new Uint8Array(r), n.next_out = 0, n.avail_out = r), s = Kr.inflate(n, o), s === hd && i && (s = Kr.inflateSetDictionary(n, i), s === il ? s = Kr.inflate(n, o) : s === H1 && (s = hd)); n.avail_in > 0 && s === dd && n.state.wrap > 0 && t[n.next_in] !== 0;) Kr.inflateReset(n), s = Kr.inflate(n, o);
        switch (s) {
            case zN:
            case H1:
            case hd:
            case jN:
                return this.onEnd(s), this.ended = !0, !1
        }
        if (a = n.avail_out, n.next_out && (n.avail_out === 0 || s === dd))
            if (this.options.to === "string") {
                let c = rl.utf8border(n.output, n.next_out),
                    l = n.next_out - c,
                    u = rl.buf2string(n.output, c);
                n.next_out = l, n.avail_out = r - l, l && n.output.set(n.output.subarray(c, c + l), 0), this.onData(u)
            } else this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
        if (!(s === il && a === 0)) {
            if (s === dd) return s = Kr.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, !0;
            if (n.avail_in === 0) break
        }
    }
    return !0
};
Rl.prototype.onData = function(t) {
    this.chunks.push(t)
};
Rl.prototype.onEnd = function(t) {
    t === il && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = qu.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg
};

function Gp(t, e) {
    const n = new Rl(e);
    if (n.push(t), n.err) throw n.msg || Bs[n.err];
    return n.result
}

function VN(t, e) {
    return e = e || {}, e.raw = !0, Gp(t, e)
}
var GN = Rl,
    WN = Gp,
    QN = VN,
    JN = Gp,
    KN = zs,
    ZN = {
        Inflate: GN,
        inflate: WN,
        inflateRaw: QN,
        ungzip: JN,
        constants: KN
    };
const {
    Deflate: YN,
    deflate: XN,
    deflateRaw: qN,
    gzip: $N
} = rN, {
    Inflate: eR,
    inflate: tR,
    inflateRaw: nR,
    ungzip: rR
} = ZN;
var iR = YN,
    sR = XN,
    oR = qN,
    aR = $N,
    lR = eR,
    cR = tR,
    uR = nR,
    fR = rR,
    dR = zs,
    hR = {
        Deflate: iR,
        deflate: sR,
        deflateRaw: oR,
        gzip: aR,
        Inflate: lR,
        inflate: cR,
        inflateRaw: uR,
        ungzip: fR,
        constants: dR
    };
let z1, mc, kh, pd, v2, md, b2;
async function pR() {
    z1 = hh("VITE_ROCKET_STORAGE_ADDRESS");
    const t = hh("VITE_WEB3_RPC_URL");
    let e = t;
    t.includes("http") || (e = window.location.origin + t), mc = new dP(e), kh = new Mi(z1, mP, mc), [pd, md] = await Promise.all([j1("rocketTokenRPL"), j1("rocketNetworkPrices")]), v2 = new Mi(pd.address, pd.abi, mc), b2 = new Mi(md.address, md.abi, mc)
}
async function j1(t) {
    const e = Sg(["string", "string"], ["contract.abi", t]),
        n = Sg(["string", "string"], ["contract.address", t]),
        r = kh.getFunction("getAddress"),
        i = kh.getFunction("getString"),
        [s, o] = await Promise.all([i(e), r(n)]),
        a = mR(s);
    return {
        address: o,
        abi: a
    }
}

function mR(t) {
    const e = rb(t);
    return hR.inflate(e, {
        to: "string"
    })
}
async function gR() {
    const t = await v2.totalSupply();
    return db(t)
}
async function yR() {
    const t = await b2.getRPLPrice();
    return db(t)
}
const vR = nt({
    __name: "app",
    setup(t) {
        const e = we("emitter"),
            n = we("axios"),
            r = j4("bugBounty", !1);
        de("bugBounty", r);
        const i = Z("");
        de("rethAPR", i);
        const s = Z(.05);
        de("inflation", s);
        const o = Z(.7);
        de("nodeOperatorShare", o);
        const a = Z("305730");
        de("numberOfValidatorsDefault", a);
        const c = Z(me("7699223.804766"));
        de("totalEffectiveRPLStakedDefault", c);
        const l = Z("19329235.929807059716979202");
        de("rplSupplyDefault", l);
        const u = Z("0.025693507968926936");
        de("rplETHRatioDefault", u);
        const f = Z("19504705");
        de("ethStakedDefault", f);
        const d = Z(150);
        de("yourRPLStakedDefault", d);
        const h = Z("4.7");
        de("beaconChainAPR", h);
        const p = Z(me(4.7));
        de("beaconChainAPRBN", p);
        const g = Z(me("305730"));
        de("numberOfValidators", g);
        const b = Z(me("3100000"));
        de("totalEffectiveRPLStaked", b);
        const x = Z(me("18203250"));
        de("rplSupply", x);
        const w = Z("0.01113875");
        de("rplETHRatio", w);
        const O = Z(me(9991426));
        de("ethStaked", O);
        const N = Z(150);
        de("yourRPLStaked", N);
        const U = Z(14);
        de("commission", U);
        const H = Z("");
        de("ethPriceInUSD", H);
        const M = Z(20);
        de("gasPrice", M);
        const y = Z(1);
        de("minipools", y);
        const v = Z(!0);
        de("claimRPL", v);
        const A = Z(!1);
        de("restakeRPL", A);
        const E = Z("");
        de("ethReturn", E);
        const P = Z("");
        de("rplReturn", P);
        const R = Z(.2);
        de("priorityFees", R);
        const F = Z(new me(0));
        de("priorityFeesBN", F);
        const _ = Z(new me(0));
        de("priorityFeesCommission", _);
        const S = Z(.2);
        de("mev", S);
        const I = Z(new me(0));
        de("mevBN", I);
        const B = Z(new me(0));
        de("mevCommission", B);
        const j = Z(!0);
        de("smoothingPoolEnabled", j);
        const Y = Z(.03929273);
        de("smoothingPoolAverage", Y);
        const te = Z(new me(0));
        de("smoothingPoolBN", te);
        const he = Z(new me(0));
        de("commissionValueBN", he);
        const Te = Z("428874");
        de("gasRPLNodeClaim", Te);
        const Be = Z("51923");
        de("gasRPLNodeTransfer", Be);
        const ve = Z("246107");
        de("gasRPLNodeStake", ve);
        const X = Z("1744642");
        de("gasMinipoolDeposit", X);
        const V = Z("460764");
        de("gasMinipoolStake", V);
        const oe = Z("21000");
        de("gasNodeETHTransfer", oe);
        const ae = Z("51923");
        de("gasNodeRPLTransfer", ae);
        const Ae = Z("69688");
        de("gasNodeApprove", Ae);
        const Fe = Z("246107");
        de("gasNodeStakeRPL", Fe);
        const C = Z("21000");
        de("gasNodeTestWithdrawalAddress", C);
        const T = Z("46756");
        de("gasNodeSetWithdrawalAddress", T);
        const z = Z("46273");
        de("gasNodeConfirmWithdrawalAddress", z);
        const Q = Z(new me(O.value));
        de("ethStakedBN", Q);
        const $ = Z("0");
        de("rplReturnETH", $);
        const ne = Z(new me(0));
        de("totalEffectiveRPLStakedBN", ne);
        const ge = Z(new me(w.value));
        de("rplETHRatioBN", ge);
        const ce = Z(new me(x.value));
        de("rplSupplyBN", ce);
        const ye = Z(new me(s.value));
        de("inflationBN", ye);
        const se = Z(new me(o.value));
        de("nodeOperatorShareBN", se);
        const Ce = Z("53.19");
        de("yourRPLStakedPercentage", Ce);
        const _e = Z(new me(P.value));
        de("rplReturnBN", _e);
        const Oe = Z("0");
        de("rplRewards", Oe);
        const He = Z("");
        de("rplAPRPercentage", He);
        const Qe = Z(new me(0));
        de("rplAPRPercentageBN", Qe);
        const st = Z("0.8");
        de("beaconChainReturn", st);
        const rt = Z(new me(st.value));
        de("beaconChainReturnBN", rt);
        const D = Z(new me(0));
        de("beaconChainReturnAsDecimal", D);
        const k = Z("0.8");
        de("beaconChainReturnAsDecimalFormatted", k);
        const le = Z("0.14");
        de("commissionValue", le);
        const Ee = Z("");
        de("calculatedETHReturn", Ee);
        const pe = Z(new me(0));
        de("calculatedETHReturnBN", pe);
        const Ie = Z("");
        de("ethAPRPercentage", Ie);
        const je = Z(new me(0));
        de("ethAPRPercentageBN", je);
        const et = Z("");
        de("totalETH", et);
        const mt = Z("");
        de("totalNodes", mt);
        const $n = Z("");
        de("regions", $n);
        const jt = Z("");
        de("displayEthStaked", jt);
        const Ve = Z("");
        de("displayNodeOperators", Ve);
        const In = Z({});
        de("yourRPLStakedOptions", In);
        const bt = Z("");
        de("totalEffectiveRPLStakedFormatted", bt);
        const on = J3(),
            Gs = Z(!0);
        Xe(j, async () => {
            j.value ? (R.value = .2, S.value = .2) : (R.value = .1, S.value = .1), await Ml()
        }), Xe(on, ft => {
            pi(ft)
        }, {
            flush: "pre",
            immediate: !0,
            deep: !0
        }), sn(async () => {
            await Promise.all([er(), pR()]), document.documentElement.classList.add("loaded"), document.body.classList.add("loaded"), document.getElementById("pload").style.display = "none", Gs.value = !1, location.hash && document.getElementById(location.hash).click(), [l.value, u.value] = await Promise.all([gR(), yR()]), console.groupCollapsed("Contract & API Data"), console.log(`RPL Supply: ${l.value.toString()}`), console.log(`Effective RPL Staked: ${c.value.toString()}`), console.log(`RPL ETH Ratio: ${u.value.toString()}`), console.log(`ETH Supply: ${f.value}`), console.log(`Number of Validators: ${a.value.toString()}`), console.groupEnd(), e.emit("set-defaults"), e.emit("recalculate")
        });
        async function er() {
            const ft = `${hh("VITE_API_URL")}/mainnet/payload`;
            await (async () => {
                try {
                    const en = await n.get(ft),
                        tr = new me(en.data.rethAPR);
                    i.value = tr.toFormat(2), f.value = en.data.ethStaked.replace("ETH", "").trim().replaceAll(",", "").trim(), c.value = en.data.rplTotalEffectiveStaked, et.value = en.data.stats.ethStakingTotal, mt.value = en.data.stats.nodeOpsTotal, p.value = new me(en.data.beaconChainAPR).multipliedBy(100)
                } catch (en) {
                    console.log(`There seems to be an issue with the RP API: ${en}`)
                }
            })()
        }

        function pi(ft) {
            document.title = ft.meta.title ? ft.meta.title : "Rocket Pool - Decentralised Ethereum Proof of Stake Protocol"
        }

        function Ws() {
            b.value = c.value, ne.value = new me(c.value), bt.value = ne.value.toFormat(2), x.value = new me(l.value).toFormat(2), ce.value = new me(l.value), w.value = u.value, ge.value = new me(u.value), O.value = f.value, Q.value = new me(O.value), N.value = d.value;
            const ft = new me(10).multipliedBy(new me(24)).dividedBy(ge.value.multipliedBy(100)),
                Fr = new me(150).multipliedBy(new me(24)).dividedBy(ge.value.multipliedBy(100));
            In.value = {
                range: {
                    min: ft.toNumber(),
                    max: Fr.toNumber()
                },
                step: 1
            }
        }
        async function Qs() {
            const ft = new me(N.value),
                Fr = new me($.value);
            ne.value = b.value, w.value = ge.value.toFormat(5);
            const en = ft.dividedBy(ne.value),
                tr = ce.value.multipliedBy(ye.value).multipliedBy(se.value),
                Ur = ft.multipliedBy(ge.value).dividedBy(24).multipliedBy(100);
            Ce.value = Ur.toFormat(0), _e.value = en.multipliedBy(tr), P.value = _e.value.toFormat(2), Fr.value = _e.value.multipliedBy(ge.value), $.value = Fr.value.toFormat(2);
            const Js = _e.value.dividedBy(ft).multipliedBy(100);
            Oe.value = Js.toFormat(2), Qe.value = Js, He.value = Qe.value.toFormat(2)
        }
        async function Ml() {
            h.value = p.value.toFormat(2), st.value = p.value.toString(), rt.value = new me(p.value);
            const ft = new me(8);
            D.value = ft.multipliedBy(rt.value.dividedBy(100)), k.value = D.value.toFormat(2);
            const en = new me(24).multipliedBy(p.value).dividedBy(100).multipliedBy(.14);
            he.value = en, le.value = he.value.toFormat(2);
            const tr = new me(R.value),
                Ur = new me(S.value),
                Js = tr.multipliedBy(.75),
                Fl = Ur.multipliedBy(.75);
            _.value = tr.multipliedBy(.14), B.value = Ur.multipliedBy(.14), F.value = tr.minus(Js).plus(_.value), I.value = Ur.minus(Fl).plus(B.value);
            const Ks = new me(8).multipliedBy(p.value).dividedBy(100),
                ta = new me(24).multipliedBy(p.value).dividedBy(100).multipliedBy(.14),
                hf = tr.multipliedBy(.75),
                Hl = tr.multipliedBy(.25),
                na = hf.multipliedBy(.14),
                pf = Ur.multipliedBy(.75),
                zl = Ur.multipliedBy(.25),
                Zs = pf.multipliedBy(.14);
            Ks.plus(ta).plus(Hl).plus(na).plus(zl).plus(Zs), pe.value = Ks.plus(ta).plus(Hl).plus(na).plus(zl).plus(Zs), Ee.value = pe.value.toFormat(2), je.value = pe.value.dividedBy(ft).multipliedBy(100), Ie.value = je.value.toFormat(2)
        }
        return e.on("recalculate", async () => {
            await Promise.all([Qs(), Ml()])
        }), e.on("set-defaults", () => {
            Ws()
        }), e.on("update-hash-header", async () => {
            history.pushState({}, null, "#header")
        }), e.on("update-hash-stake-run-node", async () => {
            history.pushState({}, null, "#stake-run-node")
        }), e.on("update-hash-security", async () => {
            history.pushState({}, null, "#security")
        }), e.on("update-hash-how-it-works", async () => {
            history.pushState({}, null, "#how-it-works")
        }), e.on("update-hash-community", async () => {
            history.pushState({}, null, "#community")
        }), e.on("update-hash-news", async () => {
            history.pushState({}, null, "#news")
        }), e.on("update-hash-team", async () => {
            history.pushState({}, null, "#team")
        }), e.on("update-hash-dao", async () => {
            history.pushState({}, null, "#dao")
        }), e.on("update-hash-tweets", async () => {
            history.pushState({}, null, "#tweets")
        }), e.on("update-hash-node-operator-interest", async () => {
            history.pushState({}, null, "#node-operator-interest")
        }), e.on("update-hash-footer", async () => {
            history.pushState({}, null, "#footer")
        }), e.on("load-tweets", async () => {
            const ft = document.createElement("script");
            ft.src = "https://platform.twitter.com/widgets.js", ft.async = !0, document.body.appendChild(ft)
        }), (ft, Fr) => {
            const en = Lr("router-view");
            return fe(), be("div", {
                id: "app",
                class: Rt({
                    isLoaded: Gs.value
                })
            }, [q(en)], 2)
        }
    }
});

function bR(t) {
    return {
        all: t = t || new Map,
        on: function(e, n) {
            var r = t.get(e);
            r ? r.push(n) : t.set(e, [n])
        },
        off: function(e, n) {
            var r = t.get(e);
            r && (n ? r.splice(r.indexOf(n) >>> 0, 1) : t.set(e, []))
        },
        emit: function(e, n) {
            var r = t.get(e);
            r && r.slice().map(function(i) {
                i(n)
            }), (r = t.get("*")) && r.slice().map(function(i) {
                i(e, n)
            })
        }
    }
}
var w2 = nt({
    name: "Vue3Autocounter",
    interval: null,
    props: {
        startAmount: {
            type: Number,
            default: 0
        },
        endAmount: {
            type: Number,
            default: 0,
            required: !0
        },
        duration: {
            type: Number,
            default: 3,
            validator(t) {
                return t >= 1
            }
        },
        autoinit: {
            type: Boolean,
            default: !0
        },
        prefix: {
            type: String,
            default: ""
        },
        suffix: {
            type: String,
            default: ""
        },
        separator: {
            type: String,
            default: ","
        },
        decimalSeparator: {
            type: String,
            default: "."
        },
        decimals: {
            type: Number,
            default: 0,
            validator(t) {
                return t >= 0
            }
        }
    },
    data() {
        return {
            timestamp: 0,
            startTimestamp: 0,
            currentAmount: 0,
            currentStartAmount: 0,
            currentDuration: 0,
            paused: !1,
            remaining: 0,
            animationFrame: 0
        }
    },
    mounted() {
        this.currentAmount = this.startAmount, this.currentStartAmount = this.startAmount, this.currentDuration = this.duration * 1e3, this.remaining = this.duration * 1e3, this.autoinit ? this.start() : this.paused = !0, this.$emit("mounted")
    },
    unmounted() {
        this.cancelAnimation()
    },
    watch: {
        startAmount() {
            this.reset()
        },
        endAmount() {
            this.reset()
        },
        duration() {
            this.reset()
        }
    },
    computed: {
        isCountingUp() {
            return this.endAmount > this.startAmount
        },
        displayedAmount() {
            return `${this.prefix}${this.formatedAmount}${this.suffix}`
        },
        formatedAmount() {
            const t = /(\d+)(\d{3})/;
            let e = this.currentAmount.toFixed(this.decimals);
            e += "";
            let n = e.split("."),
                r = n[0],
                i = n.length > 1 ? this.decimalSeparator + n[1] : "",
                s = !isNaN(parseFloat(this.separator));
            if (this.separator && !s)
                for (; t.test(r);) r = r.replace(t, "$1" + this.separator + "$2");
            return r + i
        }
    },
    methods: {
        start() {
            this.cancelAnimation(), this.currentStartAmount = this.startAmount, this.startTimestamp = null, this.currentDuration = this.duration * 1e3, this.paused = !1, this.animationFrame = window.requestAnimationFrame(this.counting)
        },
        pause() {
            this.paused || (this.cancelAnimation(), this.paused = !0)
        },
        resume() {
            this.paused && (this.startTimestamp = null, this.currentDuration = +this.remaining, this.currentStartAmount = +this.currentAmount, this.animationFrame = window.requestAnimationFrame(this.counting), this.paused = !1)
        },
        reset() {
            this.paused = !1, this.startTimestamp = null, this.cancelAnimation(), this.currentAmount = this.startAmount, this.autoinit ? this.start() : this.paused = !0
        },
        counting(t) {
            this.timestamp = t, this.startTimestamp || (this.startTimestamp = t);
            let e = t - this.startTimestamp;
            this.remaining = this.currentDuration - e, this.isCountingUp ? (this.currentAmount = this.currentStartAmount + (this.endAmount - this.currentStartAmount) * (e / this.currentDuration), this.currentAmount = this.currentAmount > this.endAmount ? this.endAmount : this.currentAmount) : (this.currentAmount = this.currentStartAmount - (this.currentStartAmount - this.endAmount) * (e / this.currentDuration), this.currentAmount = this.currentAmount < this.endAmount ? this.endAmount : this.currentAmount), e < this.currentDuration ? this.animationFrame = window.requestAnimationFrame(this.counting) : setTimeout(() => {
                this.$emit("finished")
            }, 1e3)
        },
        cancelAnimation() {
            this.animationFrame && window.cancelAnimationFrame(this.animationFrame)
        }
    }
});

function wR(t, e, n, r, i, s) {
    return fe(), fi("span", null, ue(t.displayedAmount), 1)
}
w2.render = wR;
var xR = (() => {
    const t = w2;
    return t.install = e => {
        e.component("Vue3Autocounter", t)
    }, t
})();
const AR = xR;

function Mc(t) {
    var e;
    const n = Pr(t);
    return (e = n ? .$el) != null ? e : n
}
const x2 = dp ? window : void 0;

function kR(...t) {
    let e, n, r, i;
    if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([n, r, i] = t, e = x2) : [e, n, r, i] = t, !e) return ti;
    Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
    const s = [],
        o = () => {
            s.forEach(u => u()), s.length = 0
        },
        a = (u, f, d, h) => (u.addEventListener(f, d, h), () => u.removeEventListener(f, d, h)),
        c = Xe(() => [Mc(e), Pr(i)], ([u, f]) => {
            if (o(), !u) return;
            const d = Hv(f) ? { ...f
            } : f;
            s.push(...n.flatMap(h => r.map(p => a(u, h, p, d))))
        }, {
            immediate: !0,
            flush: "post"
        }),
        l = () => {
            c(), o()
        };
    return bl(l), l
}

function _R() {
    const t = Z(!1);
    return Zo() && sn(() => {
        t.value = !0
    }), t
}

function ER(t) {
    const e = _R();
    return ze(() => (e.value, !!t()))
}

function V1(t, e, n = {}) {
    const {
        root: r,
        rootMargin: i = "0px",
        threshold: s = .1,
        window: o = x2,
        immediate: a = !0
    } = n, c = ER(() => o && "IntersectionObserver" in o), l = ze(() => {
        const p = Pr(t);
        return (Array.isArray(p) ? p : [p]).map(Mc).filter(Uv)
    });
    let u = ti;
    const f = Z(a),
        d = c.value ? Xe(() => [l.value, Mc(r), f.value], ([p, g]) => {
            if (u(), !f.value || !p.length) return;
            const b = new IntersectionObserver(e, {
                root: Mc(g),
                rootMargin: i,
                threshold: s
            });
            p.forEach(x => x && b.observe(x)), u = () => {
                b.disconnect(), u = ti
            }
        }, {
            immediate: a,
            flush: "post"
        }) : ti,
        h = () => {
            u(), d(), f.value = !1
        };
    return bl(h), {
        isSupported: c,
        isActive: f,
        pause() {
            u(), f.value = !1
        },
        resume() {
            f.value = !0
        },
        stop: h
    }
}

function gd(t) {
    return typeof Window < "u" && t instanceof Window ? t.document.documentElement : typeof Document < "u" && t instanceof Document ? t.documentElement : t
}
const yr = {
    [C4.mounted](t, e) {
        typeof e.value == "function" ? V1(t, e.value) : V1(t, ...e.value)
    }
};

function A2(t) {
    const e = window.getComputedStyle(t);
    if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && t.clientWidth < t.scrollWidth || e.overflowY === "auto" && t.clientHeight < t.scrollHeight) return !0; {
        const n = t.parentNode;
        return !n || n.tagName === "BODY" ? !1 : A2(n)
    }
}

function PR(t) {
    const e = t || window.event,
        n = e.target;
    return A2(n) ? !1 : e.touches.length > 1 ? !0 : (e.preventDefault && e.preventDefault(), !1)
}
const gc = new WeakMap;

function SR(t, e = !1) {
    const n = Z(e);
    let r = null,
        i;
    Xe(O4(t), a => {
        const c = gd(Pr(a));
        if (c) {
            const l = c;
            gc.get(l) || gc.set(l, i), n.value && (l.style.overflow = "hidden")
        }
    }, {
        immediate: !0
    });
    const s = () => {
            const a = gd(Pr(t));
            !a || n.value || (k0 && (r = kR(a, "touchmove", c => {
                PR(c)
            }, {
                passive: !1
            })), a.style.overflow = "hidden", n.value = !0)
        },
        o = () => {
            var a;
            const c = gd(Pr(t));
            !c || !n.value || (k0 && r ? .(), c.style.overflow = (a = gc.get(c)) != null ? a : "", gc.delete(c), n.value = !1)
        };
    return bl(o), ze({
        get() {
            return n.value
        },
        set(a) {
            a ? s() : o()
        }
    })
}

function NR() {
    let t = !1;
    const e = Z(!1);
    return (n, r) => {
        if (e.value = r.value, t) return;
        t = !0;
        const i = SR(n, r.value);
        Xe(e, s => i.value = s)
    }
}
NR();
const k2 = "/assets/rocketpool-UfKRnF6A.webp",
    RR = {
        class: "bg-gradient-to-r from-rporange-bg to-rppink-bg"
    },
    CR = {
        class: "bg-header relative overflow-hidden"
    },
    OR = m("div", {
        class: "bg-fx"
    }, null, -1),
    TR = m("div", {
        class: "rocket"
    }, null, -1),
    BR = m("div", {
        class: "trail"
    }, null, -1),
    IR = m("div", {
        class: "bg-clouds-top"
    }, null, -1),
    DR = {
        class: "relative overflow-hidden"
    },
    LR = {
        class: "relative pt-6 pb-16 sm:pb-24"
    },
    MR = {
        class: "mt-16 mx-auto max-w-7xl px-4 sm:mt-24"
    },
    FR = m("div", {
        class: "flex justify-center"
    }, [m("img", {
        src: k2,
        class: "md:max-w-3xl"
    })], -1),
    UR = {
        class: "mt-20 pb-12 sm:pb-16"
    },
    HR = {
        class: "relative"
    },
    zR = m("div", {
        class: "absolute inset-0 h-1/2"
    }, null, -1),
    jR = {
        class: "relative max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"
    },
    VR = {
        class: "max-w-4xl mx-auto"
    },
    GR = {
        class: "sm:grid sm:grid-cols-2"
    },
    WR = {
        class: "flex flex-col p-6 text-center sm:border-0"
    },
    QR = m("dt", {
        class: "order-2 mt-2 text-lg leading-6 font-semibold uppercase text-gray-50 tracking-wide"
    }, "ETH Staked", -1),
    JR = {
        class: "text-5xl sm:text-8xl font-extrabold block bg-gradient-to-r from-pink-100 via-yellow-300 to-yellow-200 bg-clip-text text-transparent"
    },
    KR = {
        class: "flex flex-col border-t p-6 text-center sm:border-0"
    },
    ZR = m("dt", {
        class: "order-2 mt-2 text-lg leading-6 font-semibold uppercase text-gray-50 tracking-wide"
    }, "Node Operators", -1),
    YR = {
        class: "text-5xl sm:text-8xl font-extrabold block bg-gradient-to-r from-pink-100 via-yellow-300 to-yellow-200 bg-clip-text text-transparent"
    },
    XR = nt({
        __name: "header",
        setup(t) {
            const e = we("totalETH"),
                n = we("totalNodes");
            return (r, i) => {
                const s = Lr("vue3-autocounter");
                return fe(), be("div", RR, [m("div", CR, [OR, TR, BR, IR, m("div", DR, [m("div", LR, [m("main", MR, [FR, m("div", UR, [m("div", HR, [zR, m("div", jR, [m("div", VR, [m("dl", GR, [m("div", WR, [QR, m("dd", JR, [q(s, {
                    ref: "totalETH.value",
                    startAmount: 0,
                    endAmount: J(e),
                    duration: 3,
                    separator: ",",
                    decimalSeparator: ".",
                    decimals: 0,
                    autoinit: !0
                }, null, 8, ["endAmount"])])]), m("div", KR, [ZR, m("dd", YR, [q(s, {
                    ref: "totalNodes.value",
                    startAmount: 0,
                    endAmount: J(n),
                    duration: 3,
                    separator: ",",
                    decimalSeparator: ".",
                    decimals: 0,
                    autoinit: !0
                }, null, 8, ["endAmount"])])])])])])])])])])])])])
            }
        }
    }),
    qR = "/assets/services-panel-node-LGRnrXz4.webp",
    $R = "/assets/services-panel-stake-lRAqMZmw.webp";
var _2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function E2(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
var P2 = {
    exports: {}
};
/*! @preserve
 * numeral.js
 * version : 2.0.6
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */
(function(t) {
    (function(e, n) {
        t.exports ? t.exports = n() : e.numeral = n()
    })(_2, function() {
        var e, n, r = "2.0.6",
            i = {},
            s = {},
            o = {
                currentLocale: "en",
                zeroFormat: null,
                nullFormat: null,
                defaultFormat: "0,0",
                scalePercentBy100: !0
            },
            a = {
                currentLocale: o.currentLocale,
                zeroFormat: o.zeroFormat,
                nullFormat: o.nullFormat,
                defaultFormat: o.defaultFormat,
                scalePercentBy100: o.scalePercentBy100
            };

        function c(l, u) {
            this._input = l, this._value = u
        }
        return e = function(l) {
                var u, f, d, h;
                if (e.isNumeral(l)) u = l.value();
                else if (l === 0 || typeof l > "u") u = 0;
                else if (l === null || n.isNaN(l)) u = null;
                else if (typeof l == "string")
                    if (a.zeroFormat && l === a.zeroFormat) u = 0;
                    else if (a.nullFormat && l === a.nullFormat || !l.replace(/[^0-9]+/g, "").length) u = null;
                else {
                    for (f in i)
                        if (h = typeof i[f].regexps.unformat == "function" ? i[f].regexps.unformat() : i[f].regexps.unformat, h && l.match(h)) {
                            d = i[f].unformat;
                            break
                        }
                    d = d || e._.stringToNumber, u = d(l)
                } else u = Number(l) || null;
                return new c(l, u)
            }, e.version = r, e.isNumeral = function(l) {
                return l instanceof c
            }, e._ = n = {
                numberToFormat: function(l, u, f) {
                    var d = s[e.options.currentLocale],
                        h = !1,
                        p = !1,
                        g = 0,
                        b = "",
                        x = 1e12,
                        w = 1e9,
                        O = 1e6,
                        N = 1e3,
                        U = "",
                        H = !1,
                        M, y, v, A, E, P, R;
                    if (l = l || 0, y = Math.abs(l), e._.includes(u, "(") ? (h = !0, u = u.replace(/[\(|\)]/g, "")) : (e._.includes(u, "+") || e._.includes(u, "-")) && (E = e._.includes(u, "+") ? u.indexOf("+") : l < 0 ? u.indexOf("-") : -1, u = u.replace(/[\+|\-]/g, "")), e._.includes(u, "a") && (M = u.match(/a(k|m|b|t)?/), M = M ? M[1] : !1, e._.includes(u, " a") && (b = " "), u = u.replace(new RegExp(b + "a[kmbt]?"), ""), y >= x && !M || M === "t" ? (b += d.abbreviations.trillion, l = l / x) : y < x && y >= w && !M || M === "b" ? (b += d.abbreviations.billion, l = l / w) : y < w && y >= O && !M || M === "m" ? (b += d.abbreviations.million, l = l / O) : (y < O && y >= N && !M || M === "k") && (b += d.abbreviations.thousand, l = l / N)), e._.includes(u, "[.]") && (p = !0, u = u.replace("[.]", ".")), v = l.toString().split(".")[0], A = u.split(".")[1], P = u.indexOf(","), g = (u.split(".")[0].split(",")[0].match(/0/g) || []).length, A ? (e._.includes(A, "[") ? (A = A.replace("]", ""), A = A.split("["), U = e._.toFixed(l, A[0].length + A[1].length, f, A[1].length)) : U = e._.toFixed(l, A.length, f), v = U.split(".")[0], e._.includes(U, ".") ? U = d.delimiters.decimal + U.split(".")[1] : U = "", p && Number(U.slice(1)) === 0 && (U = "")) : v = e._.toFixed(l, 0, f), b && !M && Number(v) >= 1e3 && b !== d.abbreviations.trillion) switch (v = String(Number(v) / 1e3), b) {
                        case d.abbreviations.thousand:
                            b = d.abbreviations.million;
                            break;
                        case d.abbreviations.million:
                            b = d.abbreviations.billion;
                            break;
                        case d.abbreviations.billion:
                            b = d.abbreviations.trillion;
                            break
                    }
                    if (e._.includes(v, "-") && (v = v.slice(1), H = !0), v.length < g)
                        for (var F = g - v.length; F > 0; F--) v = "0" + v;
                    return P > -1 && (v = v.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + d.delimiters.thousands)), u.indexOf(".") === 0 && (v = ""), R = v + U + (b || ""), h ? R = (h && H ? "(" : "") + R + (h && H ? ")" : "") : E >= 0 ? R = E === 0 ? (H ? "-" : "+") + R : R + (H ? "-" : "+") : H && (R = "-" + R), R
                },
                stringToNumber: function(l) {
                    var u = s[a.currentLocale],
                        f = l,
                        d = {
                            thousand: 3,
                            million: 6,
                            billion: 9,
                            trillion: 12
                        },
                        h, p, g;
                    if (a.zeroFormat && l === a.zeroFormat) p = 0;
                    else if (a.nullFormat && l === a.nullFormat || !l.replace(/[^0-9]+/g, "").length) p = null;
                    else {
                        p = 1, u.delimiters.decimal !== "." && (l = l.replace(/\./g, "").replace(u.delimiters.decimal, "."));
                        for (h in d)
                            if (g = new RegExp("[^a-zA-Z]" + u.abbreviations[h] + "(?:\\)|(\\" + u.currency.symbol + ")?(?:\\))?)?$"), f.match(g)) {
                                p *= Math.pow(10, d[h]);
                                break
                            }
                        p *= (l.split("-").length + Math.min(l.split("(").length - 1, l.split(")").length - 1)) % 2 ? 1 : -1, l = l.replace(/[^0-9\.]+/g, ""), p *= Number(l)
                    }
                    return p
                },
                isNaN: function(l) {
                    return typeof l == "number" && isNaN(l)
                },
                includes: function(l, u) {
                    return l.indexOf(u) !== -1
                },
                insert: function(l, u, f) {
                    return l.slice(0, f) + u + l.slice(f)
                },
                reduce: function(l, u) {
                    if (this === null) throw new TypeError("Array.prototype.reduce called on null or undefined");
                    if (typeof u != "function") throw new TypeError(u + " is not a function");
                    var f = Object(l),
                        d = f.length >>> 0,
                        h = 0,
                        p;
                    if (arguments.length === 3) p = arguments[2];
                    else {
                        for (; h < d && !(h in f);) h++;
                        if (h >= d) throw new TypeError("Reduce of empty array with no initial value");
                        p = f[h++]
                    }
                    for (; h < d; h++) h in f && (p = u(p, f[h], h, f));
                    return p
                },
                multiplier: function(l) {
                    var u = l.toString().split(".");
                    return u.length < 2 ? 1 : Math.pow(10, u[1].length)
                },
                correctionFactor: function() {
                    var l = Array.prototype.slice.call(arguments);
                    return l.reduce(function(u, f) {
                        var d = n.multiplier(f);
                        return u > d ? u : d
                    }, 1)
                },
                toFixed: function(l, u, f, d) {
                    var h = l.toString().split("."),
                        p = u - (d || 0),
                        g, b, x, w;
                    return h.length === 2 ? g = Math.min(Math.max(h[1].length, p), u) : g = p, x = Math.pow(10, g), w = (f(l + "e+" + g) / x).toFixed(g), d > u - g && (b = new RegExp("\\.?0{1," + (d - (u - g)) + "}$"), w = w.replace(b, "")), w
                }
            }, e.options = a, e.formats = i, e.locales = s, e.locale = function(l) {
                return l && (a.currentLocale = l.toLowerCase()), a.currentLocale
            }, e.localeData = function(l) {
                if (!l) return s[a.currentLocale];
                if (l = l.toLowerCase(), !s[l]) throw new Error("Unknown locale : " + l);
                return s[l]
            }, e.reset = function() {
                for (var l in o) a[l] = o[l]
            }, e.zeroFormat = function(l) {
                a.zeroFormat = typeof l == "string" ? l : null
            }, e.nullFormat = function(l) {
                a.nullFormat = typeof l == "string" ? l : null
            }, e.defaultFormat = function(l) {
                a.defaultFormat = typeof l == "string" ? l : "0.0"
            }, e.register = function(l, u, f) {
                if (u = u.toLowerCase(), this[l + "s"][u]) throw new TypeError(u + " " + l + " already registered.");
                return this[l + "s"][u] = f, f
            }, e.validate = function(l, u) {
                var f, d, h, p, g, b, x, w;
                if (typeof l != "string" && (l += "", console.warn && console.warn("Numeral.js: Value is not string. It has been co-erced to: ", l)), l = l.trim(), l.match(/^\d+$/)) return !0;
                if (l === "") return !1;
                try {
                    x = e.localeData(u)
                } catch {
                    x = e.localeData(e.locale())
                }
                return h = x.currency.symbol, g = x.abbreviations, f = x.delimiters.decimal, x.delimiters.thousands === "." ? d = "\\." : d = x.delimiters.thousands, w = l.match(/^[^\d]+/), w !== null && (l = l.substr(1), w[0] !== h) || (w = l.match(/[^\d]+$/), w !== null && (l = l.slice(0, -1), w[0] !== g.thousand && w[0] !== g.million && w[0] !== g.billion && w[0] !== g.trillion)) ? !1 : (b = new RegExp(d + "{2}"), l.match(/[^\d.,]/g) ? !1 : (p = l.split(f), p.length > 2 ? !1 : p.length < 2 ? !!p[0].match(/^\d+.*\d$/) && !p[0].match(b) : p[0].length === 1 ? !!p[0].match(/^\d+$/) && !p[0].match(b) && !!p[1].match(/^\d+$/) : !!p[0].match(/^\d+.*\d$/) && !p[0].match(b) && !!p[1].match(/^\d+$/)))
            }, e.fn = c.prototype = {
                clone: function() {
                    return e(this)
                },
                format: function(l, u) {
                    var f = this._value,
                        d = l || a.defaultFormat,
                        h, p, g;
                    if (u = u || Math.round, f === 0 && a.zeroFormat !== null) p = a.zeroFormat;
                    else if (f === null && a.nullFormat !== null) p = a.nullFormat;
                    else {
                        for (h in i)
                            if (d.match(i[h].regexps.format)) {
                                g = i[h].format;
                                break
                            }
                        g = g || e._.numberToFormat, p = g(f, d, u)
                    }
                    return p
                },
                value: function() {
                    return this._value
                },
                input: function() {
                    return this._input
                },
                set: function(l) {
                    return this._value = Number(l), this
                },
                add: function(l) {
                    var u = n.correctionFactor.call(null, this._value, l);

                    function f(d, h, p, g) {
                        return d + Math.round(u * h)
                    }
                    return this._value = n.reduce([this._value, l], f, 0) / u, this
                },
                subtract: function(l) {
                    var u = n.correctionFactor.call(null, this._value, l);

                    function f(d, h, p, g) {
                        return d - Math.round(u * h)
                    }
                    return this._value = n.reduce([l], f, Math.round(this._value * u)) / u, this
                },
                multiply: function(l) {
                    function u(f, d, h, p) {
                        var g = n.correctionFactor(f, d);
                        return Math.round(f * g) * Math.round(d * g) / Math.round(g * g)
                    }
                    return this._value = n.reduce([this._value, l], u, 1), this
                },
                divide: function(l) {
                    function u(f, d, h, p) {
                        var g = n.correctionFactor(f, d);
                        return Math.round(f * g) / Math.round(d * g)
                    }
                    return this._value = n.reduce([this._value, l], u), this
                },
                difference: function(l) {
                    return Math.abs(e(this._value).subtract(l).value())
                }
            }, e.register("locale", "en", {
                delimiters: {
                    thousands: ",",
                    decimal: "."
                },
                abbreviations: {
                    thousand: "k",
                    million: "m",
                    billion: "b",
                    trillion: "t"
                },
                ordinal: function(l) {
                    var u = l % 10;
                    return ~~(l % 100 / 10) === 1 ? "th" : u === 1 ? "st" : u === 2 ? "nd" : u === 3 ? "rd" : "th"
                },
                currency: {
                    symbol: "$"
                }
            }),
            function() {
                e.register("format", "bps", {
                    regexps: {
                        format: /(BPS)/,
                        unformat: /(BPS)/
                    },
                    format: function(l, u, f) {
                        var d = e._.includes(u, " BPS") ? " " : "",
                            h;
                        return l = l * 1e4, u = u.replace(/\s?BPS/, ""), h = e._.numberToFormat(l, u, f), e._.includes(h, ")") ? (h = h.split(""), h.splice(-1, 0, d + "BPS"), h = h.join("")) : h = h + d + "BPS", h
                    },
                    unformat: function(l) {
                        return +(e._.stringToNumber(l) * 1e-4).toFixed(15)
                    }
                })
            }(),
            function() {
                var l = {
                        base: 1e3,
                        suffixes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
                    },
                    u = {
                        base: 1024,
                        suffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
                    },
                    f = l.suffixes.concat(u.suffixes.filter(function(h) {
                        return l.suffixes.indexOf(h) < 0
                    })),
                    d = f.join("|");
                d = "(" + d.replace("B", "B(?!PS)") + ")", e.register("format", "bytes", {
                    regexps: {
                        format: /([0\s]i?b)/,
                        unformat: new RegExp(d)
                    },
                    format: function(h, p, g) {
                        var b, x = e._.includes(p, "ib") ? u : l,
                            w = e._.includes(p, " b") || e._.includes(p, " ib") ? " " : "",
                            O, N, U;
                        for (p = p.replace(/\s?i?b/, ""), O = 0; O <= x.suffixes.length; O++)
                            if (N = Math.pow(x.base, O), U = Math.pow(x.base, O + 1), h === null || h === 0 || h >= N && h < U) {
                                w += x.suffixes[O], N > 0 && (h = h / N);
                                break
                            }
                        return b = e._.numberToFormat(h, p, g), b + w
                    },
                    unformat: function(h) {
                        var p = e._.stringToNumber(h),
                            g, b;
                        if (p) {
                            for (g = l.suffixes.length - 1; g >= 0; g--) {
                                if (e._.includes(h, l.suffixes[g])) {
                                    b = Math.pow(l.base, g);
                                    break
                                }
                                if (e._.includes(h, u.suffixes[g])) {
                                    b = Math.pow(u.base, g);
                                    break
                                }
                            }
                            p *= b || 1
                        }
                        return p
                    }
                })
            }(),
            function() {
                e.register("format", "currency", {
                    regexps: {
                        format: /(\$)/
                    },
                    format: function(l, u, f) {
                        var d = e.locales[e.options.currentLocale],
                            h = {
                                before: u.match(/^([\+|\-|\(|\s|\$]*)/)[0],
                                after: u.match(/([\+|\-|\)|\s|\$]*)$/)[0]
                            },
                            p, g, b;
                        for (u = u.replace(/\s?\$\s?/, ""), p = e._.numberToFormat(l, u, f), l >= 0 ? (h.before = h.before.replace(/[\-\(]/, ""), h.after = h.after.replace(/[\-\)]/, "")) : l < 0 && !e._.includes(h.before, "-") && !e._.includes(h.before, "(") && (h.before = "-" + h.before), b = 0; b < h.before.length; b++) switch (g = h.before[b], g) {
                            case "$":
                                p = e._.insert(p, d.currency.symbol, b);
                                break;
                            case " ":
                                p = e._.insert(p, " ", b + d.currency.symbol.length - 1);
                                break
                        }
                        for (b = h.after.length - 1; b >= 0; b--) switch (g = h.after[b], g) {
                            case "$":
                                p = b === h.after.length - 1 ? p + d.currency.symbol : e._.insert(p, d.currency.symbol, -(h.after.length - (1 + b)));
                                break;
                            case " ":
                                p = b === h.after.length - 1 ? p + " " : e._.insert(p, " ", -(h.after.length - (1 + b) + d.currency.symbol.length - 1));
                                break
                        }
                        return p
                    }
                })
            }(),
            function() {
                e.register("format", "exponential", {
                    regexps: {
                        format: /(e\+|e-)/,
                        unformat: /(e\+|e-)/
                    },
                    format: function(l, u, f) {
                        var d, h = typeof l == "number" && !e._.isNaN(l) ? l.toExponential() : "0e+0",
                            p = h.split("e");
                        return u = u.replace(/e[\+|\-]{1}0/, ""), d = e._.numberToFormat(Number(p[0]), u, f), d + "e" + p[1]
                    },
                    unformat: function(l) {
                        var u = e._.includes(l, "e+") ? l.split("e+") : l.split("e-"),
                            f = Number(u[0]),
                            d = Number(u[1]);
                        d = e._.includes(l, "e-") ? d *= -1 : d;

                        function h(p, g, b, x) {
                            var w = e._.correctionFactor(p, g),
                                O = p * w * (g * w) / (w * w);
                            return O
                        }
                        return e._.reduce([f, Math.pow(10, d)], h, 1)
                    }
                })
            }(),
            function() {
                e.register("format", "ordinal", {
                    regexps: {
                        format: /(o)/
                    },
                    format: function(l, u, f) {
                        var d = e.locales[e.options.currentLocale],
                            h, p = e._.includes(u, " o") ? " " : "";
                        return u = u.replace(/\s?o/, ""), p += d.ordinal(l), h = e._.numberToFormat(l, u, f), h + p
                    }
                })
            }(),
            function() {
                e.register("format", "percentage", {
                    regexps: {
                        format: /(%)/,
                        unformat: /(%)/
                    },
                    format: function(l, u, f) {
                        var d = e._.includes(u, " %") ? " " : "",
                            h;
                        return e.options.scalePercentBy100 && (l = l * 100), u = u.replace(/\s?\%/, ""), h = e._.numberToFormat(l, u, f), e._.includes(h, ")") ? (h = h.split(""), h.splice(-1, 0, d + "%"), h = h.join("")) : h = h + d + "%", h
                    },
                    unformat: function(l) {
                        var u = e._.stringToNumber(l);
                        return e.options.scalePercentBy100 ? u * .01 : u
                    }
                })
            }(),
            function() {
                e.register("format", "time", {
                    regexps: {
                        format: /(:)/,
                        unformat: /(:)/
                    },
                    format: function(l, u, f) {
                        var d = Math.floor(l / 60 / 60),
                            h = Math.floor((l - d * 60 * 60) / 60),
                            p = Math.round(l - d * 60 * 60 - h * 60);
                        return d + ":" + (h < 10 ? "0" + h : h) + ":" + (p < 10 ? "0" + p : p)
                    },
                    unformat: function(l) {
                        var u = l.split(":"),
                            f = 0;
                        return u.length === 3 ? (f = f + Number(u[0]) * 60 * 60, f = f + Number(u[1]) * 60, f = f + Number(u[2])) : u.length === 2 && (f = f + Number(u[0]) * 60, f = f + Number(u[1])), Number(f)
                    }
                })
            }(), e
    })
})(P2);
var eC = P2.exports;
const ba = E2(eC);

function yc(t) {
    return [null, void 0, !1].indexOf(t) !== -1
}

function tC(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}

function S2(t) {
    var e = {
        exports: {}
    };
    return t(e, e.exports), e.exports
}
var G1 = S2(function(t, e) {
        t.exports = function() {
            var n = ["decimals", "thousand", "mark", "prefix", "suffix", "encoder", "decoder", "negativeBefore", "negative", "edit", "undo"];

            function r(p) {
                return p.split("").reverse().join("")
            }

            function i(p, g) {
                return p.substring(0, g.length) === g
            }

            function s(p, g) {
                return p.slice(-1 * g.length) === g
            }

            function o(p, g, b) {
                if ((p[g] || p[b]) && p[g] === p[b]) throw new Error(g)
            }

            function a(p) {
                return typeof p == "number" && isFinite(p)
            }

            function c(p, g) {
                return p = p.toString().split("e"), (+((p = (p = Math.round(+(p[0] + "e" + (p[1] ? +p[1] + g : g)))).toString().split("e"))[0] + "e" + (p[1] ? +p[1] - g : -g))).toFixed(g)
            }

            function l(p, g, b, x, w, O, N, U, H, M, y, v) {
                var A, E, P, R = v,
                    F = "",
                    _ = "";
                return O && (v = O(v)), !!a(v) && (p !== !1 && parseFloat(v.toFixed(p)) === 0 && (v = 0), v < 0 && (A = !0, v = Math.abs(v)), p !== !1 && (v = c(v, p)), (v = v.toString()).indexOf(".") !== -1 ? (P = (E = v.split("."))[0], b && (F = b + E[1])) : P = v, g && (P = r(P).match(/.{1,3}/g), P = r(P.join(r(g)))), A && U && (_ += U), x && (_ += x), A && H && (_ += H), _ += P, _ += F, w && (_ += w), M && (_ = M(_, R)), _)
            }

            function u(p, g, b, x, w, O, N, U, H, M, y, v) {
                var A, E = "";
                return y && (v = y(v)), !(!v || typeof v != "string") && (U && i(v, U) && (v = v.replace(U, ""), A = !0), x && i(v, x) && (v = v.replace(x, "")), H && i(v, H) && (v = v.replace(H, ""), A = !0), w && s(v, w) && (v = v.slice(0, -1 * w.length)), g && (v = v.split(g).join("")), b && (v = v.replace(b, ".")), A && (E += "-"), (E = (E += v).replace(/[^0-9\.\-.]/g, "")) !== "" && (E = Number(E), N && (E = N(E)), !!a(E) && E))
            }

            function f(p) {
                var g, b, x, w = {};
                for (p.suffix === void 0 && (p.suffix = p.postfix), g = 0; g < n.length; g += 1)
                    if ((x = p[b = n[g]]) === void 0) b !== "negative" || w.negativeBefore ? b === "mark" && w.thousand !== "." ? w[b] = "." : w[b] = !1 : w[b] = "-";
                    else if (b === "decimals") {
                    if (!(x >= 0 && x < 8)) throw new Error(b);
                    w[b] = x
                } else if (b === "encoder" || b === "decoder" || b === "edit" || b === "undo") {
                    if (typeof x != "function") throw new Error(b);
                    w[b] = x
                } else {
                    if (typeof x != "string") throw new Error(b);
                    w[b] = x
                }
                return o(w, "mark", "thousand"), o(w, "prefix", "negative"), o(w, "prefix", "negativeBefore"), w
            }

            function d(p, g, b) {
                var x, w = [];
                for (x = 0; x < n.length; x += 1) w.push(p[n[x]]);
                return w.push(b), g.apply("", w)
            }

            function h(p) {
                if (!(this instanceof h)) return new h(p);
                typeof p == "object" && (p = f(p), this.to = function(g) {
                    return d(p, l, g)
                }, this.from = function(g) {
                    return d(p, u, g)
                })
            }
            return h
        }()
    }),
    nC = tC(S2(function(t, e) {
        (function(n) {
            function r(D) {
                return i(D) && typeof D.from == "function"
            }

            function i(D) {
                return typeof D == "object" && typeof D.to == "function"
            }

            function s(D) {
                D.parentElement.removeChild(D)
            }

            function o(D) {
                return D != null
            }

            function a(D) {
                D.preventDefault()
            }

            function c(D) {
                return D.filter(function(k) {
                    return !this[k] && (this[k] = !0)
                }, {})
            }

            function l(D, k) {
                return Math.round(D / k) * k
            }

            function u(D, k) {
                var le = D.getBoundingClientRect(),
                    Ee = D.ownerDocument,
                    pe = Ee.documentElement,
                    Ie = O(Ee);
                return /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (Ie.x = 0), k ? le.top + Ie.y - pe.clientTop : le.left + Ie.x - pe.clientLeft
            }

            function f(D) {
                return typeof D == "number" && !isNaN(D) && isFinite(D)
            }

            function d(D, k, le) {
                le > 0 && (b(D, k), setTimeout(function() {
                    x(D, k)
                }, le))
            }

            function h(D) {
                return Math.max(Math.min(D, 100), 0)
            }

            function p(D) {
                return Array.isArray(D) ? D : [D]
            }

            function g(D) {
                var k = (D = String(D)).split(".");
                return k.length > 1 ? k[1].length : 0
            }

            function b(D, k) {
                D.classList && !/\s/.test(k) ? D.classList.add(k) : D.className += " " + k
            }

            function x(D, k) {
                D.classList && !/\s/.test(k) ? D.classList.remove(k) : D.className = D.className.replace(new RegExp("(^|\\b)" + k.split(" ").join("|") + "(\\b|$)", "gi"), " ")
            }

            function w(D, k) {
                return D.classList ? D.classList.contains(k) : new RegExp("\\b" + k + "\\b").test(D.className)
            }

            function O(D) {
                var k = window.pageXOffset !== void 0,
                    le = (D.compatMode || "") === "CSS1Compat";
                return {
                    x: k ? window.pageXOffset : le ? D.documentElement.scrollLeft : D.body.scrollLeft,
                    y: k ? window.pageYOffset : le ? D.documentElement.scrollTop : D.body.scrollTop
                }
            }

            function N() {
                return window.navigator.pointerEnabled ? {
                    start: "pointerdown",
                    move: "pointermove",
                    end: "pointerup"
                } : window.navigator.msPointerEnabled ? {
                    start: "MSPointerDown",
                    move: "MSPointerMove",
                    end: "MSPointerUp"
                } : {
                    start: "mousedown touchstart",
                    move: "mousemove touchmove",
                    end: "mouseup touchend"
                }
            }

            function U() {
                var D = !1;
                try {
                    var k = Object.defineProperty({}, "passive", {
                        get: function() {
                            D = !0
                        }
                    });
                    window.addEventListener("test", null, k)
                } catch {}
                return D
            }

            function H() {
                return window.CSS && CSS.supports && CSS.supports("touch-action", "none")
            }

            function M(D, k) {
                return 100 / (k - D)
            }

            function y(D, k, le) {
                return 100 * k / (D[le + 1] - D[le])
            }

            function v(D, k) {
                return y(D, D[0] < 0 ? k + Math.abs(D[0]) : k - D[0], 0)
            }

            function A(D, k) {
                return k * (D[1] - D[0]) / 100 + D[0]
            }

            function E(D, k) {
                for (var le = 1; D >= k[le];) le += 1;
                return le
            }

            function P(D, k, le) {
                if (le >= D.slice(-1)[0]) return 100;
                var Ee = E(le, D),
                    pe = D[Ee - 1],
                    Ie = D[Ee],
                    je = k[Ee - 1],
                    et = k[Ee];
                return je + v([pe, Ie], le) / M(je, et)
            }

            function R(D, k, le) {
                if (le >= 100) return D.slice(-1)[0];
                var Ee = E(le, k),
                    pe = D[Ee - 1],
                    Ie = D[Ee],
                    je = k[Ee - 1];
                return A([pe, Ie], (le - je) * M(je, k[Ee]))
            }

            function F(D, k, le, Ee) {
                if (Ee === 100) return Ee;
                var pe = E(Ee, D),
                    Ie = D[pe - 1],
                    je = D[pe];
                return le ? Ee - Ie > (je - Ie) / 2 ? je : Ie : k[pe - 1] ? D[pe - 1] + l(Ee - D[pe - 1], k[pe - 1]) : Ee
            }
            var _, S;
            n.PipsMode = void 0, (S = n.PipsMode || (n.PipsMode = {})).Range = "range", S.Steps = "steps", S.Positions = "positions", S.Count = "count", S.Values = "values", n.PipsType = void 0, (_ = n.PipsType || (n.PipsType = {}))[_.None = -1] = "None", _[_.NoValue = 0] = "NoValue", _[_.LargeValue = 1] = "LargeValue", _[_.SmallValue = 2] = "SmallValue";
            var I = function() {
                    function D(k, le, Ee) {
                        var pe;
                        this.xPct = [], this.xVal = [], this.xSteps = [], this.xNumSteps = [], this.xHighestCompleteStep = [], this.xSteps = [Ee || !1], this.xNumSteps = [!1], this.snap = le;
                        var Ie = [];
                        for (Object.keys(k).forEach(function(je) {
                                Ie.push([p(k[je]), je])
                            }), Ie.sort(function(je, et) {
                                return je[0][0] - et[0][0]
                            }), pe = 0; pe < Ie.length; pe++) this.handleEntryPoint(Ie[pe][1], Ie[pe][0]);
                        for (this.xNumSteps = this.xSteps.slice(0), pe = 0; pe < this.xNumSteps.length; pe++) this.handleStepPoint(pe, this.xNumSteps[pe])
                    }
                    return D.prototype.getDistance = function(k) {
                        for (var le = [], Ee = 0; Ee < this.xNumSteps.length - 1; Ee++) le[Ee] = y(this.xVal, k, Ee);
                        return le
                    }, D.prototype.getAbsoluteDistance = function(k, le, Ee) {
                        var pe, Ie = 0;
                        if (k < this.xPct[this.xPct.length - 1])
                            for (; k > this.xPct[Ie + 1];) Ie++;
                        else k === this.xPct[this.xPct.length - 1] && (Ie = this.xPct.length - 2);
                        Ee || k !== this.xPct[Ie + 1] || Ie++, le === null && (le = []);
                        var je = 1,
                            et = le[Ie],
                            mt = 0,
                            $n = 0,
                            jt = 0,
                            Ve = 0;
                        for (pe = Ee ? (k - this.xPct[Ie]) / (this.xPct[Ie + 1] - this.xPct[Ie]) : (this.xPct[Ie + 1] - k) / (this.xPct[Ie + 1] - this.xPct[Ie]); et > 0;) mt = this.xPct[Ie + 1 + Ve] - this.xPct[Ie + Ve], le[Ie + Ve] * je + 100 - 100 * pe > 100 ? ($n = mt * pe, je = (et - 100 * pe) / le[Ie + Ve], pe = 1) : ($n = le[Ie + Ve] * mt / 100 * je, je = 0), Ee ? (jt -= $n, this.xPct.length + Ve >= 1 && Ve--) : (jt += $n, this.xPct.length - Ve >= 1 && Ve++), et = le[Ie + Ve] * je;
                        return k + jt
                    }, D.prototype.toStepping = function(k) {
                        return k = P(this.xVal, this.xPct, k)
                    }, D.prototype.fromStepping = function(k) {
                        return R(this.xVal, this.xPct, k)
                    }, D.prototype.getStep = function(k) {
                        return k = F(this.xPct, this.xSteps, this.snap, k)
                    }, D.prototype.getDefaultStep = function(k, le, Ee) {
                        var pe = E(k, this.xPct);
                        return (k === 100 || le && k === this.xPct[pe - 1]) && (pe = Math.max(pe - 1, 1)), (this.xVal[pe] - this.xVal[pe - 1]) / Ee
                    }, D.prototype.getNearbySteps = function(k) {
                        var le = E(k, this.xPct);
                        return {
                            stepBefore: {
                                startValue: this.xVal[le - 2],
                                step: this.xNumSteps[le - 2],
                                highestStep: this.xHighestCompleteStep[le - 2]
                            },
                            thisStep: {
                                startValue: this.xVal[le - 1],
                                step: this.xNumSteps[le - 1],
                                highestStep: this.xHighestCompleteStep[le - 1]
                            },
                            stepAfter: {
                                startValue: this.xVal[le],
                                step: this.xNumSteps[le],
                                highestStep: this.xHighestCompleteStep[le]
                            }
                        }
                    }, D.prototype.countStepDecimals = function() {
                        var k = this.xNumSteps.map(g);
                        return Math.max.apply(null, k)
                    }, D.prototype.hasNoSize = function() {
                        return this.xVal[0] === this.xVal[this.xVal.length - 1]
                    }, D.prototype.convert = function(k) {
                        return this.getStep(this.toStepping(k))
                    }, D.prototype.handleEntryPoint = function(k, le) {
                        var Ee;
                        if (!f(Ee = k === "min" ? 0 : k === "max" ? 100 : parseFloat(k)) || !f(le[0])) throw new Error("noUiSlider: 'range' value isn't numeric.");
                        this.xPct.push(Ee), this.xVal.push(le[0]);
                        var pe = Number(le[1]);
                        Ee ? this.xSteps.push(!isNaN(pe) && pe) : isNaN(pe) || (this.xSteps[0] = pe), this.xHighestCompleteStep.push(0)
                    }, D.prototype.handleStepPoint = function(k, le) {
                        if (le)
                            if (this.xVal[k] !== this.xVal[k + 1]) {
                                this.xSteps[k] = y([this.xVal[k], this.xVal[k + 1]], le, 0) / M(this.xPct[k], this.xPct[k + 1]);
                                var Ee = (this.xVal[k + 1] - this.xVal[k]) / this.xNumSteps[k],
                                    pe = Math.ceil(Number(Ee.toFixed(3)) - 1),
                                    Ie = this.xVal[k] + this.xNumSteps[k] * pe;
                                this.xHighestCompleteStep[k] = Ie
                            } else this.xSteps[k] = this.xHighestCompleteStep[k] = this.xVal[k]
                    }, D
                }(),
                B = {
                    to: function(D) {
                        return D === void 0 ? "" : D.toFixed(2)
                    },
                    from: Number
                },
                j = {
                    target: "target",
                    base: "base",
                    origin: "origin",
                    handle: "handle",
                    handleLower: "handle-lower",
                    handleUpper: "handle-upper",
                    touchArea: "touch-area",
                    horizontal: "horizontal",
                    vertical: "vertical",
                    background: "background",
                    connect: "connect",
                    connects: "connects",
                    ltr: "ltr",
                    rtl: "rtl",
                    textDirectionLtr: "txt-dir-ltr",
                    textDirectionRtl: "txt-dir-rtl",
                    draggable: "draggable",
                    drag: "state-drag",
                    tap: "state-tap",
                    active: "active",
                    tooltip: "tooltip",
                    pips: "pips",
                    pipsHorizontal: "pips-horizontal",
                    pipsVertical: "pips-vertical",
                    marker: "marker",
                    markerHorizontal: "marker-horizontal",
                    markerVertical: "marker-vertical",
                    markerNormal: "marker-normal",
                    markerLarge: "marker-large",
                    markerSub: "marker-sub",
                    value: "value",
                    valueHorizontal: "value-horizontal",
                    valueVertical: "value-vertical",
                    valueNormal: "value-normal",
                    valueLarge: "value-large",
                    valueSub: "value-sub"
                },
                Y = {
                    tooltips: ".__tooltips",
                    aria: ".__aria"
                };

            function te(D, k) {
                if (!f(k)) throw new Error("noUiSlider: 'step' is not numeric.");
                D.singleStep = k
            }

            function he(D, k) {
                if (!f(k)) throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric.");
                D.keyboardPageMultiplier = k
            }

            function Te(D, k) {
                if (!f(k)) throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric.");
                D.keyboardMultiplier = k
            }

            function Be(D, k) {
                if (!f(k)) throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric.");
                D.keyboardDefaultStep = k
            }

            function ve(D, k) {
                if (typeof k != "object" || Array.isArray(k)) throw new Error("noUiSlider: 'range' is not an object.");
                if (k.min === void 0 || k.max === void 0) throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'.");
                D.spectrum = new I(k, D.snap || !1, D.singleStep)
            }

            function X(D, k) {
                if (k = p(k), !Array.isArray(k) || !k.length) throw new Error("noUiSlider: 'start' option is incorrect.");
                D.handles = k.length, D.start = k
            }

            function V(D, k) {
                if (typeof k != "boolean") throw new Error("noUiSlider: 'snap' option must be a boolean.");
                D.snap = k
            }

            function oe(D, k) {
                if (typeof k != "boolean") throw new Error("noUiSlider: 'animate' option must be a boolean.");
                D.animate = k
            }

            function ae(D, k) {
                if (typeof k != "number") throw new Error("noUiSlider: 'animationDuration' option must be a number.");
                D.animationDuration = k
            }

            function Ae(D, k) {
                var le, Ee = [!1];
                if (k === "lower" ? k = [!0, !1] : k === "upper" && (k = [!1, !0]), k === !0 || k === !1) {
                    for (le = 1; le < D.handles; le++) Ee.push(k);
                    Ee.push(!1)
                } else {
                    if (!Array.isArray(k) || !k.length || k.length !== D.handles + 1) throw new Error("noUiSlider: 'connect' option doesn't match handle count.");
                    Ee = k
                }
                D.connect = Ee
            }

            function Fe(D, k) {
                switch (k) {
                    case "horizontal":
                        D.ort = 0;
                        break;
                    case "vertical":
                        D.ort = 1;
                        break;
                    default:
                        throw new Error("noUiSlider: 'orientation' option is invalid.")
                }
            }

            function C(D, k) {
                if (!f(k)) throw new Error("noUiSlider: 'margin' option must be numeric.");
                k !== 0 && (D.margin = D.spectrum.getDistance(k))
            }

            function T(D, k) {
                if (!f(k)) throw new Error("noUiSlider: 'limit' option must be numeric.");
                if (D.limit = D.spectrum.getDistance(k), !D.limit || D.handles < 2) throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.")
            }

            function z(D, k) {
                var le;
                if (!f(k) && !Array.isArray(k)) throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
                if (Array.isArray(k) && k.length !== 2 && !f(k[0]) && !f(k[1])) throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.");
                if (k !== 0) {
                    for (Array.isArray(k) || (k = [k, k]), D.padding = [D.spectrum.getDistance(k[0]), D.spectrum.getDistance(k[1])], le = 0; le < D.spectrum.xNumSteps.length - 1; le++)
                        if (D.padding[0][le] < 0 || D.padding[1][le] < 0) throw new Error("noUiSlider: 'padding' option must be a positive number(s).");
                    var Ee = k[0] + k[1],
                        pe = D.spectrum.xVal[0];
                    if (Ee / (D.spectrum.xVal[D.spectrum.xVal.length - 1] - pe) > 1) throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.")
                }
            }

            function Q(D, k) {
                switch (k) {
                    case "ltr":
                        D.dir = 0;
                        break;
                    case "rtl":
                        D.dir = 1;
                        break;
                    default:
                        throw new Error("noUiSlider: 'direction' option was not recognized.")
                }
            }

            function $(D, k) {
                if (typeof k != "string") throw new Error("noUiSlider: 'behaviour' must be a string containing options.");
                var le = k.indexOf("tap") >= 0,
                    Ee = k.indexOf("drag") >= 0,
                    pe = k.indexOf("fixed") >= 0,
                    Ie = k.indexOf("snap") >= 0,
                    je = k.indexOf("hover") >= 0,
                    et = k.indexOf("unconstrained") >= 0,
                    mt = k.indexOf("drag-all") >= 0,
                    $n = k.indexOf("smooth-steps") >= 0;
                if (pe) {
                    if (D.handles !== 2) throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles");
                    C(D, D.start[1] - D.start[0])
                }
                if (et && (D.margin || D.limit)) throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit");
                D.events = {
                    tap: le || Ie,
                    drag: Ee,
                    dragAll: mt,
                    smoothSteps: $n,
                    fixed: pe,
                    snap: Ie,
                    hover: je,
                    unconstrained: et
                }
            }

            function ne(D, k) {
                if (k !== !1)
                    if (k === !0 || i(k)) {
                        D.tooltips = [];
                        for (var le = 0; le < D.handles; le++) D.tooltips.push(k)
                    } else {
                        if ((k = p(k)).length !== D.handles) throw new Error("noUiSlider: must pass a formatter for all handles.");
                        k.forEach(function(Ee) {
                            if (typeof Ee != "boolean" && !i(Ee)) throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.")
                        }), D.tooltips = k
                    }
            }

            function ge(D, k) {
                if (k.length !== D.handles) throw new Error("noUiSlider: must pass a attributes for all handles.");
                D.handleAttributes = k
            }

            function ce(D, k) {
                if (!i(k)) throw new Error("noUiSlider: 'ariaFormat' requires 'to' method.");
                D.ariaFormat = k
            }

            function ye(D, k) {
                if (!r(k)) throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods.");
                D.format = k
            }

            function se(D, k) {
                if (typeof k != "boolean") throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean.");
                D.keyboardSupport = k
            }

            function Ce(D, k) {
                D.documentElement = k
            }

            function _e(D, k) {
                if (typeof k != "string" && k !== !1) throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`.");
                D.cssPrefix = k
            }

            function Oe(D, k) {
                if (typeof k != "object") throw new Error("noUiSlider: 'cssClasses' must be an object.");
                typeof D.cssPrefix == "string" ? (D.cssClasses = {}, Object.keys(k).forEach(function(le) {
                    D.cssClasses[le] = D.cssPrefix + k[le]
                })) : D.cssClasses = k
            }

            function He(D) {
                var k = {
                        margin: null,
                        limit: null,
                        padding: null,
                        animate: !0,
                        animationDuration: 300,
                        ariaFormat: B,
                        format: B
                    },
                    le = {
                        step: {
                            r: !1,
                            t: te
                        },
                        keyboardPageMultiplier: {
                            r: !1,
                            t: he
                        },
                        keyboardMultiplier: {
                            r: !1,
                            t: Te
                        },
                        keyboardDefaultStep: {
                            r: !1,
                            t: Be
                        },
                        start: {
                            r: !0,
                            t: X
                        },
                        connect: {
                            r: !0,
                            t: Ae
                        },
                        direction: {
                            r: !0,
                            t: Q
                        },
                        snap: {
                            r: !1,
                            t: V
                        },
                        animate: {
                            r: !1,
                            t: oe
                        },
                        animationDuration: {
                            r: !1,
                            t: ae
                        },
                        range: {
                            r: !0,
                            t: ve
                        },
                        orientation: {
                            r: !1,
                            t: Fe
                        },
                        margin: {
                            r: !1,
                            t: C
                        },
                        limit: {
                            r: !1,
                            t: T
                        },
                        padding: {
                            r: !1,
                            t: z
                        },
                        behaviour: {
                            r: !0,
                            t: $
                        },
                        ariaFormat: {
                            r: !1,
                            t: ce
                        },
                        format: {
                            r: !1,
                            t: ye
                        },
                        tooltips: {
                            r: !1,
                            t: ne
                        },
                        keyboardSupport: {
                            r: !0,
                            t: se
                        },
                        documentElement: {
                            r: !1,
                            t: Ce
                        },
                        cssPrefix: {
                            r: !0,
                            t: _e
                        },
                        cssClasses: {
                            r: !0,
                            t: Oe
                        },
                        handleAttributes: {
                            r: !1,
                            t: ge
                        }
                    },
                    Ee = {
                        connect: !1,
                        direction: "ltr",
                        behaviour: "tap",
                        orientation: "horizontal",
                        keyboardSupport: !0,
                        cssPrefix: "noUi-",
                        cssClasses: j,
                        keyboardPageMultiplier: 5,
                        keyboardMultiplier: 1,
                        keyboardDefaultStep: 10
                    };
                D.format && !D.ariaFormat && (D.ariaFormat = D.format), Object.keys(le).forEach(function(mt) {
                    if (o(D[mt]) || Ee[mt] !== void 0) le[mt].t(k, o(D[mt]) ? D[mt] : Ee[mt]);
                    else if (le[mt].r) throw new Error("noUiSlider: '" + mt + "' is required.")
                }), k.pips = D.pips;
                var pe = document.createElement("div"),
                    Ie = pe.style.msTransform !== void 0,
                    je = pe.style.transform !== void 0;
                k.transformRule = je ? "transform" : Ie ? "msTransform" : "webkitTransform";
                var et = [
                    ["left", "top"],
                    ["right", "bottom"]
                ];
                return k.style = et[k.dir][k.ort], k
            }

            function Qe(D, k, le) {
                var Ee, pe, Ie, je, et, mt = N(),
                    $n = H() && U(),
                    jt = D,
                    Ve = k.spectrum,
                    In = [],
                    bt = [],
                    on = [],
                    Gs = 0,
                    er = {},
                    pi = D.ownerDocument,
                    Ws = k.documentElement || pi.documentElement,
                    Qs = pi.body,
                    Ml = pi.dir === "rtl" || k.ort === 1 ? 0 : 100;

                function ft(L, G) {
                    var K = pi.createElement("div");
                    return G && b(K, G), L.appendChild(K), K
                }

                function Fr(L, G) {
                    var K = ft(L, k.cssClasses.origin),
                        ie = ft(K, k.cssClasses.handle);
                    if (ft(ie, k.cssClasses.touchArea), ie.setAttribute("data-handle", String(G)), k.keyboardSupport && (ie.setAttribute("tabindex", "0"), ie.addEventListener("keydown", function(xe) {
                            return MA(xe, G)
                        })), k.handleAttributes !== void 0) {
                        var ke = k.handleAttributes[G];
                        Object.keys(ke).forEach(function(xe) {
                            ie.setAttribute(xe, ke[xe])
                        })
                    }
                    return ie.setAttribute("role", "slider"), ie.setAttribute("aria-orientation", k.ort ? "vertical" : "horizontal"), G === 0 ? b(ie, k.cssClasses.handleLower) : G === k.handles - 1 && b(ie, k.cssClasses.handleUpper), K
                }

                function en(L, G) {
                    return !!G && ft(L, k.cssClasses.connect)
                }

                function tr(L, G) {
                    var K = ft(G, k.cssClasses.connects);
                    pe = [], (Ie = []).push(en(K, L[0]));
                    for (var ie = 0; ie < k.handles; ie++) pe.push(Fr(G, ie)), on[ie] = ie, Ie.push(en(K, L[ie + 1]))
                }

                function Ur(L) {
                    return b(L, k.cssClasses.target), k.dir === 0 ? b(L, k.cssClasses.ltr) : b(L, k.cssClasses.rtl), k.ort === 0 ? b(L, k.cssClasses.horizontal) : b(L, k.cssClasses.vertical), b(L, getComputedStyle(L).direction === "rtl" ? k.cssClasses.textDirectionRtl : k.cssClasses.textDirectionLtr), ft(L, k.cssClasses.base)
                }

                function Js(L, G) {
                    return !(!k.tooltips || !k.tooltips[G]) && ft(L.firstChild, k.cssClasses.tooltip)
                }

                function Fl() {
                    return jt.hasAttribute("disabled")
                }

                function Ks(L) {
                    return pe[L].hasAttribute("disabled")
                }

                function Ul() {
                    et && (ra("update" + Y.tooltips), et.forEach(function(L) {
                        L && s(L)
                    }), et = null)
                }

                function ta() {
                    Ul(), et = pe.map(Js), vf("update" + Y.tooltips, function(L, G, K) {
                        if (et && k.tooltips && et[G] !== !1) {
                            var ie = L[G];
                            k.tooltips[G] !== !0 && (ie = k.tooltips[G].to(K[G])), et[G].innerHTML = ie
                        }
                    })
                }

                function hf() {
                    ra("update" + Y.aria), vf("update" + Y.aria, function(L, G, K, ie, ke) {
                        on.forEach(function(xe) {
                            var Je = pe[xe],
                                Se = jl(bt, xe, 0, !0, !0, !0),
                                Ft = jl(bt, xe, 100, !0, !0, !0),
                                Tt = ke[xe],
                                yt = String(k.ariaFormat.to(K[xe]));
                            Se = Ve.fromStepping(Se).toFixed(1), Ft = Ve.fromStepping(Ft).toFixed(1), Tt = Ve.fromStepping(Tt).toFixed(1), Je.children[0].setAttribute("aria-valuemin", Se), Je.children[0].setAttribute("aria-valuemax", Ft), Je.children[0].setAttribute("aria-valuenow", Tt), Je.children[0].setAttribute("aria-valuetext", yt)
                        })
                    })
                }

                function Hl(L) {
                    if (L.mode === n.PipsMode.Range || L.mode === n.PipsMode.Steps) return Ve.xVal;
                    if (L.mode === n.PipsMode.Count) {
                        if (L.values < 2) throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'.");
                        for (var G = L.values - 1, K = 100 / G, ie = []; G--;) ie[G] = G * K;
                        return ie.push(100), na(ie, L.stepped)
                    }
                    return L.mode === n.PipsMode.Positions ? na(L.values, L.stepped) : L.mode === n.PipsMode.Values ? L.stepped ? L.values.map(function(ke) {
                        return Ve.fromStepping(Ve.getStep(Ve.toStepping(ke)))
                    }) : L.values : []
                }

                function na(L, G) {
                    return L.map(function(K) {
                        return Ve.fromStepping(G ? Ve.getStep(K) : K)
                    })
                }

                function pf(L) {
                    function G(Tt, yt) {
                        return Number((Tt + yt).toFixed(7))
                    }
                    var K = Hl(L),
                        ie = {},
                        ke = Ve.xVal[0],
                        xe = Ve.xVal[Ve.xVal.length - 1],
                        Je = !1,
                        Se = !1,
                        Ft = 0;
                    return (K = c(K.slice().sort(function(Tt, yt) {
                        return Tt - yt
                    })))[0] !== ke && (K.unshift(ke), Je = !0), K[K.length - 1] !== xe && (K.push(xe), Se = !0), K.forEach(function(Tt, yt) {
                        var _t, dt, Zt, cn, Vt, Om, xf, Tm, Bm, Im, Af = Tt,
                            Ys = K[yt + 1],
                            Dm = L.mode === n.PipsMode.Steps;
                        for (Dm && (_t = Ve.xNumSteps[yt]), _t || (_t = Ys - Af), Ys === void 0 && (Ys = Af), _t = Math.max(_t, 1e-7), dt = Af; dt <= Ys; dt = G(dt, _t)) {
                            for (Tm = (Vt = (cn = Ve.toStepping(dt)) - Ft) / (L.density || 1), Im = Vt / (Bm = Math.round(Tm)), Zt = 1; Zt <= Bm; Zt += 1) ie[(Om = Ft + Zt * Im).toFixed(5)] = [Ve.fromStepping(Om), 0];
                            xf = K.indexOf(dt) > -1 ? n.PipsType.LargeValue : Dm ? n.PipsType.SmallValue : n.PipsType.NoValue, !yt && Je && dt !== Ys && (xf = 0), dt === Ys && Se || (ie[cn.toFixed(5)] = [dt, xf]), Ft = cn
                        }
                    }), ie
                }

                function zl(L, G, K) {
                    var ie, ke, xe = pi.createElement("div"),
                        Je = ((ie = {})[n.PipsType.None] = "", ie[n.PipsType.NoValue] = k.cssClasses.valueNormal, ie[n.PipsType.LargeValue] = k.cssClasses.valueLarge, ie[n.PipsType.SmallValue] = k.cssClasses.valueSub, ie),
                        Se = ((ke = {})[n.PipsType.None] = "", ke[n.PipsType.NoValue] = k.cssClasses.markerNormal, ke[n.PipsType.LargeValue] = k.cssClasses.markerLarge, ke[n.PipsType.SmallValue] = k.cssClasses.markerSub, ke),
                        Ft = [k.cssClasses.valueHorizontal, k.cssClasses.valueVertical],
                        Tt = [k.cssClasses.markerHorizontal, k.cssClasses.markerVertical];

                    function yt(dt, Zt) {
                        var cn = Zt === k.cssClasses.value,
                            Vt = cn ? Je : Se;
                        return Zt + " " + (cn ? Ft : Tt)[k.ort] + " " + Vt[dt]
                    }

                    function _t(dt, Zt, cn) {
                        if ((cn = G ? G(Zt, cn) : cn) !== n.PipsType.None) {
                            var Vt = ft(xe, !1);
                            Vt.className = yt(cn, k.cssClasses.marker), Vt.style[k.style] = dt + "%", cn > n.PipsType.NoValue && ((Vt = ft(xe, !1)).className = yt(cn, k.cssClasses.value), Vt.setAttribute("data-value", String(Zt)), Vt.style[k.style] = dt + "%", Vt.innerHTML = String(K.to(Zt)))
                        }
                    }
                    return b(xe, k.cssClasses.pips), b(xe, k.ort === 0 ? k.cssClasses.pipsHorizontal : k.cssClasses.pipsVertical), Object.keys(L).forEach(function(dt) {
                        _t(dt, L[dt][0], L[dt][1])
                    }), xe
                }

                function Zs() {
                    je && (s(je), je = null)
                }

                function mf(L) {
                    Zs();
                    var G = pf(L),
                        K = L.filter,
                        ie = L.format || {
                            to: function(ke) {
                                return String(Math.round(ke))
                            }
                        };
                    return je = jt.appendChild(zl(G, K, ie))
                }

                function km() {
                    var L = Ee.getBoundingClientRect(),
                        G = "offset" + ["Width", "Height"][k.ort];
                    return k.ort === 0 ? L.width || Ee[G] : L.height || Ee[G]
                }

                function Yi(L, G, K, ie) {
                    var ke = function(Je) {
                            var Se = OA(Je, ie.pageOffset, ie.target || G);
                            return !!Se && !(Fl() && !ie.doNotReject) && !(w(jt, k.cssClasses.tap) && !ie.doNotReject) && !(L === mt.start && Se.buttons !== void 0 && Se.buttons > 1) && (!ie.hover || !Se.buttons) && ($n || Se.preventDefault(), Se.calcPoint = Se.points[k.ort], void K(Se, ie))
                        },
                        xe = [];
                    return L.split(" ").forEach(function(Je) {
                        G.addEventListener(Je, ke, !!$n && {
                            passive: !0
                        }), xe.push([Je, ke])
                    }), xe
                }

                function OA(L, G, K) {
                    var ie = L.type.indexOf("touch") === 0,
                        ke = L.type.indexOf("mouse") === 0,
                        xe = L.type.indexOf("pointer") === 0,
                        Je = 0,
                        Se = 0;
                    if (L.type.indexOf("MSPointer") === 0 && (xe = !0), L.type === "mousedown" && !L.buttons && !L.touches) return !1;
                    if (ie) {
                        var Ft = function(_t) {
                            var dt = _t.target;
                            return dt === K || K.contains(dt) || L.composed && L.composedPath().shift() === K
                        };
                        if (L.type === "touchstart") {
                            var Tt = Array.prototype.filter.call(L.touches, Ft);
                            if (Tt.length > 1) return !1;
                            Je = Tt[0].pageX, Se = Tt[0].pageY
                        } else {
                            var yt = Array.prototype.find.call(L.changedTouches, Ft);
                            if (!yt) return !1;
                            Je = yt.pageX, Se = yt.pageY
                        }
                    }
                    return G = G || O(pi), (ke || xe) && (Je = L.clientX + G.x, Se = L.clientY + G.y), L.pageOffset = G, L.points = [Je, Se], L.cursor = ke || xe, L
                }

                function _m(L) {
                    var G = 100 * (L - u(Ee, k.ort)) / km();
                    return G = h(G), k.dir ? 100 - G : G
                }

                function TA(L) {
                    var G = 100,
                        K = !1;
                    return pe.forEach(function(ie, ke) {
                        if (!Ks(ke)) {
                            var xe = bt[ke],
                                Je = Math.abs(xe - L);
                            (Je < G || Je <= G && L > xe || Je === 100 && G === 100) && (K = ke, G = Je)
                        }
                    }), K
                }

                function BA(L, G) {
                    L.type === "mouseout" && L.target.nodeName === "HTML" && L.relatedTarget === null && gf(L, G)
                }

                function IA(L, G) {
                    if (navigator.appVersion.indexOf("MSIE 9") === -1 && L.buttons === 0 && G.buttonsProperty !== 0) return gf(L, G);
                    var K = (k.dir ? -1 : 1) * (L.calcPoint - G.startCalcPoint);
                    Em(K > 0, 100 * K / G.baseSize, G.locations, G.handleNumbers, G.connect)
                }

                function gf(L, G) {
                    G.handle && (x(G.handle, k.cssClasses.active), Gs -= 1), G.listeners.forEach(function(K) {
                        Ws.removeEventListener(K[0], K[1])
                    }), Gs === 0 && (x(jt, k.cssClasses.drag), wf(), L.cursor && (Qs.style.cursor = "", Qs.removeEventListener("selectstart", a))), k.events.smoothSteps && (G.handleNumbers.forEach(function(K) {
                        Xi(K, bt[K], !0, !0, !1, !1)
                    }), G.handleNumbers.forEach(function(K) {
                        Mt("update", K)
                    })), G.handleNumbers.forEach(function(K) {
                        Mt("change", K), Mt("set", K), Mt("end", K)
                    })
                }

                function yf(L, G) {
                    if (!G.handleNumbers.some(Ks)) {
                        var K;
                        G.handleNumbers.length === 1 && (K = pe[G.handleNumbers[0]].children[0], Gs += 1, b(K, k.cssClasses.active)), L.stopPropagation();
                        var ie = [],
                            ke = Yi(mt.move, Ws, IA, {
                                target: L.target,
                                handle: K,
                                connect: G.connect,
                                listeners: ie,
                                startCalcPoint: L.calcPoint,
                                baseSize: km(),
                                pageOffset: L.pageOffset,
                                handleNumbers: G.handleNumbers,
                                buttonsProperty: L.buttons,
                                locations: bt.slice()
                            }),
                            xe = Yi(mt.end, Ws, gf, {
                                target: L.target,
                                handle: K,
                                listeners: ie,
                                doNotReject: !0,
                                handleNumbers: G.handleNumbers
                            }),
                            Je = Yi("mouseout", Ws, BA, {
                                target: L.target,
                                handle: K,
                                listeners: ie,
                                doNotReject: !0,
                                handleNumbers: G.handleNumbers
                            });
                        ie.push.apply(ie, ke.concat(xe, Je)), L.cursor && (Qs.style.cursor = getComputedStyle(L.target).cursor, pe.length > 1 && b(jt, k.cssClasses.drag), Qs.addEventListener("selectstart", a, !1)), G.handleNumbers.forEach(function(Se) {
                            Mt("start", Se)
                        })
                    }
                }

                function DA(L) {
                    L.stopPropagation();
                    var G = _m(L.calcPoint),
                        K = TA(G);
                    K !== !1 && (k.events.snap || d(jt, k.cssClasses.tap, k.animationDuration), Xi(K, G, !0, !0), wf(), Mt("slide", K, !0), Mt("update", K, !0), k.events.snap ? yf(L, {
                        handleNumbers: [K]
                    }) : (Mt("change", K, !0), Mt("set", K, !0)))
                }

                function LA(L) {
                    var G = _m(L.calcPoint),
                        K = Ve.getStep(G),
                        ie = Ve.fromStepping(K);
                    Object.keys(er).forEach(function(ke) {
                        ke.split(".")[0] === "hover" && er[ke].forEach(function(xe) {
                            xe.call(Gl, ie)
                        })
                    })
                }

                function MA(L, G) {
                    if (Fl() || Ks(G)) return !1;
                    var K = ["Left", "Right"],
                        ie = ["Down", "Up"],
                        ke = ["PageDown", "PageUp"],
                        xe = ["Home", "End"];
                    k.dir && !k.ort ? K.reverse() : k.ort && !k.dir && (ie.reverse(), ke.reverse());
                    var Je, Se = L.key.replace("Arrow", ""),
                        Ft = Se === ke[0],
                        Tt = Se === ke[1],
                        yt = Se === ie[0] || Se === K[0] || Ft,
                        _t = Se === ie[1] || Se === K[1] || Tt,
                        dt = Se === xe[0],
                        Zt = Se === xe[1];
                    if (!(yt || _t || dt || Zt)) return !0;
                    if (L.preventDefault(), _t || yt) {
                        var cn = yt ? 0 : 1,
                            Vt = Cm(G)[cn];
                        if (Vt === null) return !1;
                        Vt === !1 && (Vt = Ve.getDefaultStep(bt[G], yt, k.keyboardDefaultStep)), Vt *= Tt || Ft ? k.keyboardPageMultiplier : k.keyboardMultiplier, Vt = Math.max(Vt, 1e-7), Vt *= yt ? -1 : 1, Je = In[G] + Vt
                    } else Je = Zt ? k.spectrum.xVal[k.spectrum.xVal.length - 1] : k.spectrum.xVal[0];
                    return Xi(G, Ve.toStepping(Je), !0, !0), Mt("slide", G), Mt("update", G), Mt("change", G), Mt("set", G), !1
                }

                function FA(L) {
                    L.fixed || pe.forEach(function(G, K) {
                        Yi(mt.start, G.children[0], yf, {
                            handleNumbers: [K]
                        })
                    }), L.tap && Yi(mt.start, Ee, DA, {}), L.hover && Yi(mt.move, Ee, LA, {
                        hover: !0
                    }), L.drag && Ie.forEach(function(G, K) {
                        if (G !== !1 && K !== 0 && K !== Ie.length - 1) {
                            var ie = pe[K - 1],
                                ke = pe[K],
                                xe = [G],
                                Je = [ie, ke],
                                Se = [K - 1, K];
                            b(G, k.cssClasses.draggable), L.fixed && (xe.push(ie.children[0]), xe.push(ke.children[0])), L.dragAll && (Je = pe, Se = on), xe.forEach(function(Ft) {
                                Yi(mt.start, Ft, yf, {
                                    handles: Je,
                                    handleNumbers: Se,
                                    connect: G
                                })
                            })
                        }
                    })
                }

                function vf(L, G) {
                    er[L] = er[L] || [], er[L].push(G), L.split(".")[0] === "update" && pe.forEach(function(K, ie) {
                        Mt("update", ie)
                    })
                }

                function UA(L) {
                    return L === Y.aria || L === Y.tooltips
                }

                function ra(L) {
                    var G = L && L.split(".")[0],
                        K = G ? L.substring(G.length) : L;
                    Object.keys(er).forEach(function(ie) {
                        var ke = ie.split(".")[0],
                            xe = ie.substring(ke.length);
                        G && G !== ke || K && K !== xe || UA(xe) && K !== xe || delete er[ie]
                    })
                }

                function Mt(L, G, K) {
                    Object.keys(er).forEach(function(ie) {
                        var ke = ie.split(".")[0];
                        L === ke && er[ie].forEach(function(xe) {
                            xe.call(Gl, In.map(k.format.to), G, In.slice(), K || !1, bt.slice(), Gl)
                        })
                    })
                }

                function jl(L, G, K, ie, ke, xe, Je) {
                    var Se;
                    return pe.length > 1 && !k.events.unconstrained && (ie && G > 0 && (Se = Ve.getAbsoluteDistance(L[G - 1], k.margin, !1), K = Math.max(K, Se)), ke && G < pe.length - 1 && (Se = Ve.getAbsoluteDistance(L[G + 1], k.margin, !0), K = Math.min(K, Se))), pe.length > 1 && k.limit && (ie && G > 0 && (Se = Ve.getAbsoluteDistance(L[G - 1], k.limit, !1), K = Math.min(K, Se)), ke && G < pe.length - 1 && (Se = Ve.getAbsoluteDistance(L[G + 1], k.limit, !0), K = Math.max(K, Se))), k.padding && (G === 0 && (Se = Ve.getAbsoluteDistance(0, k.padding[0], !1), K = Math.max(K, Se)), G === pe.length - 1 && (Se = Ve.getAbsoluteDistance(100, k.padding[1], !0), K = Math.min(K, Se))), Je || (K = Ve.getStep(K)), !((K = h(K)) === L[G] && !xe) && K
                }

                function bf(L, G) {
                    var K = k.ort;
                    return (K ? G : L) + ", " + (K ? L : G)
                }

                function Em(L, G, K, ie, ke) {
                    var xe = K.slice(),
                        Je = ie[0],
                        Se = k.events.smoothSteps,
                        Ft = [!L, L],
                        Tt = [L, !L];
                    ie = ie.slice(), L && ie.reverse(), ie.length > 1 ? ie.forEach(function(_t, dt) {
                        var Zt = jl(xe, _t, xe[_t] + G, Ft[dt], Tt[dt], !1, Se);
                        Zt === !1 ? G = 0 : (G = Zt - xe[_t], xe[_t] = Zt)
                    }) : Ft = Tt = [!0];
                    var yt = !1;
                    ie.forEach(function(_t, dt) {
                        yt = Xi(_t, K[_t] + G, Ft[dt], Tt[dt], !1, Se) || yt
                    }), yt && (ie.forEach(function(_t) {
                        Mt("update", _t), Mt("slide", _t)
                    }), ke != null && Mt("drag", Je))
                }

                function Pm(L, G) {
                    return k.dir ? 100 - L - G : L
                }

                function HA(L, G) {
                    bt[L] = G, In[L] = Ve.fromStepping(G);
                    var K = "translate(" + bf(Pm(G, 0) - Ml + "%", "0") + ")";
                    pe[L].style[k.transformRule] = K, Sm(L), Sm(L + 1)
                }

                function wf() {
                    on.forEach(function(L) {
                        var G = bt[L] > 50 ? -1 : 1,
                            K = 3 + (pe.length + G * L);
                        pe[L].style.zIndex = String(K)
                    })
                }

                function Xi(L, G, K, ie, ke, xe) {
                    return ke || (G = jl(bt, L, G, K, ie, !1, xe)), G !== !1 && (HA(L, G), !0)
                }

                function Sm(L) {
                    if (Ie[L]) {
                        var G = 0,
                            K = 100;
                        L !== 0 && (G = bt[L - 1]), L !== Ie.length - 1 && (K = bt[L]);
                        var ie = K - G,
                            ke = "translate(" + bf(Pm(G, ie) + "%", "0") + ")",
                            xe = "scale(" + bf(ie / 100, "1") + ")";
                        Ie[L].style[k.transformRule] = ke + " " + xe
                    }
                }

                function Nm(L, G) {
                    return L === null || L === !1 || L === void 0 ? bt[G] : (typeof L == "number" && (L = String(L)), (L = k.format.from(L)) !== !1 && (L = Ve.toStepping(L)), L === !1 || isNaN(L) ? bt[G] : L)
                }

                function Vl(L, G, K) {
                    var ie = p(L),
                        ke = bt[0] === void 0;
                    G = G === void 0 || G, k.animate && !ke && d(jt, k.cssClasses.tap, k.animationDuration), on.forEach(function(Se) {
                        Xi(Se, Nm(ie[Se], Se), !0, !1, K)
                    });
                    var xe = on.length === 1 ? 0 : 1;
                    if (ke && Ve.hasNoSize() && (K = !0, bt[0] = 0, on.length > 1)) {
                        var Je = 100 / (on.length - 1);
                        on.forEach(function(Se) {
                            bt[Se] = Se * Je
                        })
                    }
                    for (; xe < on.length; ++xe) on.forEach(function(Se) {
                        Xi(Se, bt[Se], !0, !0, K)
                    });
                    wf(), on.forEach(function(Se) {
                        Mt("update", Se), ie[Se] !== null && G && Mt("set", Se)
                    })
                }

                function zA(L) {
                    Vl(k.start, L)
                }

                function jA(L, G, K, ie) {
                    if (!((L = Number(L)) >= 0 && L < on.length)) throw new Error("noUiSlider: invalid handle number, got: " + L);
                    Xi(L, Nm(G, L), !0, !0, ie), Mt("update", L), K && Mt("set", L)
                }

                function Rm(L) {
                    if (L === void 0 && (L = !1), L) return In.length === 1 ? In[0] : In.slice(0);
                    var G = In.map(k.format.to);
                    return G.length === 1 ? G[0] : G
                }

                function VA() {
                    for (ra(Y.aria), ra(Y.tooltips), Object.keys(k.cssClasses).forEach(function(L) {
                            x(jt, k.cssClasses[L])
                        }); jt.firstChild;) jt.removeChild(jt.firstChild);
                    delete jt.noUiSlider
                }

                function Cm(L) {
                    var G = bt[L],
                        K = Ve.getNearbySteps(G),
                        ie = In[L],
                        ke = K.thisStep.step,
                        xe = null;
                    if (k.snap) return [ie - K.stepBefore.startValue || null, K.stepAfter.startValue - ie || null];
                    ke !== !1 && ie + ke > K.stepAfter.startValue && (ke = K.stepAfter.startValue - ie), xe = ie > K.thisStep.startValue ? K.thisStep.step : K.stepBefore.step !== !1 && ie - K.stepBefore.highestStep, G === 100 ? ke = null : G === 0 && (xe = null);
                    var Je = Ve.countStepDecimals();
                    return ke !== null && ke !== !1 && (ke = Number(ke.toFixed(Je))), xe !== null && xe !== !1 && (xe = Number(xe.toFixed(Je))), [xe, ke]
                }

                function GA() {
                    return on.map(Cm)
                }

                function WA(L, G) {
                    var K = Rm(),
                        ie = ["margin", "limit", "padding", "range", "animate", "snap", "step", "format", "pips", "tooltips"];
                    ie.forEach(function(xe) {
                        L[xe] !== void 0 && (le[xe] = L[xe])
                    });
                    var ke = He(le);
                    ie.forEach(function(xe) {
                        L[xe] !== void 0 && (k[xe] = ke[xe])
                    }), Ve = ke.spectrum, k.margin = ke.margin, k.limit = ke.limit, k.padding = ke.padding, k.pips ? mf(k.pips) : Zs(), k.tooltips ? ta() : Ul(), bt = [], Vl(o(L.start) ? L.start : K, G)
                }

                function QA() {
                    Ee = Ur(jt), tr(k.connect, Ee), FA(k.events), Vl(k.start), k.pips && mf(k.pips), k.tooltips && ta(), hf()
                }
                QA();
                var Gl = {
                    destroy: VA,
                    steps: GA,
                    on: vf,
                    off: ra,
                    get: Rm,
                    set: Vl,
                    setHandle: jA,
                    reset: zA,
                    __moveHandles: function(L, G, K) {
                        Em(L, G, bt, K)
                    },
                    options: le,
                    updateOptions: WA,
                    target: jt,
                    removePips: Zs,
                    removeTooltips: Ul,
                    getPositions: function() {
                        return bt.slice()
                    },
                    getTooltips: function() {
                        return et
                    },
                    getOrigins: function() {
                        return pe
                    },
                    pips: mf
                };
                return Gl
            }

            function st(D, k) {
                if (!D || !D.nodeName) throw new Error("noUiSlider: create requires a single element, got: " + D);
                if (D.noUiSlider) throw new Error("noUiSlider: Slider was already initialized.");
                var le = Qe(D, He(k), k);
                return D.noUiSlider = le, le
            }
            var rt = {
                __spectrum: I,
                cssClasses: j,
                create: st
            };
            n.create = st, n.cssClasses = j, n.default = rt, Object.defineProperty(n, "__esModule", {
                value: !0
            })
        })(e)
    }));

function W1(t, e) {
    if (!Array.isArray(t) || !Array.isArray(e)) return !1;
    const n = e.slice().sort();
    return t.length === e.length && t.slice().sort().every(function(r, i) {
        return r === n[i]
    })
}
var $r = {
    name: "Slider",
    emits: ["input", "update:modelValue", "start", "slide", "drag", "update", "change", "set", "end"],
    props: {
        value: {
            validator: function(t) {
                return e => typeof e == "number" || e instanceof Array || e == null || e === !1
            },
            required: !1
        },
        modelValue: {
            validator: function(t) {
                return e => typeof e == "number" || e instanceof Array || e == null || e === !1
            },
            required: !1
        },
        id: {
            type: [String, Number],
            required: !1
        },
        disabled: {
            type: Boolean,
            required: !1,
            default: !1
        },
        min: {
            type: Number,
            required: !1,
            default: 0
        },
        max: {
            type: Number,
            required: !1,
            default: 100
        },
        step: {
            type: Number,
            required: !1,
            default: 1
        },
        orientation: {
            type: String,
            required: !1,
            default: "horizontal"
        },
        direction: {
            type: String,
            required: !1,
            default: "ltr"
        },
        tooltips: {
            type: Boolean,
            required: !1,
            default: !0
        },
        options: {
            type: Object,
            required: !1,
            default: () => ({})
        },
        merge: {
            type: Number,
            required: !1,
            default: -1
        },
        format: {
            type: [Object, Function, Boolean],
            required: !1,
            default: null
        },
        classes: {
            type: Object,
            required: !1,
            default: () => ({})
        },
        showTooltip: {
            type: String,
            required: !1,
            default: "always"
        },
        tooltipPosition: {
            type: String,
            required: !1,
            default: null
        },
        lazy: {
            type: Boolean,
            required: !1,
            default: !0
        },
        ariaLabelledby: {
            type: String,
            required: !1,
            default: void 0
        },
        aria: {
            required: !1,
            type: Object,
            default: () => ({})
        }
    },
    setup(t, e) {
        const n = function(o, a, c) {
                const {
                    value: l,
                    modelValue: u,
                    min: f
                } = oo(o);
                let d = u && u.value !== void 0 ? u : l;
                const h = Z(d.value);
                if (yc(d.value) && (d = Z(f.value)), Array.isArray(d.value) && d.value.length == 0) throw new Error("Slider v-model must not be an empty array");
                return {
                    value: d,
                    initialValue: h
                }
            }(t),
            r = function(o, a, c) {
                const {
                    classes: l,
                    showTooltip: u,
                    tooltipPosition: f,
                    orientation: d
                } = oo(o), h = ze(() => ({
                    target: "slider-target",
                    focused: "slider-focused",
                    tooltipFocus: "slider-tooltip-focus",
                    tooltipDrag: "slider-tooltip-drag",
                    ltr: "slider-ltr",
                    rtl: "slider-rtl",
                    horizontal: "slider-horizontal",
                    vertical: "slider-vertical",
                    textDirectionRtl: "slider-txt-dir-rtl",
                    textDirectionLtr: "slider-txt-dir-ltr",
                    base: "slider-base",
                    connects: "slider-connects",
                    connect: "slider-connect",
                    origin: "slider-origin",
                    handle: "slider-handle",
                    handleLower: "slider-handle-lower",
                    handleUpper: "slider-handle-upper",
                    touchArea: "slider-touch-area",
                    tooltip: "slider-tooltip",
                    tooltipTop: "slider-tooltip-top",
                    tooltipBottom: "slider-tooltip-bottom",
                    tooltipLeft: "slider-tooltip-left",
                    tooltipRight: "slider-tooltip-right",
                    tooltipHidden: "slider-tooltip-hidden",
                    active: "slider-active",
                    draggable: "slider-draggable",
                    tap: "slider-state-tap",
                    drag: "slider-state-drag",
                    pips: "slider-pips",
                    pipsHorizontal: "slider-pips-horizontal",
                    pipsVertical: "slider-pips-vertical",
                    marker: "slider-marker",
                    markerHorizontal: "slider-marker-horizontal",
                    markerVertical: "slider-marker-vertical",
                    markerNormal: "slider-marker-normal",
                    markerLarge: "slider-marker-large",
                    markerSub: "slider-marker-sub",
                    value: "slider-value",
                    valueHorizontal: "slider-value-horizontal",
                    valueVertical: "slider-value-vertical",
                    valueNormal: "slider-value-normal",
                    valueLarge: "slider-value-large",
                    valueSub: "slider-value-sub",
                    ...l.value
                }));
                return {
                    classList: ze(() => {
                        const p = { ...h.value
                        };
                        return Object.keys(p).forEach(g => {
                            p[g] = Array.isArray(p[g]) ? p[g].filter(b => b !== null).join(" ") : p[g]
                        }), u.value !== "always" && (p.target += ` ${u.value==="drag"?p.tooltipDrag:p.tooltipFocus}`), d.value === "horizontal" && (p.tooltip += f.value === "bottom" ? ` ${p.tooltipBottom}` : ` ${p.tooltipTop}`), d.value === "vertical" && (p.tooltip += f.value === "right" ? ` ${p.tooltipRight}` : ` ${p.tooltipLeft}`), p
                    })
                }
            }(t),
            i = function(o, a, c) {
                const {
                    format: l,
                    step: u
                } = oo(o), f = c.value, d = c.classList, h = ze(() => l && l.value ? typeof l.value == "function" ? {
                    to: l.value
                } : G1({ ...l.value
                }) : G1({
                    decimals: u.value >= 0 ? 0 : 2
                })), p = ze(() => Array.isArray(f.value) ? f.value.map(g => h.value) : h.value);
                return {
                    tooltipFormat: h,
                    tooltipsFormat: p,
                    tooltipsMerge: (g, b, x) => {
                        var w = getComputedStyle(g).direction === "rtl",
                            O = g.noUiSlider.options.direction === "rtl",
                            N = g.noUiSlider.options.orientation === "vertical",
                            U = g.noUiSlider.getTooltips(),
                            H = g.noUiSlider.getOrigins();
                        U.forEach(function(M, y) {
                            M && H[y].appendChild(M)
                        }), g.noUiSlider.on("update", function(M, y, v, A, E) {
                            var P = [
                                    []
                                ],
                                R = [
                                    []
                                ],
                                F = [
                                    []
                                ],
                                _ = 0;
                            U[0] && (P[0][0] = 0, R[0][0] = E[0], F[0][0] = h.value.to(parseFloat(M[0])));
                            for (var S = 1; S < M.length; S++)(!U[S] || M[S] - M[S - 1] > b) && (P[++_] = [], F[_] = [], R[_] = []), U[S] && (P[_].push(S), F[_].push(h.value.to(parseFloat(M[S]))), R[_].push(E[S]));
                            P.forEach(function(I, B) {
                                for (var j = I.length, Y = 0; Y < j; Y++) {
                                    var te = I[Y];
                                    if (Y === j - 1) {
                                        var he = 0;
                                        R[B].forEach(function(X) {
                                            he += 1e3 - X
                                        });
                                        var Te = N ? "bottom" : "right",
                                            Be = O ? 0 : j - 1,
                                            ve = 1e3 - R[B][Be];
                                        he = (w && !N ? 100 : 0) + he / j - ve, U[te].innerHTML = F[B].join(x), U[te].style.display = "block", U[te].style[Te] = he + "%", d.value.tooltipHidden.split(" ").forEach(X => {
                                            U[te].classList.contains(X) && U[te].classList.remove(X)
                                        })
                                    } else U[te].style.display = "none", d.value.tooltipHidden.split(" ").forEach(X => {
                                        U[te].classList.add(X)
                                    })
                                }
                            })
                        })
                    }
                }
            }(t, 0, {
                value: n.value,
                classList: r.classList
            }),
            s = function(o, a, c) {
                const {
                    orientation: l,
                    direction: u,
                    tooltips: f,
                    step: d,
                    min: h,
                    max: p,
                    merge: g,
                    id: b,
                    disabled: x,
                    options: w,
                    classes: O,
                    format: N,
                    lazy: U,
                    ariaLabelledby: H,
                    aria: M
                } = oo(o), y = c.value, v = c.initialValue, A = c.tooltipsFormat, E = c.tooltipsMerge, P = c.tooltipFormat, R = c.classList, F = Z(null), _ = Z(null), S = Z(!1), I = ze(() => {
                    let X = {
                        cssPrefix: "",
                        cssClasses: R.value,
                        orientation: l.value,
                        direction: u.value,
                        tooltips: !!f.value && A.value,
                        connect: "lower",
                        start: yc(y.value) ? h.value : y.value,
                        range: {
                            min: h.value,
                            max: p.value
                        }
                    };
                    if (d.value > 0 && (X.step = d.value), Array.isArray(y.value) && (X.connect = !0), H && H.value || M && Object.keys(M.value).length) {
                        let V = Array.isArray(y.value) ? y.value : [y.value];
                        X.handleAttributes = V.map(oe => Object.assign({}, M.value, H && H.value ? {
                            "aria-labelledby": H.value
                        } : {}))
                    }
                    return N.value && (X.ariaFormat = P.value), X
                }), B = ze(() => {
                    let X = {
                        id: b && b.value ? b.value : void 0
                    };
                    return x.value && (X.disabled = !0), X
                }), j = ze(() => Array.isArray(y.value)), Y = () => {
                    let X = _.value.get();
                    return Array.isArray(X) ? X.map(V => parseFloat(V)) : parseFloat(X)
                }, te = function(X) {
                    let V = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
                    _.value.set(X, V)
                }, he = X => {
                    a.emit("input", X), a.emit("update:modelValue", X), a.emit("update", X)
                }, Te = () => {
                    _.value = nC.create(F.value, Object.assign({}, I.value, w.value)), f.value && j.value && g.value >= 0 && E(F.value, g.value, " - "), _.value.on("set", () => {
                        const X = Y();
                        a.emit("change", X), a.emit("set", X), U.value && he(X)
                    }), _.value.on("update", () => {
                        if (!S.value) return;
                        const X = Y();
                        j.value && W1(y.value, X) || !j.value && y.value == X ? a.emit("update", X) : U.value || he(X)
                    }), _.value.on("start", () => {
                        a.emit("start", Y())
                    }), _.value.on("end", () => {
                        a.emit("end", Y())
                    }), _.value.on("slide", () => {
                        a.emit("slide", Y())
                    }), _.value.on("drag", () => {
                        a.emit("drag", Y())
                    }), F.value.querySelectorAll("[data-handle]").forEach(X => {
                        X.onblur = () => {
                            F.value && R.value.focused.split(" ").forEach(V => {
                                F.value.classList.remove(V)
                            })
                        }, X.onfocus = () => {
                            R.value.focused.split(" ").forEach(V => {
                                F.value.classList.add(V)
                            })
                        }
                    }), S.value = !0
                }, Be = () => {
                    _.value.off(), _.value.destroy(), _.value = null
                }, ve = (X, V) => {
                    S.value = !1, Be(), Te()
                };
                return sn(Te), Us(Be), Xe(j, ve, {
                    immediate: !1
                }), Xe(h, ve, {
                    immediate: !1
                }), Xe(p, ve, {
                    immediate: !1
                }), Xe(d, ve, {
                    immediate: !1
                }), Xe(l, ve, {
                    immediate: !1
                }), Xe(u, ve, {
                    immediate: !1
                }), Xe(f, ve, {
                    immediate: !1
                }), Xe(g, ve, {
                    immediate: !1
                }), Xe(N, ve, {
                    immediate: !1,
                    deep: !0
                }), Xe(w, ve, {
                    immediate: !1,
                    deep: !0
                }), Xe(O, ve, {
                    immediate: !1,
                    deep: !0
                }), Xe(y, (X, V) => {
                    V && (typeof V == "object" && typeof X == "object" && X && Object.keys(V) > Object.keys(X) || typeof V == "object" && typeof X != "object" || yc(X)) && ve()
                }, {
                    immediate: !1
                }), Xe(y, X => {
                    if (yc(X)) return void te(h.value, !1);
                    let V = Y();
                    j.value && !Array.isArray(V) && (V = [V]), (j.value && !W1(X, V) || !j.value && X != V) && te(X, !1)
                }, {
                    deep: !0
                }), {
                    slider: F,
                    slider$: _,
                    isRange: j,
                    sliderProps: B,
                    init: Te,
                    destroy: Be,
                    refresh: ve,
                    update: te,
                    reset: () => {
                        he(v.value)
                    }
                }
            }(t, e, {
                value: n.value,
                initialValue: n.initialValue,
                tooltipFormat: i.tooltipFormat,
                tooltipsFormat: i.tooltipsFormat,
                tooltipsMerge: i.tooltipsMerge,
                classList: r.classList
            });
        return { ...r,
            ...i,
            ...s
        }
    }
};
$r.render = function(t, e, n, r, i, s) {
    return fe(), be("div", Bv(t.sliderProps, {
        ref: "slider"
    }), null, 16)
}, $r.__file = "src/Slider.vue";
const rC = {
        class: "bg-staking"
    },
    iC = {
        class: "p-2 md:p-0 max-w-7xl mx-auto bg-white pt-20 bg-staking relative grid gap-5 lg:grid-cols-2"
    },
    sC = {
        class: "py-16 px-4 sm:px-6 lg:py-10 lg:px-10 bg-gray-100 shadow rounded overflow-hidden"
    },
    oC = m("div", {
        class: "max-w-3xl mx-auto text-center pb-10"
    }, [m("div", {
        class: "flex justify-center"
    }, [m("img", {
        src: qR
    })]), m("h2", {
        class: "py-10 text-center text-4xl font-extrabold tracking-tight sm:text-6xl bg-gradient-to-r from-red-500 via-yellow-400 to-red-400 bg-clip-text text-transparent leading-8"
    }, " Stake + Run Node ")], -1),
    aC = {
        class: "space-y-10 lg:space-y-0 lg:grid lg:grid-cols-3 lg:gap-8 h-auto lg:h-80"
    },
    lC = {
        class: "flex justify-center"
    },
    cC = {
        class: "flex items-center justify-center h-20 w-20 rounded-full bg-gradient-to-b from-red-500 to-yellow-400 text-white"
    },
    uC = {
        class: "mt-5 text-lg leading-6 font-semibold text-gray-900 text-center"
    },
    fC = {
        class: "mt-2 text-base text-gray-500 text-center"
    },
    dC = {
        class: "mt-20 pb-10 sm:pb-16"
    },
    hC = {
        class: "relative"
    },
    pC = m("div", {
        class: "absolute inset-0 h-1/2"
    }, null, -1),
    mC = {
        class: "relative max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"
    },
    gC = {
        class: "max-w-5xl mx-auto"
    },
    yC = {
        class: "rounded-lg bg-white shadow-lg sm:grid sm:grid-cols-2"
    },
    vC = {
        class: "flex flex-col border-b border-gray-100 p-6 text-center sm:border-0 sm:border-r"
    },
    bC = m("dt", {
        class: "order-2 mt-2 text-lg leading-6 font-medium text-gray-500"
    }, "ETH Rewards", -1),
    wC = {
        class: "order-1 text-5xl sm:text-2xl font-extrabold purple-gradient bg-clip-text text-transparent tracking-tight"
    },
    xC = m("div", {
        class: "flex flex-col border-t border-b border-gray-100 p-6 text-center sm:border-0 sm:border-l sm:border-r"
    }, [m("dt", {
        class: "order-2 mt-2 text-lg leading-6 font-medium text-gray-500"
    }, "Variable"), m("dd", {
        class: "order-1 text-5xl sm:text-2xl font-extrabold purple-gradient bg-clip-text text-transparent tracking-tight"
    }, "+ RPL Rewards")], -1),
    AC = m("div", {
        class: "mt-5 max-w-md mx-auto sm:flex sm:justify-center md:mt-8"
    }, [m("div", {
        class: "rounded-md shadow"
    }, [m("a", {
        href: "/node-operators",
        target: "_blank",
        class: "w-full flex items-center justify-center px-8 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button md:py-5 md:text-3xl md:px-10"
    }, " Get started ")])], -1),
    kC = {
        class: "p-2 md:p-0 py-16 px-4 sm:px-6 lg:py-10 lg:px-10 bg-gray-100 shadow rounded overflow-hidden"
    },
    _C = m("div", {
        class: "max-w-3xl mx-auto text-center pb-10"
    }, [m("div", {
        class: "flex justify-center"
    }, [m("img", {
        src: $R
    })]), m("h2", {
        class: "py-10 text-center text-4xl font-extrabold tracking-tight sm:text-6xl bg-gradient-to-r from-red-500 via-yellow-400 to-red-400 bg-clip-text text-transparent leading-8"
    }, " Stake ETH ")], -1),
    EC = {
        class: "space-y-10 lg:space-y-0 lg:grid lg:grid-cols-3 lg:gap-8 h-auto lg:h-80"
    },
    PC = {
        class: "flex justify-center"
    },
    SC = {
        class: "flex items-center justify-center h-20 w-20 rounded-full bg-gradient-to-b from-red-500 to-yellow-400 text-white"
    },
    NC = {
        class: "mt-5 text-lg leading-6 font-semibold text-gray-900 text-center"
    },
    RC = {
        class: "mt-2 text-base text-gray-500 text-center"
    },
    CC = {
        class: "mt-20 pb-10 sm:pb-16"
    },
    OC = {
        class: "relative"
    },
    TC = m("div", {
        class: "absolute inset-0 h-1/2"
    }, null, -1),
    BC = {
        class: "relative max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"
    },
    IC = {
        class: "max-w-3xl mx-auto"
    },
    DC = {
        class: "rounded-lg bg-white shadow-lg sm:grid sm:grid-cols-1"
    },
    LC = {
        class: "flex flex-col border-b border-gray-100 p-6 text-center sm:border-0 sm:border-r"
    },
    MC = m("dt", {
        class: "order-2 mt-2 text-lg leading-6 font-medium text-gray-500"
    }, "Based on 7 day average", -1),
    FC = {
        class: "order-1 text-5xl sm:text-2xl font-extrabold purple-gradient bg-clip-text text-transparent tracking-tight"
    },
    UC = m("div", {
        class: "mt-5 max-w-md mx-auto sm:flex sm:justify-center md:mt-8"
    }, [m("div", {
        class: "rounded-md shadow"
    }, [m("a", {
        href: "https://stake.rocketpool.net",
        target: "_blank",
        rel: "noreferrer",
        class: "w-full flex items-center justify-center px-8 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button md:py-5 md:text-3xl md:px-10"
    }, " Stake ")])], -1),
    HC = nt({
        __name: "stake-eth-run-node",
        setup(t) {
            const e = we("emitter"),
                n = we("ethStaked"),
                r = we("ethStakedBN"),
                i = we("ethAPRPercentage"),
                s = we("ethStakedDefault"),
                o = we("rethAPR");

            function a() {
                n.value = s.value, r.value = new me(n.value)
            }

            function c() {
                r.value = new me(n.value), e.emit("recalculate")
            }
            const l = {
                    range: {
                        min: 9e6,
                        max: 2e7
                    },
                    step: 1e5
                },
                u = function(h) {
                    return ba(h).format("0.0a") + " ETH"
                },
                f = [{
                    name: "Permissionless",
                    description: "Anyone can join the Rocket Pool decentralised node operator network.",
                    icon: ["fas", "network-wired"]
                }, {
                    name: "Only 8 ETH",
                    description: "Stake with less than 32 ETH.",
                    icon: ["fab", "ethereum"]
                }, {
                    name: "Higher ROI",
                    description: "Earn commission from staking pool ETH and RPL rewards from providing RPL collateral.",
                    icon: ["fas", "dollar-sign"]
                }],
                d = [{
                    name: "Liquid",
                    description: "Deposit as little as 0.01 ETH and receive the rETH liquid staking token. rETH accrues staking rewards over time.",
                    icon: ["fab", "ethereum"]
                }, {
                    name: "Decentralised",
                    description: "A decentralised network of node operators earn rewards for rETH holders.",
                    icon: ["fas", "users"]
                }, {
                    name: "Non-custodial",
                    description: "Node operators do not handle funds. Any penalties incurred by node operators are taken from their earnings rather than rETH holders.",
                    icon: ["fas", "lock"]
                }];
            return e.on("setDefaults", () => {
                a()
            }), (h, p) => {
                const g = Lr("fa");
                return fe(), be("div", rC, [m("div", iC, [m("div", sC, [oC, m("dl", aC, [(fe(), be(Ye, null, xt(f, b => m("div", {
                    key: b.name
                }, [m("dt", null, [m("div", lC, [m("div", cC, [q(g, {
                    icon: b.icon,
                    class: "h-10 w-10",
                    size: "3x",
                    "aria-hidden": "true"
                }, null, 8, ["icon"])])]), m("p", uC, ue(b.name), 1)]), m("dd", fC, ue(b.description), 1)])), 64))]), m("div", dC, [m("div", hC, [pC, m("div", mC, [m("div", gC, [m("dl", yC, [m("div", vC, [bC, m("dd", wC, " " + ue(J(i)) + "% APR", 1), q(J($r), {
                    modelValue: J(n),
                    "onUpdate:modelValue": p[0] || (p[0] = b => pt(n) ? n.value = b : null),
                    options: l,
                    format: u,
                    lazy: !1,
                    class: "hidden",
                    onUpdate: c
                }, null, 8, ["modelValue"])]), xC])])])])]), AC]), m("div", kC, [_C, m("dl", EC, [(fe(), be(Ye, null, xt(d, b => m("div", {
                    key: b.name
                }, [m("dt", null, [m("div", PC, [m("div", SC, [q(g, {
                    icon: b.icon,
                    class: "h-10 w-10",
                    size: "3x",
                    "aria-hidden": "true"
                }, null, 8, ["icon"])])]), m("p", NC, ue(b.name), 1)]), m("dd", RC, ue(b.description), 1)])), 64))]), m("div", CC, [m("div", OC, [TC, m("div", BC, [m("div", IC, [m("dl", DC, [m("div", LC, [MC, m("dd", FC, " " + ue(J(o)) + "% APR", 1)])])])])])]), UC])])])
            }
        }
    }),
    ef = (t, e) => {
        const n = t.__vccOpts || t;
        for (const [r, i] of e) n[r] = i;
        return n
    },
    zC = {},
    jC = {
        class: "py-20 bg-white"
    },
    VC = Ko('<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="max-w-7xl mx-auto text-center py-12 px-4 sm:px-6 lg:py-16 lg:px-8"><h2 class="py-2 text-center text-4xl font-extrabold tracking-tight sm:text-6xl bg-gradient-to-r from-red-500 via-yellow-400 to-red-400 bg-clip-text text-transparent leading-8"><span class="block">Interested in node operation?</span></h2><div class="mt-5 max-w-md mx-auto sm:flex sm:justify-center md:mt-8"><div class="rounded-md shadow"><a href="/node-operators" target="_blank" rel="noreferrer" class="w-full flex items-center justify-center px-8 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button md:py-5 md:text-3xl md:px-10"> Find out more </a></div></div></div></div>', 1),
    GC = [VC];

function WC(t, e) {
    return fe(), be("div", jC, GC)
}
const QC = ef(zC, [
        ["render", WC]
    ]),
    JC = "data:image/svg+xml,%3csvg%20id='my-svg'%20class='navbar-sigma-icon'%20width='60px'%20height='60px'%20viewBox='0%200%20111%20101'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cg%20id='Page-1'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%20data-darkreader-inline-stroke=''%20style='--darkreader-inline-stroke:none;%20--darkreader-inline-fill:none;'%20data-darkreader-inline-fill=''%3e%3cg%20id='Desktop'%20transform='translate(-214.000000,%20-2093.000000)'%20stroke='%23FFFFFF'%20data-darkreader-inline-stroke=''%20style='--darkreader-inline-stroke:%23e8e6e3;'%3e%3cg%20id='g4557'%20transform='translate(224.000000,%202093.000000)'%3e%3cpath%20d='M81.995,36.74%20C81.995,36.74%2048.072,36.74%2027.91,36.74%20C7.748,36.74%200.323,52.614%200.323,63.815%20C0.323,75.016%2010.82,90.89%2027.91,90.89%20C45,90.89%2054.984,76.424%2054.984,63.815%20C54.984,51.206%2054.984,38.66%2054.984,38.66'%20id='path4553'%20stroke-width='19.5860996'%20style='stroke-dasharray:%20208,%20210;%20stroke-dashoffset:%200;'%3e%3c/path%3e%3cpath%20d='M94.41,0.92599%20L94.41,33.67599'%20id='line4555'%20stroke-width='13'%20style='stroke-dasharray:%2033,%2035;%20stroke-dashoffset:%200;'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e",
    KC = "/assets/consensys-diligence-_na8TsbV.svg",
    ZC = "/assets/trail-of-bits-VV0LOAGP.svg",
    N2 = "data:image/svg+xml,%3csvg%20fill='none'%20height='42'%20viewBox='0%200%20187%2042'%20width='187'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20fill='%23fff'%3e%3cg%20clip-rule='evenodd'%20fill-rule='evenodd'%3e%3cpath%20d='m10.4146%2017.8578%2012.9036%2013.1352%2012.7658-12.9949%2010.4669%2010.6547-12.1612%2012.3795-3.1285-3.0998%209.116-9.2797-4.2932-4.3703-12.7658%2012.995-12.9036-13.1352-4.24095%204.3171%209.25465%209.4208-3.1285%203.0998-12.2998-12.5206z'/%3e%3cpath%20d='m36.1364%2024.142-12.9036-13.1351-12.7657%2012.9949-10.46693978-10.6548%2012.16113978-12.379406%203.1285%203.099806-9.116%209.2796%204.2933%204.3704%2012.7657-12.995%2012.9036%2013.1352%204.241-4.3172-9.2547-9.42074%203.1285-3.09981%2012.2998%2012.52055z'/%3e%3cpath%20d='m21.3066%2040.7237v-8.2757h4.2137v8.2757z'/%3e%3cpath%20d='m21.3066%209.55185v-8.27566h4.2137v8.27566z'/%3e%3c/g%3e%3cpath%20d='m60.7498%2010.738h-4.1988v21.1406h4.1988z'/%3e%3cpath%20d='m82.048%2016.3167c-1.9086%200-3.729.8222-4.6392%202.6133-.9396-1.7911-2.7013-2.6133-4.7567-2.6133-1.8498%200-3.2591.7047-3.9932%201.9673l-.4404-1.6736h-3.8171v15.2682h4.1107v-8.5444c0-2.2608%201.1745-3.3472%202.9068-3.3472%201.6443%200%202.7601%201.0277%202.7601%203.5234v8.3682h3.9638v-8.4563c.0587-2.3783%201.2919-3.4353%202.9068-3.4353%201.6737%200%202.7601%201.0277%202.7601%203.3179v8.603h4.14v-9.4251c0-4.2282-2.8481-6.1661-5.9017-6.1661z'/%3e%3cpath%20d='m108.858%2016.3167c-1.909%200-3.729.8222-4.639%202.6133-.94-1.7911-2.702-2.6133-4.7569-2.6133-1.8498%200-3.2592.7047-3.9932%201.9673l-.4405-1.6736h-3.817v15.2682h4.1107v-8.5444c0-2.2608%201.1744-3.3472%202.9068-3.3472%201.6443%200%202.7601%201.0277%202.7601%203.5234v8.3682h3.964v-8.4563c.058-2.3783%201.292-3.4353%202.907-3.4353%201.673%200%202.76%201.0277%202.76%203.3179v8.603h4.14v-9.4251c0-4.2282-2.848-6.1661-5.902-6.1661z'/%3e%3cpath%20d='m128.034%2016.6104v8.3681c0%202.2609-1.057%203.6115-3.083%203.6409-1.938.0587-3.171-1.0864-3.171-3.4647v-8.5443h-3.905v9.0728c0%203.9051%202.26%206.489%206.166%206.489%201.82%200%203.141-.8222%203.934-1.9673l.206%201.6737h3.758v-15.2682z'/%3e%3cpath%20d='m144.002%2016.3167c-2.29%200-3.817.8515-4.61%202.1141l-.235-1.8204h-3.817v15.2682h4.111v-8.0746c0-2.4664%201.174-3.9638%203.347-3.9638%201.997%200%203.201%201.2919%203.201%203.817v8.2214h4.14v-9.0729c0-3.9051-2.232-6.489-6.137-6.489z'/%3e%3cpath%20d='m168.116%2024.0096c0-4.6686-3.025-7.6929-7.576-7.6929s-7.604%203.1711-7.604%207.9278c0%204.786%203.053%207.957%207.634%207.957%203.846%200%206.753-2.1434%207.428-5.3145h-4.14c-.469%201.3213-1.673%201.9966-3.171%201.9966-1.967%200-3.553-1.2625-3.611-3.5234h11.04zm-7.576-4.4924c1.791%200%203.289%201.0277%203.465%203.1417h-6.9c.176-2.114%201.674-3.1417%203.435-3.1417z'/%3e%3cpath%20d='m169.721%2016.6104v3.5821h2.349v11.6861h4.14v-11.6861h3.494v-3.5821h-3.494v-1.5562c0-1.0864.293-1.9085%201.967-1.9085h1.527v-3.3473h-2.437c-3.847%200-5.197%201.8792-5.197%204.8447v1.9673z'/%3e%3cpath%20d='m182.419%2014.2614h4.169l.059-4.463h-4.169zm.059%2017.6172h4.11v-15.2682h-4.11z'/%3e%3c/g%3e%3c/svg%3e",
    YC = {},
    XC = {
        class: "relative pt-16 pb-20 px-4 sm:px-6 lg:pt-24 lg:pb-28 lg:px-8 security overflow-hidden"
    },
    qC = Ko('<div class="bg-fx"></div><div class="bg-clouds-bottom"></div><div class="bg-clouds-top"></div><div class="p-2 md:p-0 relative max-w-7xl mx-auto"><div class="text-center"><h2 class="py-2 text-center text-4xl font-extrabold tracking-tight sm:text-6xl bg-gradient-to-r from-yellow-200 to-yellow-500 bg-clip-text text-transparent leading-8">Security</h2><p class="mt-3 max-w-2xl mx-auto text-xl text-gray-50 sm:mt-4">Our smart contracts have been audited by the best in the business.</p></div><div class="mt-12 max-w-lg mx-auto grid gap-5 lg:grid-cols-4 lg:max-w-none"><div class="flex flex-col rounded-lg shadow-lg overflow-hidden"><div class="flex-shrink-0"><div class="bg-gray-800"><img class="h-48 w-48 object-contain mx-auto p-4" src="' + JC + '" alt="Sigma Prime"></div></div><div class="flex-1 bg-white p-6 flex flex-col justify-between"><div class="flex-1"><p class="text-sm font-medium text-indigo-600">Audit</p><div class="block mt-2"><p class="text-xl font-semibold text-gray-900">Sigma Prime</p><p class="mt-3 text-base text-gray-500"> Have an extensive background in information security, blockchain, and system design. They perform in-depth security assessments for decentralised systems. Sigma Prime also maintains the Lighthouse Ethereum consensus client. </p></div></div><div class="mt-6 flex items-center justify-center"><a href="/files/sigma-prime-audit.pdf" target="_blank" class="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"> May 2021 </a></div><div class="mt-6 flex items-center justify-center"><a href="/files/sigma-prime-fix-review.pdf" target="_blank" class="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"> November 2021 </a></div><div class="mt-6 flex items-center justify-center"><a href="/files/sigma-prime-audit-redstone.pdf" target="_blank" class="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"> June 2022 </a></div><div class="mt-6 flex items-center justify-center"><a href="/files/sigma-prime-atlas-v1.2.pdf" target="_blank" class="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"> December 2022 </a></div></div></div><div class="flex flex-col rounded-lg shadow-lg overflow-hidden"><div class="flex-shrink-0"><div class="bg-gray-800"><img class="h-48 w-48 object-contain mx-auto p-4" src="' + KC + '" alt="Consensys Diligence"></div></div><div class="flex-1 bg-white p-6 flex flex-col justify-between"><div class="flex-1"><p class="text-sm font-medium text-indigo-600">Audit</p><div class="block mt-2"><p class="text-xl font-semibold text-gray-900">Consensys Diligence</p><p class="mt-3 text-base text-gray-500"> As one of the most experienced teams in the space, ConsenSys Diligence is at the cutting edge of offensive cryptography, blockchain technology, and cryptoeconomic incentive analysis. </p></div></div><div class="mt-6 flex items-center justify-center"><a href="https://consensys.net/diligence/audits/2021/04/rocketpool/" target="_blank" rel="noreferrer" class="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"> May 2021 </a></div><div class="mt-6 flex items-center justify-center"><a href="/files/consensys-audit-redstone.pdf" target="_blank" rel="noreferrer" class="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"> June 2022 </a></div><div class="mt-6 flex items-center justify-center"><a href="/files/consensys-diligence-atlas-v1.2.pdf" target="_blank" rel="noreferrer" class="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"> January 2023 </a></div></div></div><div class="flex flex-col rounded-lg shadow-lg overflow-hidden"><div class="flex-shrink-0"><div class="bg-gray-800"><img class="h-48 w-48 object-contain mx-auto p-4" src="' + ZC + '" alt="Trail of Bits"></div></div><div class="flex-1 bg-white p-6 flex flex-col justify-between"><div class="flex-1"><p class="text-sm font-medium text-indigo-600">Audit</p><div class="block mt-2"><p class="text-xl font-semibold text-gray-900">Trail of Bits</p><p class="mt-3 text-base text-gray-500"> Has helped secure some of the worlds most targeted organizations and products. They combine high-end security research with a real-world attacker mentality to reduce risk and fortify code. </p></div></div><div class="mt-6 flex items-center justify-center"><a href="https://github.com/trailofbits/publications/blob/master/reviews/RocketPool.pdf" target="_blank" rel="noreferrer" class="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"> Sept 2021 </a></div></div></div><div class="flex flex-col rounded-lg shadow-lg overflow-hidden"><div class="flex-shrink-0"><div class="bg-gray-800"><img class="h-48 w-48 object-contain mx-auto p-4" src="' + N2 + '" alt="Immunefi Bug Bounty"></div></div><div class="flex-1 bg-white p-6 flex flex-col justify-between"><div class="flex-1"><p class="text-sm font-medium text-indigo-600">Bug Bounty</p><div class="block mt-2"><p class="text-xl font-semibold text-gray-900">Immunefi Bug Bounty</p><p class="mt-3 text-base text-gray-500"> Are you a security researcher? Whitehat? In line with our commitment to security we have a bug bounty program in place. Help secure Rocket Pool and earn a bounty. </p></div></div><div class="mt-6 flex items-center justify-center"><a href="https://immunefi.com/bounty/rocketpool/" target="_blank" rel="noreferrer" class="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"> Learn more </a></div></div></div></div></div>', 4),
    $C = [qC];

function eO(t, e) {
    return fe(), be("div", XC, $C)
}
const tO = ef(YC, [
        ["render", eO]
    ]),
    nO = {
        class: "py-20 bg-white"
    },
    rO = {
        class: "p-2 md:p-0 max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"
    },
    iO = m("div", {
        class: "lg:text-center"
    }, [m("h2", {
        class: "py-2 text-center text-4xl font-extrabold tracking-tight sm:text-6xl bg-gradient-to-r from-red-500 via-yellow-400 to-red-400 bg-clip-text text-transparent leading-8"
    }, " How does Rocket Pool work? "), m("p", {
        class: "mt-4 max-w-2xl text-xl text-gray-600 lg:mx-auto font-semibold"
    }, "Rocket Pool is the first truly decentralised Ethereum staking pool.")], -1),
    sO = {
        class: "mt-10"
    },
    oO = {
        class: "space-y-10 md:space-y-0 md:grid md:grid-cols-2 md:gap-x-8 md:gap-y-10"
    },
    aO = {
        class: "absolute flex items-center justify-center h-20 w-20 rounded-full border-2 border-yellow-200 text-red-500"
    },
    lO = {
        class: "ml-24 text-lg leading-6 font-semibold text-gray-900"
    },
    cO = {
        class: "mt-2 ml-24 text-base text-gray-500"
    },
    uO = Ko('<div class="max-w-7xl mx-auto text-center py-12 px-4 sm:px-6 lg:py-16 lg:px-8"><h2 class="text-3xl font-extrabold tracking-tight text-gray-900 sm:text-4xl"><span class="block bg-gradient-to-r from-yellow-200 to-red-600 bg-clip-text text-transparent">Want to know more?</span></h2><div class="mt-8 flex-none md:flex justify-center"><div class="block md:inline-flex mb-3 md:mb-0"><a target="_blank" rel="noreferrer" href="https://medium.com/rocket-pool/rocket-pool-staking-protocol-part-1-8be4859e5fbd" class="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"> Explainer series </a></div><div class="mb-3 block md:inline-flex md:ml-3 md:mb-0"><a target="_blank" rel="noreferrer" href="https://docs.rocketpool.net/guides/" class="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"> Guides &amp; documentation </a></div><div class="mb-3 block md:inline-flex md:ml-3 md:mb-0"><a target="_blank" rel="noreferrer" href="https://docs.rocketpool.net/developers/" class="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"> Developers </a></div><div class="mb-3 block md:inline-flex md:ml-3 md:mb-0"><a target="_blank" rel="noreferrer" href="https://medium.com/rocket-pool/rocket-pool-rpl-token-upgrade-new-addresses-e96c12c55adf" class="inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"> Token addresses </a></div></div></div>', 1),
    fO = nt({
        __name: "how-it-works",
        setup(t) {
            const e = [{
                name: "Liquid Staking",
                description: "Innovative liquid staking token that accrues while using an increasing exchange rate, rather than rebasing which is better for DeFi and better for tax reporting.",
                icon: ["fab", "ethereum"]
            }, {
                name: "Smart Contracts",
                description: "Open source, audited smart contracts ensure funds are never in the custody of node operators.",
                icon: ["fas", "file-alt"]
            }, {
                name: "Smart Nodes",
                description: "With our custom node software any user/business/group can run a node on our network, stake their own ETH for free and generate a higher return.",
                icon: ["fas", "server"]
            }, {
                name: "Minimised Penalty Risk",
                description: "Any losses that occur from bad nodes for stakers who deposit ETH are socialised across the whole network to minimise impacts on any single user.",
                icon: ["fas", "lock"]
            }, {
                name: "Infrastructure",
                description: "Network redundancy and decentralisation are key pillars of the Rocket Pool network. Any potential issues and their effects are minimised using this technique.",
                icon: ["fas", "sitemap"]
            }, {
                name: "Experience",
                description: "Rocket Pool was originally designed in late 2016 using the Mauve Paper which was released by Vitalik. We've been in the space now longer than most, and it shows.",
                icon: ["fas", "rocket"]
            }];
            return (n, r) => {
                const i = Lr("fa");
                return fe(), be("div", nO, [m("div", rO, [iO, m("div", sO, [m("dl", oO, [(fe(), be(Ye, null, xt(e, s => m("div", {
                    key: s.name,
                    class: "relative"
                }, [m("dt", null, [m("div", aO, [q(i, {
                    icon: s.icon,
                    class: "h-10 w-10",
                    size: "3x",
                    "aria-hidden": "true"
                }, null, 8, ["icon"])]), m("p", lO, ue(s.name), 1)]), m("dd", cO, ue(s.description), 1)])), 64))])]), uO])])
            }
        }
    }),
    dO = {
        class: "relative pt-16 pb-20 px-4 sm:px-6 lg:pt-24 lg:pb-28 lg:px-8 community overflow-hidden"
    },
    hO = m("div", {
        class: "bg-fx"
    }, null, -1),
    pO = m("div", {
        class: "bg-clouds-bottom"
    }, null, -1),
    mO = m("div", {
        class: "bg-clouds-top"
    }, null, -1),
    gO = {
        class: "p-2 md:p-0 relative max-w-7xl mx-auto"
    },
    yO = m("div", {
        class: "text-center"
    }, [m("h2", {
        class: "py-2 text-center text-4xl font-extrabold tracking-tight sm:text-6xl bg-gradient-to-r from-yellow-200 to-yellow-500 bg-clip-text text-transparent leading-8"
    }, "Community"), m("p", {
        class: "mt-3 max-w-2xl mx-auto text-xl text-gray-50 sm:mt-4"
    }, "Our fantastic community would love to answer any questions you have.")], -1),
    vO = {
        class: "mt-12 max-w-lg mx-auto grid gap-5 lg:grid-cols-5 lg:max-w-none"
    },
    bO = {
        class: "flex-shrink-0"
    },
    wO = {
        class: "bg-gray-800"
    },
    xO = {
        class: "flex-1 bg-white p-6 flex flex-col justify-between"
    },
    AO = {
        class: "flex-1"
    },
    kO = ["href"],
    _O = {
        class: "text-xl font-semibold text-gray-900"
    },
    EO = {
        class: "mt-3 text-base text-gray-500"
    },
    PO = {
        class: "mt-6 flex items-center justify-center"
    },
    SO = ["href"],
    Wp = nt({
        __name: "community",
        setup(t) {
            const e = [{
                title: "Discord",
                href: "https://discord.gg/rocketpool",
                description: "Rocket Pool has a warm and welcoming community! Want to ask questions? Find out more? Or just have a chat? Come join us on Discord.",
                imageUrl: ["fab", "discord"],
                cta: "Join our discord"
            }, {
                title: "Medium",
                href: "https://medium.com/rocket-pool",
                description: "Our articles explain every aspect of Rocket Pool from, how to stake ETH? become a node operator? or how our tokenomics work? Take a jump down the rabbit hole.",
                imageUrl: ["fab", "medium"],
                cta: "Read our articles"
            }, {
                title: "Twitter",
                href: "https://twitter.com/Rocket_Pool",
                description: "Find out what is happening in the Rocket Pool and Ethereum staking ecosystem. Like, Retweet, you know what to do.",
                imageUrl: ["fab", "x-twitter"],
                cta: "Follow us"
            }, {
                title: "GitHub",
                href: "https://github.com/rocket-pool",
                description: "The Rocket Pool protocol is Open-Source, check it out! Deep-dive into how Rocket Pool works! Run our tests and check things for yourself.",
                imageUrl: ["fab", "github"],
                cta: "Review our code"
            }, {
                title: "Forum",
                href: "https://dao.rocketpool.net",
                description: "Join the discussion about new features, improvements and governance of the Rocket Pool protocol.",
                imageUrl: ["fab", "discourse"],
                cta: "Discuss"
            }];
            return (n, r) => {
                const i = Lr("fa");
                return fe(), be("div", dO, [hO, pO, mO, m("div", gO, [yO, m("div", vO, [(fe(), be(Ye, null, xt(e, s => m("div", {
                    key: s.title,
                    class: "flex flex-col rounded-lg shadow-lg overflow-hidden"
                }, [m("div", bO, [m("div", wO, [q(i, {
                    icon: s.imageUrl,
                    size: "8x",
                    class: "h-48 w-48 mx-auto p-4 text-white block",
                    "aria-hidden": "true"
                }, null, 8, ["icon"])])]), m("div", xO, [m("div", AO, [m("a", {
                    href: s.href,
                    class: "block mt-2"
                }, [m("p", _O, ue(s.title), 1), m("p", EO, ue(s.description), 1)], 8, kO)]), m("div", PO, [m("a", {
                    href: s.href,
                    target: "_blank",
                    rel: "noreferrer",
                    class: "inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"
                }, ue(s.cta), 9, SO)])])])), 64))])])])
            }
        }
    }),
    NO = "/assets/lighthouse-j0iiH2FU.webp",
    RO = "data:image/webp;base64,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",
    CO = "data:image/webp;base64,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",
    OO = "data:image/webp;base64,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",
    TO = "data:image/webp;base64,UklGRtQDAABXRUJQVlA4WAoAAAAQAAAAXwAAXwAAQUxQSCoDAAABgFXbVlBrRzgRiEAEIhiBCEY4EYhABCMQwQhEOA32h16Eo+O934iYAPwZQ9pVj3Ytqil+imylcWIrm3xC2E8uPPfwMsknl7f8olCMLk3lHVLp11ReoEbXpt5Sp/uePEnh/HNLuMZc+gOyiJt4cmHCaKw2xjM6ycaVOgSIjtGyC+XaU8aA0IbI4qBytWlprRVNd4COsS6rdHykG2w2xLqo0neLF0QbYl1S6bGkq5686gVpjHWB0iV+BjWShwBAHmOdlukz/gDkIHkKABxjzJOiOTm0tlY1AkA28riIjTFOkZPOzw1ANFIBQB90mVHovwqQSCYA6GM8JiT61YS4VSN5CrCT/aIPuD2S7kkAQArJA0AjNwDyxOSJ0nmvAZuRGUhkA4D6gOVBMG+kZSTSADQyANAnDGOVb8xQMgOZPJCKPapDga80QecJbJwdRuqCLuGYRsVJHgen1wGxBQXAZg9a3s8bUy4Ov3YuTAAgx9ABAO2yXn/1FeECbDYQL8lH/xG5Ej/l+IVbH4x3xQWw2dDmpNx1J5DjYpfQnfSbSC/AZuQOiBq9xsvuCHJ0AAf97pdjjTwABEh0XC99TXoEoHvqAIRrdcZujgggLWozEE9HCciLKDMA9bMBuirPQTy9qIM+CVL8tFXcJgGpu6ge+jRI9dA8UKcBm30D4zzI8Q0W5gH1E3jKgs1B9cAep8npQF3Q8qTYuVrdkC1MkML1CmQvZI0PRI0OdyD5Ic+S5C7uB30mICyrqf26ba11+g0AlgUg1CHnANAWFVxDtXe0S1ljcgOI2hvKZVujGJTc/W2XsMRkBEDu3uSCc4Xisfk6cVsWdDyvvva7uCBPSL7CHfq0jpnd04mfOi1PKZ72X2FWw9ToyOQX6qQ0B91PxWCY0zC5+AkjqFPSrOimYjjoxB3T1WsY+w8mfmx6hvotBROlf8kpMxDtOyxibv6OjNn6FRnz6zdUrKxfULG2vq9idXnbjvX5XRkek73HInxKe0sTuNV3KDzH5q9FOM/dl2X4FzU/poJXyt59mAreux3rzix4t+RjxVkCPjFpswlnzQFfKimr1natqlvCnxFWUDgghAAAADAJAJ0BKmAAYAA+bSySRaQioZgEAEAGxLSAC2w/AH8A/AD9AKf9GQfSugZOqd6mv3qcmooIBi25hOEjlZXpu3/D2McaNfyEgIlyUS63wtlKNAwA/vNh//77S//fVH//vtjKDLAyEm/8f87qSqAhguQEhKK/imR//+h0ko98N7TQw4AAAA==",
    BO = "data:image/webp;base64,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",
    IO = "data:image/webp;base64,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",
    DO = "data:image/webp;base64,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",
    LO = "data:image/webp;base64,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",
    MO = "data:image/webp;base64,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",
    FO = "data:image/webp;base64,UklGRmIEAABXRUJQVlA4IFYEAADQGQCdASp9AH0APm0ylkikIqIhJZdI6IANiWdu3V+ZSV+v/ZL/kzXfH9G/FDzP713mf2g40jJX7N+Q+il/uW+Vcd/kH+p/qeoa/mv97/LvmWvCPYA/kv9a/4vpL/OnnQ+gf+p/hfgH/lH9U/4nXw/ar2TxzHihbkJLQtyEloW1L/a7GYqGJ2ZzftAFH6Gxo/3CLVf7cCyf+QEz8twcQY3YbFUGA2BH7bX59NQqw4MGcVcjvq4aHrmxqWgqcRFz3+wa1d0vfRjIfqWv6bF7XpLQtyEloW4qAAD+/K0QAAEj8cvK7FX4RZfW8CUGuUGMNaldu2JF+A4WWZ9mtBKSmaA6UKD+9l/80nulv8myn+LBtfaFHUZryLhAZ+OqvYrNPLsV6m+41WtDbbkhCvIe87S+TonYWWrCY3EBmGx3ur0OB7iPcGysuu/4WfflKvpcLDfh2f8WBk533agmqHAe+ACvuaHxn7QHuEbsFCT//PbiiceyYqL9aDyQk1PXhdhG4j+LevEsSqJ/++3lK5nyaNglKD+unya/3aXqGaoFM4e7WUjpaZJVxlMTDHtJv/+/Tda3ZxKoWjRFs/4kcKOB7YxwccphuE+PC/16AFwC1V7GnC7jP8wuNCnqE5cAUlG6cBdSbKhFVEz8etAbUbKmWYtfdsPMEkK15P+KPjTsjvNA6cYfyFuNbPw7lPGx7x+miBIsvOup7GqQevOxnzj2YI8N8PJ2bTYLsVIdtbf5VpTqJKQl1WLAhwT6XnGZfrXgderouAISjwc/4XeX7Tv/rel/4bh5ZhNwDkXW/kbXus3oeNrhdEWZJGVqtoNj7/QCXx4TK+RVsU0xVBq1q4KUYtOzX1/mrBPZgMxK+gvKc7BFg6mUjMC12VFfUmKYOpUV2FiKoYrDMtwcjyXNujCebUIybVspkAov4Rvxj6Z4f5A6lV8m+ySU36BScaHtU96I1yz5BxNwjGswhDAtOV39prkE/ScUEvWv8S/W/SrRmcPH2k0/X/UrXP3rJ14081Phqh96fpVDYDsCBwfz/ZqmtpYtQX3195lIteCaRC58KD6ePuZTJtlNX+lQDaPjTNyqCPJ9r8w/Lbq/u3EDy3H7Y82Q7j30agR2//KG5iBGIELJWcQVO/WT07l+C7+nwyeUQ/4whVZG2n/4mFkAMHfsGNXk/NmH+z0pINuCgPWgZeuYmAWQg/eqd3khuQ8Goh1n+zemzN6fZS4pwEZSASRR9/rL4qCHMrb9DmX9YvPqVvejeJZvfpJhYdDemmCF8jKzCe6l2+nuWACXAjkMi2s/2hh4gPlEl3jGgxJ+Vt+IEKrGqzpC/5zvx+suLthNgf7rlD4B5jz8//defHy8JMiYKfxukHAH4QJUD8FdljyUMiJrgpLg6kRJppklCooDo7WiKdJDMOxaq7pFslSckT2aE4oa7rkD87qPRnBiuwlYYfYeeKomR7eAb8fESXewnOXjhKgAAAAAAAA=",
    UO = "data:image/webp;base64,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",
    HO = "data:image/webp;base64,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",
    zO = "data:image/webp;base64,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",
    R2 = "data:image/webp;base64,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",
    jO = "data:image/webp;base64,UklGRvAEAABXRUJQVlA4WAoAAAAQAAAAXwAAXwAAQUxQSPoCAAABoIZt2/FGur+k5ti2bdu2PbPeTbO2bdu2bYxt2/7q9ksn14/3zbdd/J+ImACdz3Xwlf2P/C0X9/9kKNDmf60dRGr+r2nckwP1/1Cma7+GPlI69W8eMFLLlCmTIWWWyVCgVb9WAR8N+rVPiFWtV/8mgRjp3fq3T4xVo2fPqramn5YAey9wjOqvFQLHb0qQPgP2SS77Bu0H9g2xdVoNZN+TZHRaDnBotlHt/Qjg3hE0Bq8AWNxV0oA87G85Uotj2Ben+cn3ML0ORqQA61/JUqcC7NOl1B3YX5SUhd0br6ouLLlg1ltRuEjJe2BbePIDOfCGRoYKbfDSpPAx+MqANZdOfrIInpAWw4ONalwaZas0G95tWH7QXmikPlG8u3v1fwryKjwG7wQlLYRDzqWwNEVSi1xoIrkxrpbUvISCoPF5vKTeEbyKSb/+9qok5wgk6SaYIanPY4+1128wV5LuhAv3EK0mSc61t92W+SN0lXkPhH14yZK0AirIJVpd5lswVZKq9L/4F6CMxkDhx7dOayapzDmKs0KhUOgeePEcO+VzJyUBy2B4xsdBmb9BHbnslvViuE6Jt+zHXkaBH7BuH6Lm+P2gmEN+tkKSZQw84mOfv8O2MFzt/ATs/f76bwzFLfzhFIDXtgkceizm7PXQzkhbum5t+icwwfISzC8t2ln+gOG9YXF9SastZtnuH8FjSYW4qZKUWKdOhetgfRUp4SX4SxPhaAtJM6LklS+1zdUl5yY4lTIPsiQNxvjcdRtKagqv6D14NU5ynoNr07ZD7gev7IWSbnJ+A+/LZ1cAWSo18j58bgtwqfrBsfDkpz3g65EXwv5rxi9cAZepQTZsfeDelZBbTQ22YS2aJqnCYux3q9ROb8f6uKPAn5jezUAo+AX2FUlSn9NYs/tLSrl6TRGHXmokM27BHwUcf6+LzD/XfSP9ue4by0vr1lXTn+u+yXxwP7nfDZWktAf3Rk9/20MX/7FuugLz/sgnsu66FEmq8sC2SHTXY9V1HuBWUDgg0AEAAFAOAJ0BKmAAYAA+bTSXSCQjIiEoE5kwgA2JYgDWnAt6X+SvNlaBeB8lrqu/272Afiv/M75jzAfrl+sHYA8o7rAP3A9gD9gPSq/ZH4Dv3D9gf9j//+CTQOdBtXmi4UkPTS0vaIfXVKD5zqGny9C9x6pthTK6qtZUDzecUAD+/EoAAGT/Qpvf/6Hg/4C+4abwf6RP1t09h9bdx/+8JD67d4/SJVYkSVb/m7Lv1prVLyC6h6yL7/VKHk3CSpkEyLLIuL//aNIBqF32cLEVnElRP1+gzJb/tWo7zcfrUcUDMrtH/NDCT3k0Ta+Nb7T59KjNHYVtejgO2tavdDL9xMpyKUqnZMlVTahCLbzHz1Ef6fkRx781LqGdRetMSIvuDrHoIjBc4CpVWJv9ktu3/8LofpuqJw5Uw+O7hSOdnb1aVQS59ZC1V4bRXDzmP/ZoOq2hE0mMfYreu5ZjuQYvxb/SdL//8BkXnQXqgvC4/+TEkjqJFrd9xAB0+uAWFSchjAsX78goXk/TbflteDkiQ894rGtiG8RrlbOb8vXVsiYUCpvxLVNVv+4osfVGpRQdAMhgAXG9i4uldH5bXlb/fNyyIxf5eurSCYq5lgEq7wAAAAAA",
    VO = "data:image/webp;base64,UklGRhYDAABXRUJQVlA4WAoAAAAQAAAAXwAAXwAAQUxQSIoCAAABoC3JtmnbalvHtm3btm3btm1f+95xbevYtm3bVj2MMfEHJyImQG9EHVHrrc0nzm59r3qEI4UxxkjGbzFHnonLDh3f9HaVCEfC7j/uObP9px5JXJmMMe9LamfMx0lcKYwxCyRV2IPnziJWFgAJv00kZfzlNe6dSaXIYXdx3x0fbRUB7kpaAiyNcmQBzkrdX+LzaaPwSt/E+wcp7h/4XREvEPMdSRy1XgE83Lz1IcCjXGFlv419/dJrnqWTvsN+cvaJxZ8RgejgI9ZZ4OXoOFKCqa842CTCR5YsWUYAy7NkyRJPKwB+ySulnv251BTgQotYiml2DqB9sCclvdoDdJKzS5tIyYekLsAfklQS4D05Y0k7gAvpZKc+D+wPxqW0Hj8A2xUwlFnA1bguKT1AW7lbAGQNcBXYElsJre3AKKv9EHfKcP4FPpJ3PeBZHI/YT4GGAfruAL6QrLNAR2sv7vzhrAUm+WgHXJT3OaBLgC4ZrwKDHbuBIf7ShPMf8J6PesDTWB4xT4BGQVT+ObyqYf0MrLAW//HHQeBBdDjzgAuxvDIANPNoDJAjkHoBt62OAHXk/Bv4R+FUAJjripb2AqdSOlKcBA4rwGBJ7+M8G/cycL+FpKjJAE1C0maArzNLKWZ8IHUAOFkvSlENTgJ0DjJEUqx1LjXFPvjpl+cAtkaEVfAR9vkzr3iYQhH/Y9878QB7aUQYSn3Opf6v8Xkxs8JStYeW82Mp8SbLc0NihaJij12qedhraVqFp7xrvfYlkmLNfOLxYGoshaR2Hops+OG2U8fWzy4tZwpjjHFUMMYM8pBKzll//MzW92tFyk41+K/jZ/f+0ieJnJmMMe9LameMqeXSIGMWWG/2DVZQOCBmAAAAcAUAnQEqYABgAD5tMJRGpCMiISuIAIANiWkA1MggWoCbW0iYOXd3RpHKkax8iBxxNraNQAD++yGAAEJ+dlFWNilwUSRpnqRcoouH//6/nYKA3sKvsYxQQOSVJretpA0WaqAAAAAA",
    GO = "data:image/webp;base64,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",
    WO = {},
    QO = Ko('<div class="bg-white"><div class="max-w-7xl mx-auto py-12 px-4 text-center sm:px-6 lg:px-8 lg:py-24"><div class="lg:text-center"><h2 class="py-2 text-center text-4xl font-extrabold tracking-tight sm:text-6xl bg-gradient-to-r from-red-500 via-yellow-400 to-red-400 bg-clip-text text-transparent leading-8"> Oracle DAO </h2><p class="mt-4 max-w-3xl text-xl text-gray-600 lg:mx-auto font-semibold">Our Oracle DAO features key Ethereum projects, infrastructure and industry.</p></div><div class="max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:py-16 lg:px-8"><div class="mt-6 grid grid-cols-2 gap-0.5 md:grid-cols-3 lg:mt-8"><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://lighthouse.sigmaprime.io/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + NO + '" alt="Lighthouse ETH2 Client Team"></a><a href="https://lighthouse.sigmaprime.io/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Lighthouse ETH2 Client Team</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://nimbus.team/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + RO + '" alt="Nimbus ETH2 Client Team"></a><a href="https://nimbus.team/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Nimbus ETH2 Client Team</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50 hidden"><a href="https://prysmaticlabs.com/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + CO + '" alt="Prysm ETH2 Client Team"></a><a href="https://prysmaticlabs.com/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Prysm ETH2 Client Team</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://etherscan.io/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + OO + '" alt="Etherscan / Beaconscan"></a><a href="https://etherscan.io/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Etherscan / Beaconscan</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://beaconcha.in/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + TO + '" alt="Beaconcha.in"></a><a href="https://beaconcha.in/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Beaconcha.in</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://consensys.net/codefi/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + BO + '" alt="Consensys Codefi"></a><a href="https://consensys.net/codefi/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Consensys Codefi</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://www.youtube.com/channel/UCvCp6vKY5jDr87htKH6hgDA" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + IO + '" alt="Daily Gwei"></a><a href="https://www.youtube.com/channel/UCvCp6vKY5jDr87htKH6hgDA" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Daily Gwei</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50 hidden"><a href="https://blockdaemon.com/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + DO + '" alt="Blockdaemon"></a><a href="https://blockdaemon.com/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Blockdaemon</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50 hidden"><a href="https://staked.us/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + LO + '" alt="Staked"></a><a href="https://staked.us/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Staked</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://blockchain.capital/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + MO + '" alt="Blockchain Capital"></a><a href="https://blockchain.capital/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Blockchain Capital</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://www.youtube.com/channel/UCAl9Ld79qaZxp9JzEOwd3aA" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + FO + '" alt="Bankless"></a><a href="https://www.youtube.com/channel/UCAl9Ld79qaZxp9JzEOwd3aA" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Bankless</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://twitter.com/superphiz/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + UO + '" alt="Superphiz"></a><a href="https://twitter.com/superphiz/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Superphiz</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://www.fireeyes.xyz/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + HO + '" alt="Fire Eyes"></a><a href="https://www.fireeyes.xyz/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Fire Eyes</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://cryptomanufaktur.io/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + zO + '" alt="CryptoManufaktur"></a><a href="https://cryptomanufaktur.io/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">CryptoManufaktur</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://rocketpool.net/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + R2 + '" alt="Rocket Pool"></a><a href="https://rocketpool.net/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-base font-semibold text-gray-500 tracking-tight">Rocket Pool</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://ventures.coinbase.com/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + jO + '" alt="Coinbase Ventures"></a><a href="https://ventures.coinbase.com/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-gray">Coinbase Ventures &amp; Unit 411</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://www.gitcoin.co/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + VO + '" alt="GitCoin"></a><a href="https://www.gitcoin.co/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-gray">Gitcoin</p></a></div><div class="col-span-1 flex flex-col justify-center py-8 px-8 bg-gray-50"><a href="https://rpscientists.com/" target="_blank" rel="noreferrer"><img class="max-h-24 m-auto" src="' + GO + '" alt="Rocket Scientists"></a><a href="https://rpscientists.com/" target="_blank" rel="noreferrer"><p class="mt-5 text-center text-gray">Rocket Scientists</p></a></div></div></div></div></div>', 1),
    JO = [QO];

function KO(t, e) {
    return fe(), be("div", null, JO)
}
const ZO = ef(WO, [
        ["render", KO]
    ]),
    YO = "/assets/team-member-david-VBtThkfS.webp",
    XO = "/assets/team-member-darren-7LuN2Zp6.webp",
    qO = "/assets/team-member-kane-QTBvjzEZ.webp",
    $O = "/assets/team-member-nick-bvgjW_fE.webp",
    eT = "/assets/team-member-joe-mkaf5znK.webp",
    tT = "/assets/team-member-mav-nick-k64gKkKi.webp",
    nT = {
        class: "relative pt-16 pb-20 px-4 sm:px-6 lg:pt-24 lg:pb-28 lg:px-8 team overflow-hidden"
    },
    rT = m("div", {
        class: "bg-fx"
    }, null, -1),
    iT = m("div", {
        class: "bg-clouds-bottom"
    }, null, -1),
    sT = m("div", {
        class: "bg-clouds-top"
    }, null, -1),
    oT = {
        class: "relative max-w-7xl text-center sm:text-left mx-auto py-12 px-4 sm:px-6 lg:px-8 lg:py-24 z-20"
    },
    aT = {
        class: "space-y-12"
    },
    lT = m("div", {
        class: "text-center"
    }, [m("h2", {
        class: "py-2 text-center text-4xl font-extrabold tracking-tight sm:text-6xl bg-gradient-to-r from-red-300 via-yellow-300 to-red-400 bg-clip-text text-transparent leading-8"
    }, "Our Team"), m("p", {
        class: "mt-3 max-w-2xl mx-auto text-xl text-gray-100 sm:mt-4"
    }, "Our hard-working and very experienced team.")], -1),
    cT = {
        role: "list",
        class: "mx-auto space-y-16 sm:space-y-0 lg:max-w-4xl"
    },
    uT = {
        class: "space-y-6 sm:flex py-8"
    },
    fT = {
        class: "mb-4 flex-shrink-0 sm:mb-0 sm:mr-4"
    },
    dT = ["src"],
    hT = {
        class: "space-y-2"
    },
    pT = {
        class: "text-lg leading-6 space-y-1"
    },
    mT = {
        class: "font-semibold text-yellow-200"
    },
    gT = {
        class: "font-bold text-gray-100 text-base"
    },
    yT = {
        class: "text-lg"
    },
    vT = {
        class: "text-base text-gray-100"
    },
    bT = nt({
        __name: "team",
        setup(t) {
            const e = [{
                name: "David Rugendyke",
                role: "Founder & CTO",
                description: "David has over 18 years commercial experience as a senior developer with a computer science background and started designing Rocket Pool in late 2016. He is currently committed to developing Rocket Pool full time as the chief technology officer.",
                image: YO
            }, {
                name: "Darren Langley",
                role: "General Manager",
                description: "Darren has over 18 years commercial experience, he has managed and mentored development teams, designed application architecture, and delivered exciting digital products for government, financial services, blockchain services, and more.",
                image: XO
            }, {
                name: "Kane Wallmann",
                role: "Senior Solidity Engineer",
                description: "Kane has over 15 years experience in web and application development. In 2017, the Ethereum revolution caught his attention and he has been developing smart contracts and their supporting infrastructure ever since. He also makes pizza!",
                image: qO
            }, {
                name: "Nick Doherty",
                role: "Senior Blockchain Engineer",
                description: "Nick has over 15 years experience engineering high-level technical solutions in the advertising, e-commerce and finance sectors. With previous quant experience in traditional markets, he is now targeting these skills towards the blockchain.",
                image: $O
            }, {
                name: "Joe Clapis",
                role: "Senior Blockchain Engineer",
                description: "Joe has over 11 years experience as a software systems engineer and has worked on systems ranging from spacecraft simulators to quantum computers to blockchain apps. He is an avid problem solver and enjoys creating solutions to challenging problems.",
                image: eT
            }, {
                name: "Maverick (Nick Ashley)",
                role: "Marketing & Community Manager",
                description: "Nick earned his callsign Maverick from a background in aviation marketing, in addition to flying light aircraft as a hobby. After bringing years of globe-spanning consulting expertise to the blockchain world, it will be put to good use helping to take Rocket Pool to new heights.",
                image: tT
            }];
            return (n, r) => (fe(), be("div", nT, [rT, iT, sT, m("div", oT, [m("div", aT, [lT, m("ul", cT, [(fe(), be(Ye, null, xt(e, i => m("li", {
                key: i.name
            }, [m("div", uT, [m("div", fT, [m("img", {
                class: "h-30 w-30 mx-auto",
                src: i.image
            }, null, 8, dT)]), m("div", hT, [m("div", pT, [m("h3", mT, ue(i.role), 1), m("p", gT, ue(i.name), 1)]), m("div", yT, [m("p", vT, ue(i.description), 1)])])])])), 64))])])])]))
        }
    });

function hu(t, e, ...n) {
    if (t in e) {
        let i = e[t];
        return typeof i == "function" ? i(...n) : i
    }
    let r = new Error(`Tried to handle "${t}" but there is no handler defined. Only defined handlers are: ${Object.keys(e).map(i=>`"${i}"`).join(", ")}.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r, hu), r
}
var _h = (t => (t[t.None = 0] = "None", t[t.RenderStrategy = 1] = "RenderStrategy", t[t.Static = 2] = "Static", t))(_h || {}),
    wT = (t => (t[t.Unmount = 0] = "Unmount", t[t.Hidden = 1] = "Hidden", t))(wT || {});

function Vs({
    visible: t = !0,
    features: e = 0,
    ourProps: n,
    theirProps: r,
    ...i
}) {
    var s;
    let o = O2(r, n),
        a = Object.assign(i, {
            props: o
        });
    if (t || e & 2 && o.static) return yd(a);
    if (e & 1) {
        let c = (s = o.unmount) == null || s ? 0 : 1;
        return hu(c, {
            0() {
                return null
            },
            1() {
                return yd({ ...i,
                    props: { ...o,
                        hidden: !0,
                        style: {
                            display: "none"
                        }
                    }
                })
            }
        })
    }
    return yd(a)
}

function yd({
    props: t,
    attrs: e,
    slots: n,
    slot: r,
    name: i
}) {
    var s, o;
    let {
        as: a,
        ...c
    } = T2(t, ["unmount", "static"]), l = (s = n.default) == null ? void 0 : s.call(n, r), u = {};
    if (r) {
        let f = !1,
            d = [];
        for (let [h, p] of Object.entries(r)) typeof p == "boolean" && (f = !0), p === !0 && d.push(h);
        f && (u["data-headlessui-state"] = d.join(" "))
    }
    if (a === "template") {
        if (l = C2(l ? ? []), Object.keys(c).length > 0 || Object.keys(e).length > 0) {
            let [f, ...d] = l ? ? [];
            if (!AT(f) || d.length > 0) throw new Error(['Passing props on "template"!', "", `The current component <${i} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(c).concat(Object.keys(e)).map(g => g.trim()).filter((g, b, x) => x.indexOf(g) === b).sort((g, b) => g.localeCompare(b)).map(g => `  - ${g}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map(g => `  - ${g}`).join(`
`)].join(`
`));
            let h = O2((o = f.props) != null ? o : {}, c),
                p = ii(f, h);
            for (let g in h) g.startsWith("on") && (p.props || (p.props = {}), p.props[g] = h[g]);
            return p
        }
        return Array.isArray(l) && l.length === 1 ? l[0] : l
    }
    return Ns(a, Object.assign({}, c, u), {
        default: () => l
    })
}

function C2(t) {
    return t.flatMap(e => e.type === Ye ? C2(e.children) : [e])
}

function O2(...t) {
    if (t.length === 0) return {};
    if (t.length === 1) return t[0];
    let e = {},
        n = {};
    for (let r of t)
        for (let i in r) i.startsWith("on") && typeof r[i] == "function" ? (n[i] != null || (n[i] = []), n[i].push(r[i])) : e[i] = r[i];
    if (e.disabled || e["aria-disabled"]) return Object.assign(e, Object.fromEntries(Object.keys(n).map(r => [r, void 0])));
    for (let r in n) Object.assign(e, {
        [r](i, ...s) {
            let o = n[r];
            for (let a of o) {
                if (i instanceof Event && i.defaultPrevented) return;
                a(i, ...s)
            }
        }
    });
    return e
}

function xT(t) {
    let e = Object.assign({}, t);
    for (let n in e) e[n] === void 0 && delete e[n];
    return e
}

function T2(t, e = []) {
    let n = Object.assign({}, t);
    for (let r of e) r in n && delete n[r];
    return n
}

function AT(t) {
    return t == null ? !1 : typeof t.type == "string" || typeof t.type == "object" || typeof t.type == "function"
}
let kT = 0;

function _T() {
    return ++kT
}

function pu() {
    return _T()
}
var Ti = (t => (t.Space = " ", t.Enter = "Enter", t.Escape = "Escape", t.Backspace = "Backspace", t.Delete = "Delete", t.ArrowLeft = "ArrowLeft", t.ArrowUp = "ArrowUp", t.ArrowRight = "ArrowRight", t.ArrowDown = "ArrowDown", t.Home = "Home", t.End = "End", t.PageUp = "PageUp", t.PageDown = "PageDown", t.Tab = "Tab", t))(Ti || {});

function Or(t) {
    var e;
    return t == null || t.value == null ? null : (e = t.value.$el) != null ? e : t.value
}
let B2 = Symbol("Context");
var sl = (t => (t[t.Open = 1] = "Open", t[t.Closed = 2] = "Closed", t[t.Closing = 4] = "Closing", t[t.Opening = 8] = "Opening", t))(sl || {});

function ET() {
    return we(B2, null)
}

function PT(t) {
    de(B2, t)
}

function Q1(t, e) {
    if (t) return t;
    let n = e ? ? "button";
    if (typeof n == "string" && n.toLowerCase() === "button") return "button"
}

function I2(t, e) {
    let n = Z(Q1(t.value.type, t.value.as));
    return sn(() => {
        n.value = Q1(t.value.type, t.value.as)
    }), Zc(() => {
        var r;
        n.value || Or(e) && Or(e) instanceof HTMLButtonElement && !((r = Or(e)) != null && r.hasAttribute("type")) && (n.value = "button")
    }), n
}
var D2 = (t => (t[t.None = 1] = "None", t[t.Focusable = 2] = "Focusable", t[t.Hidden = 4] = "Hidden", t))(D2 || {});
let ST = nt({
    name: "Hidden",
    props: {
        as: {
            type: [Object, String],
            default: "div"
        },
        features: {
            type: Number,
            default: 1
        }
    },
    setup(t, {
        slots: e,
        attrs: n
    }) {
        return () => {
            let {
                features: r,
                ...i
            } = t, s = {
                "aria-hidden": (r & 2) === 2 ? !0 : void 0,
                style: {
                    position: "fixed",
                    top: 1,
                    left: 1,
                    width: 1,
                    height: 0,
                    padding: 0,
                    margin: -1,
                    overflow: "hidden",
                    clip: "rect(0, 0, 0, 0)",
                    whiteSpace: "nowrap",
                    borderWidth: "0",
                    ...(r & 4) === 4 && (r & 2) !== 2 && {
                        display: "none"
                    }
                }
            };
            return Vs({
                ourProps: s,
                theirProps: i,
                slot: {},
                attrs: n,
                slots: e,
                name: "Hidden"
            })
        }
    }
});

function NT(t) {
    var e, n;
    let r = (e = t ? .form) != null ? e : t.closest("form");
    if (r) {
        for (let i of r.elements)
            if (i !== t && (i.tagName === "INPUT" && i.type === "submit" || i.tagName === "BUTTON" && i.type === "submit" || i.nodeName === "INPUT" && i.type === "image")) {
                i.click();
                return
            }(n = r.requestSubmit) == null || n.call(r)
    }
}

function RT(t, e, n) {
    let r = Z(n ? .value),
        i = ze(() => t.value !== void 0);
    return [ze(() => i.value ? t.value : r.value), function(s) {
        return i.value || (r.value = s), e ? .(s)
    }]
}
let L2 = Symbol("DescriptionContext");

function CT() {
    let t = we(L2, null);
    if (t === null) throw new Error("Missing parent");
    return t
}

function OT({
    slot: t = Z({}),
    name: e = "Description",
    props: n = {}
} = {}) {
    let r = Z([]);

    function i(s) {
        return r.value.push(s), () => {
            let o = r.value.indexOf(s);
            o !== -1 && r.value.splice(o, 1)
        }
    }
    return de(L2, {
        register: i,
        slot: t,
        name: e,
        props: n
    }), ze(() => r.value.length > 0 ? r.value.join(" ") : void 0)
}
let TT = nt({
    name: "Description",
    props: {
        as: {
            type: [Object, String],
            default: "p"
        },
        id: {
            type: String,
            default: () => `headlessui-description-${pu()}`
        }
    },
    setup(t, {
        attrs: e,
        slots: n
    }) {
        let r = CT();
        return sn(() => Us(r.register(t.id))), () => {
            let {
                name: i = "Description",
                slot: s = Z({}),
                props: o = {}
            } = r, {
                id: a,
                ...c
            } = t, l = { ...Object.entries(o).reduce((u, [f, d]) => Object.assign(u, {
                    [f]: J(d)
                }), {}),
                id: a
            };
            return Vs({
                ourProps: l,
                theirProps: c,
                slot: s.value,
                attrs: e,
                slots: n,
                name: i
            })
        }
    }
});
var BT = (t => (t[t.Open = 0] = "Open", t[t.Closed = 1] = "Closed", t))(BT || {});
let M2 = Symbol("DisclosureContext");

function Qp(t) {
    let e = we(M2, null);
    if (e === null) {
        let n = new Error(`<${t} /> is missing a parent <Disclosure /> component.`);
        throw Error.captureStackTrace && Error.captureStackTrace(n, Qp), n
    }
    return e
}
let F2 = Symbol("DisclosurePanelContext");

function IT() {
    return we(F2, null)
}
let is = nt({
        name: "Disclosure",
        props: {
            as: {
                type: [Object, String],
                default: "template"
            },
            defaultOpen: {
                type: [Boolean],
                default: !1
            }
        },
        setup(t, {
            slots: e,
            attrs: n
        }) {
            let r = Z(t.defaultOpen ? 0 : 1),
                i = Z(null),
                s = Z(null),
                o = {
                    buttonId: Z(`headlessui-disclosure-button-${pu()}`),
                    panelId: Z(`headlessui-disclosure-panel-${pu()}`),
                    disclosureState: r,
                    panel: i,
                    button: s,
                    toggleDisclosure() {
                        r.value = hu(r.value, {
                            0: 1,
                            1: 0
                        })
                    },
                    closeDisclosure() {
                        r.value !== 1 && (r.value = 1)
                    },
                    close(a) {
                        o.closeDisclosure();
                        let c = (() => a ? a instanceof HTMLElement ? a : a.value instanceof HTMLElement ? Or(a) : Or(o.button) : Or(o.button))();
                        c ? .focus()
                    }
                };
            return de(M2, o), PT(ze(() => hu(r.value, {
                0: sl.Open,
                1: sl.Closed
            }))), () => {
                let {
                    defaultOpen: a,
                    ...c
                } = t, l = {
                    open: r.value === 0,
                    close: o.close
                };
                return Vs({
                    theirProps: c,
                    ourProps: {},
                    slot: l,
                    slots: e,
                    attrs: n,
                    name: "Disclosure"
                })
            }
        }
    }),
    ss = nt({
        name: "DisclosureButton",
        props: {
            as: {
                type: [Object, String],
                default: "button"
            },
            disabled: {
                type: [Boolean],
                default: !1
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(t, {
            attrs: e,
            slots: n,
            expose: r
        }) {
            let i = Qp("DisclosureButton"),
                s = IT(),
                o = ze(() => s === null ? !1 : s.value === i.panelId.value);
            sn(() => {
                o.value || t.id !== null && (i.buttonId.value = t.id)
            }), Us(() => {
                o.value || (i.buttonId.value = null)
            });
            let a = Z(null);
            r({
                el: a,
                $el: a
            }), o.value || Zc(() => {
                i.button.value = a.value
            });
            let c = I2(ze(() => ({
                as: t.as,
                type: e.type
            })), a);

            function l() {
                var d;
                t.disabled || (o.value ? (i.toggleDisclosure(), (d = Or(i.button)) == null || d.focus()) : i.toggleDisclosure())
            }

            function u(d) {
                var h;
                if (!t.disabled)
                    if (o.value) switch (d.key) {
                        case Ti.Space:
                        case Ti.Enter:
                            d.preventDefault(), d.stopPropagation(), i.toggleDisclosure(), (h = Or(i.button)) == null || h.focus();
                            break
                    } else switch (d.key) {
                        case Ti.Space:
                        case Ti.Enter:
                            d.preventDefault(), d.stopPropagation(), i.toggleDisclosure();
                            break
                    }
            }

            function f(d) {
                switch (d.key) {
                    case Ti.Space:
                        d.preventDefault();
                        break
                }
            }
            return () => {
                var d;
                let h = {
                        open: i.disclosureState.value === 0
                    },
                    {
                        id: p,
                        ...g
                    } = t,
                    b = o.value ? {
                        ref: a,
                        type: c.value,
                        onClick: l,
                        onKeydown: u
                    } : {
                        id: (d = i.buttonId.value) != null ? d : p,
                        ref: a,
                        type: c.value,
                        "aria-expanded": i.disclosureState.value === 0,
                        "aria-controls": i.disclosureState.value === 0 || Or(i.panel) ? i.panelId.value : void 0,
                        disabled: t.disabled ? !0 : void 0,
                        onClick: l,
                        onKeydown: u,
                        onKeyup: f
                    };
                return Vs({
                    ourProps: b,
                    theirProps: g,
                    slot: h,
                    attrs: e,
                    slots: n,
                    name: "DisclosureButton"
                })
            }
        }
    }),
    os = nt({
        name: "DisclosurePanel",
        props: {
            as: {
                type: [Object, String],
                default: "div"
            },
            static: {
                type: Boolean,
                default: !1
            },
            unmount: {
                type: Boolean,
                default: !0
            },
            id: {
                type: String,
                default: null
            }
        },
        setup(t, {
            attrs: e,
            slots: n,
            expose: r
        }) {
            let i = Qp("DisclosurePanel");
            sn(() => {
                t.id !== null && (i.panelId.value = t.id)
            }), Us(() => {
                i.panelId.value = null
            }), r({
                el: i.panel,
                $el: i.panel
            }), de(F2, i.panelId);
            let s = ET(),
                o = ze(() => s !== null ? (s.value & sl.Open) === sl.Open : i.disclosureState.value === 0);
            return () => {
                var a;
                let c = {
                        open: i.disclosureState.value === 0,
                        close: i.close
                    },
                    {
                        id: l,
                        ...u
                    } = t,
                    f = {
                        id: (a = i.panelId.value) != null ? a : l,
                        ref: i.panel
                    };
                return Vs({
                    ourProps: f,
                    theirProps: u,
                    slot: c,
                    attrs: e,
                    slots: n,
                    features: _h.RenderStrategy | _h.Static,
                    visible: o.value,
                    name: "DisclosurePanel"
                })
            }
        }
    }),
    DT = Symbol("LabelContext");

function LT({
    slot: t = {},
    name: e = "Label",
    props: n = {}
} = {}) {
    let r = Z([]);

    function i(s) {
        return r.value.push(s), () => {
            let o = r.value.indexOf(s);
            o !== -1 && r.value.splice(o, 1)
        }
    }
    return de(DT, {
        register: i,
        slot: t,
        name: e,
        props: n
    }), ze(() => r.value.length > 0 ? r.value.join(" ") : void 0)
}
let U2 = Symbol("GroupContext"),
    Jp = nt({
        name: "SwitchGroup",
        props: {
            as: {
                type: [Object, String],
                default: "template"
            }
        },
        setup(t, {
            slots: e,
            attrs: n
        }) {
            let r = Z(null),
                i = LT({
                    name: "SwitchLabel",
                    props: {
                        htmlFor: ze(() => {
                            var o;
                            return (o = r.value) == null ? void 0 : o.id
                        }),
                        onClick(o) {
                            r.value && (o.currentTarget.tagName === "LABEL" && o.preventDefault(), r.value.click(), r.value.focus({
                                preventScroll: !0
                            }))
                        }
                    }
                }),
                s = OT({
                    name: "SwitchDescription"
                });
            return de(U2, {
                switchRef: r,
                labelledby: i,
                describedby: s
            }), () => Vs({
                theirProps: t,
                ourProps: {},
                slot: {},
                slots: e,
                attrs: n,
                name: "SwitchGroup"
            })
        }
    }),
    Kp = nt({
        name: "Switch",
        emits: {
            "update:modelValue": t => !0
        },
        props: {
            as: {
                type: [Object, String],
                default: "button"
            },
            modelValue: {
                type: Boolean,
                default: void 0
            },
            defaultChecked: {
                type: Boolean,
                optional: !0
            },
            form: {
                type: String,
                optional: !0
            },
            name: {
                type: String,
                optional: !0
            },
            value: {
                type: String,
                optional: !0
            },
            id: {
                type: String,
                default: () => `headlessui-switch-${pu()}`
            }
        },
        inheritAttrs: !1,
        setup(t, {
            emit: e,
            attrs: n,
            slots: r,
            expose: i
        }) {
            let s = we(U2, null),
                [o, a] = RT(ze(() => t.modelValue), b => e("update:modelValue", b), ze(() => t.defaultChecked));

            function c() {
                a(!o.value)
            }
            let l = Z(null),
                u = s === null ? l : s.switchRef,
                f = I2(ze(() => ({
                    as: t.as,
                    type: n.type
                })), u);
            i({
                el: u,
                $el: u
            });

            function d(b) {
                b.preventDefault(), c()
            }

            function h(b) {
                b.key === Ti.Space ? (b.preventDefault(), c()) : b.key === Ti.Enter && NT(b.currentTarget)
            }

            function p(b) {
                b.preventDefault()
            }
            let g = ze(() => {
                var b, x;
                return (x = (b = Or(u)) == null ? void 0 : b.closest) == null ? void 0 : x.call(b, "form")
            });
            return sn(() => {
                Xe([g], () => {
                    if (!g.value || t.defaultChecked === void 0) return;

                    function b() {
                        a(t.defaultChecked)
                    }
                    return g.value.addEventListener("reset", b), () => {
                        var x;
                        (x = g.value) == null || x.removeEventListener("reset", b)
                    }
                }, {
                    immediate: !0
                })
            }), () => {
                let {
                    id: b,
                    name: x,
                    value: w,
                    form: O,
                    ...N
                } = t, U = {
                    checked: o.value
                }, H = {
                    id: b,
                    ref: u,
                    role: "switch",
                    type: f.value,
                    tabIndex: 0,
                    "aria-checked": o.value,
                    "aria-labelledby": s ? .labelledby.value,
                    "aria-describedby": s ? .describedby.value,
                    onClick: d,
                    onKeyup: h,
                    onKeypress: p
                };
                return Ns(Ye, [x != null && o.value != null ? Ns(ST, xT({
                    features: D2.Hidden,
                    as: "input",
                    type: "checkbox",
                    hidden: !0,
                    readOnly: !0,
                    checked: o.value,
                    form: O,
                    name: x,
                    value: w
                })) : null, Vs({
                    ourProps: H,
                    theirProps: { ...n,
                        ...T2(N, ["modelValue", "defaultChecked"])
                    },
                    slot: U,
                    attrs: n,
                    slots: r,
                    name: "Switch"
                })])
            }
        }
    }),
    mu = TT;

function H2(t, e) {
    return fe(), be("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true"
    }, [m("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M12 6.042A8.967 8.967 0 006 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 016 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 016-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0018 18a8.967 8.967 0 00-6 2.292m0-14.25v14.25"
    })])
}

function z2(t, e) {
    return fe(), be("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true"
    }, [m("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M17.593 3.322c1.1.128 1.907 1.077 1.907 2.185V21L12 17.25 4.5 21V5.507c0-1.108.806-2.057 1.907-2.185a48.507 48.507 0 0111.186 0z"
    })])
}

function as(t, e) {
    return fe(), be("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true"
    }, [m("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M19.5 8.25l-7.5 7.5-7.5-7.5"
    })])
}

function j2(t, e) {
    return fe(), be("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true"
    }, [m("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M17.25 6.75L22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3l-4.5 16.5"
    })])
}

function Ai(t, e) {
    return fe(), be("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true"
    }, [m("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z"
    })])
}

function V2(t, e) {
    return fe(), be("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true"
    }, [m("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9 5.25h.008v.008H12v-.008z"
    })])
}

function MT(t, e) {
    return fe(), be("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "1.5",
        stroke: "currentColor",
        "aria-hidden": "true"
    }, [m("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M6 18L18 6M6 6l12 12"
    })])
}
const FT = {
        class: "bg-white py-16 sm:py-24"
    },
    UT = {
        class: "relative sm:py-16"
    },
    HT = {
        class: "mx-auto max-w-md px-4 sm:max-w-3xl sm:px-6 lg:max-w-7xl lg:px-8"
    },
    zT = m("div", null, [m("h2", {
        class: "py-2 text-center text-4xl font-extrabold tracking-tight sm:text-6xl bg-gradient-to-r from-red-500 via-yellow-400 to-red-400 bg-clip-text text-transparent leading-8"
    }, " Latest News "), m("p", {
        class: "mt-4 text-center max-w-3xl text-xl text-gray-600 lg:mx-auto font-semibold"
    }, "Read more about what is happening with the protocol.")], -1),
    jT = {
        class: "text-lg"
    },
    VT = m("span", {
        class: "text-xl text-gray-600 font-semibold"
    }, "2023", -1),
    GT = {
        class: "ml-6 h-7 flex items-center"
    },
    WT = {
        class: "mt-2 pt-2 grid gap-8"
    },
    QT = {
        class: "text-sm text-indigo-600"
    },
    JT = ["datetime"],
    KT = ["href"],
    ZT = {
        class: "text-xl font-semibold text-gray-900"
    },
    YT = {
        class: "mt-3 text-base text-gray-500"
    },
    XT = {
        class: "mt-3"
    },
    qT = ["href"],
    $T = m("div", {
        class: "relative p-6"
    }, [m("div", {
        class: "absolute inset-0 flex items-center",
        "aria-hidden": "true"
    }, [m("div", {
        class: "border-t border-gray-300 w-9/12 mx-auto"
    })])], -1),
    e9 = {
        class: "text-lg"
    },
    t9 = m("span", {
        class: "text-xl text-gray-600 font-semibold"
    }, "2022", -1),
    n9 = {
        class: "ml-6 h-7 flex items-center"
    },
    r9 = {
        class: "mt-2 pt-2 grid gap-8"
    },
    i9 = {
        class: "text-sm text-indigo-600"
    },
    s9 = ["datetime"],
    o9 = ["href"],
    a9 = {
        class: "text-xl font-semibold text-gray-900"
    },
    l9 = {
        class: "mt-3 text-base text-gray-500"
    },
    c9 = {
        class: "mt-3"
    },
    u9 = ["href"],
    f9 = m("div", {
        class: "relative p-6"
    }, [m("div", {
        class: "absolute inset-0 flex items-center",
        "aria-hidden": "true"
    }, [m("div", {
        class: "border-t border-gray-300 w-9/12 mx-auto"
    })])], -1),
    d9 = {
        class: "text-lg"
    },
    h9 = m("span", {
        class: "text-xl text-gray-600 font-semibold"
    }, "2021", -1),
    p9 = {
        class: "ml-6 h-7 flex items-center"
    },
    m9 = {
        class: "mt-2 pt-2 grid gap-8"
    },
    g9 = {
        class: "text-sm text-indigo-600"
    },
    y9 = ["datetime"],
    v9 = ["href"],
    b9 = {
        class: "text-xl font-semibold text-gray-900"
    },
    w9 = {
        class: "mt-3 text-base text-gray-500"
    },
    x9 = {
        class: "mt-3"
    },
    A9 = ["href"],
    k9 = m("div", {
        class: "relative p-6"
    }, [m("div", {
        class: "absolute inset-0 flex items-center",
        "aria-hidden": "true"
    }, [m("div", {
        class: "border-t border-gray-300 w-9/12 mx-auto"
    })])], -1),
    _9 = {
        class: "text-lg"
    },
    E9 = m("span", {
        class: "text-xl text-gray-600 font-semibold"
    }, "2020", -1),
    P9 = {
        class: "ml-6 h-7 flex items-center"
    },
    S9 = {
        class: "mt-2 pt-2 grid gap-8"
    },
    N9 = {
        class: "text-sm text-indigo-600"
    },
    R9 = ["datetime"],
    C9 = ["href"],
    O9 = {
        class: "text-xl font-semibold text-gray-900"
    },
    T9 = {
        class: "mt-3 text-base text-gray-500"
    },
    B9 = {
        class: "mt-3"
    },
    I9 = ["href"],
    D9 = m("div", {
        class: "relative p-6"
    }, [m("div", {
        class: "absolute inset-0 flex items-center",
        "aria-hidden": "true"
    }, [m("div", {
        class: "border-t border-gray-300 w-9/12 mx-auto"
    })])], -1),
    L9 = {
        class: "text-lg"
    },
    M9 = m("span", {
        class: "text-xl text-gray-600 font-semibold"
    }, "2019", -1),
    F9 = {
        class: "ml-6 h-7 flex items-center"
    },
    U9 = {
        class: "mt-2 pt-2 grid gap-8"
    },
    H9 = {
        class: "text-sm text-indigo-600"
    },
    z9 = ["datetime"],
    j9 = ["href"],
    V9 = {
        class: "text-xl font-semibold text-gray-900"
    },
    G9 = {
        class: "mt-3 text-base text-gray-500"
    },
    W9 = {
        class: "mt-3"
    },
    Q9 = ["href"],
    J9 = m("div", {
        class: "relative p-6"
    }, [m("div", {
        class: "absolute inset-0 flex items-center",
        "aria-hidden": "true"
    }, [m("div", {
        class: "border-t border-gray-300 w-9/12 mx-auto"
    })])], -1),
    K9 = {
        class: "text-lg"
    },
    Z9 = m("span", {
        class: "text-xl text-gray-600 font-semibold"
    }, "2018", -1),
    Y9 = {
        class: "ml-6 h-7 flex items-center"
    },
    X9 = {
        class: "mt-2 pt-2 grid gap-8"
    },
    q9 = {
        class: "text-sm text-indigo-600"
    },
    $9 = ["datetime"],
    e7 = ["href"],
    t7 = {
        class: "text-xl font-semibold text-gray-900"
    },
    n7 = {
        class: "mt-3 text-base text-gray-500"
    },
    r7 = {
        class: "mt-3"
    },
    i7 = ["href"],
    s7 = m("div", {
        class: "relative p-6"
    }, [m("div", {
        class: "absolute inset-0 flex items-center",
        "aria-hidden": "true"
    }, [m("div", {
        class: "border-t border-gray-300 w-9/12 mx-auto"
    })])], -1),
    o7 = {
        class: "text-lg"
    },
    a7 = m("span", {
        class: "text-xl text-gray-600 font-semibold"
    }, "2017", -1),
    l7 = {
        class: "ml-6 h-7 flex items-center"
    },
    c7 = {
        class: "mt-2 pt-2 grid gap-8"
    },
    u7 = {
        class: "text-sm text-indigo-600"
    },
    f7 = ["datetime"],
    d7 = ["href"],
    h7 = {
        class: "text-xl font-semibold text-gray-900"
    },
    p7 = {
        class: "mt-3 text-base text-gray-500"
    },
    m7 = {
        class: "mt-3"
    },
    g7 = ["href"],
    y7 = nt({
        __name: "news",
        setup(t) {
            const e = [{
                    url: "https://medium.com/rocket-pool/rocket-pool-atlas-upgrade-7c69e39a3d5f",
                    title: "Rocket Pool  Atlas Upgrade",
                    summary: "Hello Rocket Poolers! Today were excited to officially announce the protocols next major upgrade, Atlas!",
                    date: "4th March, 2023"
                }],
                n = [{
                    url: "https://medium.com/rocket-pool/rocket-pool-our-first-birthday-8c40e12240c4",
                    title: "Rocket Pool  Our First Birthday!",
                    summary: "Hello Rocket Poolers! Today we are celebrating our first mainnet birthday! For such a momentous occasion, we thought wed take a step back and look at all thats happened in this first amazing year.",
                    date: "9th November, 2022"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-bring-out-your-nodes-9d67ebca70bd",
                    title: "Rocket Pool  Bring out your nodes",
                    summary: "Hello Rocket Poolers! With the the merge just around the corner, weve decided to have a little bit of toungue-in-cheek fun leading up to it.",
                    date: "31st August, 2022"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-protocol-dao-governance-phase-0-4b8ec7bfe07e",
                    title: "Rocket Pool  Protocol DAO Governance Phase 0",
                    summary: "Rocket Pool has a vibrant community. Over the last 5 years, it has developed a unique culture and created enriching relationships between its members.",
                    date: "3rd August, 2022"
                }, {
                    url: "https://medium.com/rocket-pool/the-merge-node-operators-b0f106dcf66f",
                    title: "Rocket Pool  The Merge & Node Operators",
                    summary: "If you are a Rocket Pool node operator you are probably wondering what is happening with The Merge and how you should prepare.",
                    date: "27th July, 2022"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-the-merge-redstone-601d9efd6b4",
                    title: "Rocket Pool  The Merge & Redstone",
                    summary: "Hello Rocket Poolers! Today were exciting to announce Redstone! This is Rocket Pools first major upgrade since launching to mainnet.",
                    date: "28th June, 2022"
                }, {
                    url: "https://medium.com/rocket-pool/devconnect-presentations-panels-6a6e3e1a7922",
                    title: "Rocket Pool  Devconnect Presentations & Panels",
                    summary: "Hello Rocket Poolers! Recently the majority of the team made a (really long) trip to the first ever Devconnect conference in Amsterdam, Netherlands.",
                    date: "4th May, 2022"
                }, {
                    url: "https://medium.com/rocket-pool/where-we-are-and-whats-to-come-7f5f932e9035",
                    title: "Rocket Pool  Where we are and whats to come!",
                    summary: "Hello Rocket Poolers! With our mainnet launch on the 9th November 2021, the decentralised protocol has rocketed to become the second largest Ethereum staking provider in just a matter of weeks.",
                    date: "28th January, 2022"
                }],
                r = [{
                    url: "https://medium.com/rocket-pool/rocket-pool-rpl-token-upgrade-new-addresses-e96c12c55adf",
                    title: "Rocket Pool  RPL Token Upgrade & New Addresses (RPL/rETH)",
                    summary: "Wow what a ride! Now that the Rocket Pool protocol is finally out in the wild, the real work begins.",
                    date: "23rd November, 2021"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-staking-protocol-part-4-2635c44e4f7e",
                    title: "Rocket Pool  ETH2 Staking Protocol Part 4",
                    summary: "Hello Rocket Poolers! Today were extremely excited to announce the launch date of our highly anticipated mainnet release.",
                    date: "9th September, 2021"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-prater-testnet-guides-2428ecdc565e",
                    title: "Rocket Pool  Prater Testnet Guides",
                    summary: "Hello Rocket Poolers! In just a few days on the 2nd August, 2021 00:00 UTC. Our official Prater Testnet site will be open to the public, running from https://testnet.rocketpool.net.",
                    date: "30th July, 2021"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-prater-testnet-launch-ac2a574c18c7",
                    title: "Rocket Pool  Prater Testnet Launch",
                    summary: "Hello Rocket Poolers! Today were very excited to announce the launch date of our highly anticipated Prater testnet.",
                    date: "13th July, 2021"
                }, {
                    url: "https://www.youtube.com/watch?v=-YD5cAbatOc",
                    title: "Bankless - ETH Staking Panel with Rocket Pool",
                    summary: "Darren Langley, General Manager of Rocket Pool appears as a panelist for the Bankless ETH Staking Panel delivering our approach to the world of ETH staking!",
                    date: "15th July, 2021"
                }, {
                    url: "https://medium.com/rocket-pool/the-merge-0x02-mev-and-the-future-of-the-protocol-c7451337ec40",
                    title: "Rocket Pool  The Merge, 0x02, MEV, and the Future of the Protocol",
                    summary: "Hello Rocket Poolers! Like many in the Ethereum community, we have been keeping a close eye on The Merge approach and progress. This update will provide some details on what we have been doing to prepare for The Merge.",
                    date: "23rd June, 2021"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-staking-protocol-part-3-3029afb57d4c",
                    title: "Rocket Pool  ETH2 Staking Protocol Part 3",
                    summary: "Welcome to Part 3 of the Rocket Pool Staking explainer series! As Rocket Pool prepares for the mainnet debut, its important to break down the tokenomics for ETH2 staking on a decentralised, trustless and community-owned staking protocol.",
                    date: "13th April, 2021"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-3-0-beta-finale-fb35c4f8e003",
                    title: "Rocket Pool 3.0  Beta Finale",
                    summary: "Were proud to announce that the Rocket Pool 3.0 Pyrmont Beta will be starting on the 18th March, 2021 00:00 UTC and will feature a 2,500 RPL giveaway for participants! The beta site will be open to the public, running from https://beta.rocketpool.net for several weeks while audits are actively being done by both Sigma Prime and ConsenSys Diligence.",
                    date: "12th March, 2021"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-staking-protocol-part-2-e0d346911fe1",
                    title: "Rocket Pool  ETH2 Staking Protocol Part 2",
                    summary: "Welcome to the second article in the Rocket Pool Staking Protocol Explainer series! This is part of a explainer series that covers all aspects of Rocket Pool, a decentralised, trustless and community owned staking protocol designed for ETH2.",
                    date: "18th February, 2021"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-staking-protocol-part-1-8be4859e5fbd",
                    title: "Rocket Pool  ETH2 Staking Protocol Part 1",
                    summary: "Welcome to the Rocket Pool Staking Protocol Explainer series! This is part of a explainer series that covers all aspects of Rocket Pool, a decentralised, trustless and community owned staking protocol designed for ETH2.",
                    date: "22nd January, 2021"
                }],
                i = [{
                    url: "https://medium.com/rocket-pool/rocket-pool-eth2-our-vision-e367d366d01e",
                    title: "ETH2 Staking, Our Vision",
                    summary: "The launch of the Beacon Chain today marks a significant milestone in Ethereums migration to Proof of Stake. As the most anticipated upgrade in Ethereums five year history, were excited to usher in Phase 0 of ETH2 as a non-custodial, community-owned staking protocol...",
                    date: "1st December, 2020"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-medalla-beta-concludes-f97834d43ebd",
                    title: "Rocket Pool Medalla Beta Concludes",
                    summary: "Our Medalla beta launched on 6th of October, 2020 and has been a great experience. Weve improved numerous aspects of our smart node stack, which makes running ETH2 validators in a decentralised network a smooth and buttery experience. New beta will start on Pyrmont soon!",
                    date: "20th November, 2020"
                }, {
                    url: "https://twitter.com/BanklessHQ/status/1318647748523065347",
                    title: "Bankless - Meet the Nation with Rocket Pool",
                    summary: "A great interview with Bankless, covers everything ETH2 staking + Rocket Pool in much detail.",
                    date: "21st October, 2020"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-2-5-beta-guides-6e6d4d412d82",
                    title: "Rocket Pool Medalla Beta Guides",
                    summary: "Our Medalla beta will be starting in just under a week, on the 6th of October, 2020 00:00 UTC. Were getting excited to see how people will not only stake, but also node operate! Here you can find guides that will help you stake and run a node!",
                    date: "2nd October, 2020"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-2-5-rolling-beta-launch-397a2c976c87",
                    title: "Rocket Pool Medalla Beta Announcement",
                    summary: "Were proud to announce that the Rocket Pool 2.5 Medalla Rolling Beta will be starting in a few weeks, on the 6th October, 2020 00:00 UTC. The beta site will be open to the public, running from https://beta.rocketpool.net for several months at the least, with new features added in several phases.",
                    date: "22nd September, 2020"
                }, {
                    url: "https://medium.com/rocket-pool/development-update-12th-august-372780d6e3fa",
                    title: "Development Update  12th August 2020",
                    summary: "Since our last major announcement on our changes to Rocket Pool 2.5, we've been super busy! So, in today's development update, we'll be covering not only how those changes have been brought to life and the challenges that came with them, but also our plans for the rollout of the next beta on the newly created ETH2 Medalla testnet. Weve even thrown in some pretty screenshots for good measure.",
                    date: "12th August, 2020"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-2-5-tokenised-staking-48601d52d924",
                    title: "Rocket Pool 2.5 Announcement",
                    summary: "We're excited to reveal today some big improvements to Rocket Pool, a decentralised staking network for ETH2. These big changes have been inspired by feedback from our community over many months and have also allowed us to implement some additional features that we've been planning as well.",
                    date: "29th May, 2020"
                }, {
                    url: "https://medium.com/rocket-pool/development-update-10th-april-72db7824c8e0",
                    title: "Development Update  10th April 2020",
                    summary: "Today's development is chock full of info on our GUI client for staking with Rocket Pool in ETH2 as a node operator, and also news about our ETH2 client integration.",
                    date: "10th April, 2020"
                }, {
                    url: "https://medium.com/rocket-pool/development-update-4th-feb-2020-55c1cb7a2ca1",
                    title: "Development Update  6th February 2020",
                    summary: "In our first update for 2020 and hot on the heals of our last beta from November, well be covering progress of our GUI client for node operators in the Rocket Pool network and giving a glimpse into our roadmap for 2020.",
                    date: "6th February, 2020"
                }, {
                    url: "https://twitter.com/AlexSaundersAU/status/1222767964195147776",
                    title: "Everything you need to know about staking on Ethereum 2.0 with @Rocket_Pool",
                    summary: "Want to know a bit more about Rocket Pool + ETH2, but dont want to spend 10 mins digging through google? Well Alex Saunders with Nugget News has you covered. In this talk, he uses his silky- smooth radio voice to talk to David about Rocket Pool and our plans for the staking future of Ethereum. Be sure to give it a listen.",
                    date: "3rd February, 2020"
                }, {
                    url: "https://twitter.com/stakingspace/status/1224408973362724864",
                    title: "Smart Node ETH2 workshop for the Trust-Less 2020 virtual conference",
                    summary: "Dave and Jake give a workshop on how to setup an ETH2 smart node in Rocket Pool for the Trust-Less 2020 virtual conference organised by @DystopiaLabs and @TheBAFNetwork.",
                    date: "2nd February, 2020"
                }],
                s = [{
                    url: "https://medium.com/rocket-pool/rocket-pool-beta-v2-guide-cc68ddf90e61",
                    title: "Rocket Pool v1 Beta Recap + Stats  20 Nov, 2019",
                    summary: "Our V1 Beta has just concluded with over 50,000 testnet ETH staked and close to 1,000 users over 60 days! Get all the stats and info on it in our recap article.",
                    date: "20th November, 2019"
                }, {
                    url: "https://medium.com/rocket-pool/development-update-17-july-2019-f3af7466cbd3",
                    title: "Development Update  17 July, 2019",
                    summary: "In this months update, well be focusing on node operators; those all-important people in the Rocket Pool network who want to run their own node, stake their own ETH, and earn a better staking return overall than they would staking solo.",
                    date: "17th July, 2019"
                }, {
                    url: "https://medium.com/rocket-pool/development-update-7th-june-2019-52f39834d7f5",
                    title: "Development Update  7th June, 2019",
                    summary: "Its been a busy month at the Rocket Pool HQ, and for ETH2 in general, as client teams such as Prysmatic Labs have begun slowly rolling out their own testnets. In this update well be covering our continued work on our upcoming public beta release, our potential rETH token and new mechanics introduced which provide even more safety for your staking deposits. Well also look at some details of our smart node software package design to help improve upgradability, scalability and monitoring(ility). Phew!",
                    date: "7th June, 2019"
                }, {
                    url: "https://podcasts.apple.com/us/podcast/token-talks-interviews-with-the-best-projects-in-crypto/id1362129613?mt=2",
                    title: "Token Talks chat with Zachary DeWitt",
                    summary: "We recently got invited to have a chat on the 'Token Talks' podcast with Zach DeWitt from Wing VC. They're a group based in SF who keep track of promising emerging projects in the crypto world. Was a great chat on Rocket Pool 2.0 & our founder David, goes for about 40mins.",
                    date: "1st May, 2019"
                }, {
                    url: "https://medium.com/rocket-pool/development-update-4th-apr-2019-f585f8c15dd0",
                    title: "Development Update  4th April, 2019",
                    summary: "With EDCON only a short week away, we've added a video of our next beta in action before we travel to Sydney for the event, check it out! 2019 has seen a huge amount of work done on Rocket Pool 2.0, our decentralised staking network, which is aiming to be compatible with phase 0 of Ethereums Serenity updatethe beacon chain. It will provide users and businesses the opportunity to stake their ETH easily - with as little as just a single ETH and even offer their own staking services using our network in the background.",
                    date: "4th April, 2019"
                }, {
                    url: "https://medium.com/rocket-pool/development-update-6th-feb-2019-850e6c01657e",
                    title: "Development Update  6th Feb, 2019",
                    summary: "In this update well feature some early information and screenshots of the new Rocket Pool 2.0 beta, which features a much simpler design than our first version. Staking your ETH in the Rocket Pool network should be a no-brainer.",
                    date: "6th February, 2019"
                }],
                o = [{
                    url: "https://medium.com/rocket-pool/xmas-development-update-23rd-dec-2018-34cee36d8a9",
                    title: "Xmas Development Update  23rd Dec, 2018",
                    summary: "Well what a year its been! From bull markets, to bear markets; from Casper 0.2.0 as a contract, to Casper as part of Serenity; from Rocket Pool alpha, to actual beta release; from Rocket Pool 1.0, to Rocket Pool 2.0; from working as a solo project venture to working with ConsenSys Ventures phew!",
                    date: "23rd December, 2018"
                }, {
                    url: "https://medium.com/rocket-pool/pubsub-pattern-in-solidity-smart-contracts-32012b9881b4",
                    title: "PubSub Pattern in Solidity Smart Contracts",
                    summary: "Rocket Pool is a complex beast with many interlocking parts. After spending some time working on the shiny, new Rocket Pool 2.0, we found that we had a number of contracts which needed to know about changes in others. Here we write about our new approach using the PubSub programming pattern.",
                    date: "29th November, 2018"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-2-0-the-next-generation-cc67ff2b65a8",
                    title: "Rocket Pool 2.0  The Next Generation",
                    summary: "Today, hot on the heels of our 1.0 beta release, we at Rocket Pool are very happy to announce our new whitepaper for Rocket Pool 2.0a decentralised staking infrastructure service for Ethereum 2.0. This article will serve as an introductory guide to several of the main and significant changes from the original Rocket Pool 1.0 design, which was compatible with the recently deprecated Casper 0.2.0 smart contract.",
                    date: "18th October, 2018"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-beta-v1-postmortem-1809391d91b9",
                    title: "Rocket Pool Beta v1 Recap",
                    summary: "Its been two busy months since launch, and the Rocket Pool Beta has finally come to a close, after running at capacity for almost its entire lifespan! It has been incredibly exciting putting our work out into the world, and watching the Rocket Pool community engage with the beta and put it though its paces. A huge thank you to everyone who participated and provided us with a tonne of valuable feedback!",
                    date: "19th September, 2018"
                }, {
                    url: "https://medium.com/rocket-pool/ethereum-2-0-whos-building-it-54a735442e",
                    title: "Ethereum 2.0 - Whos Building It?",
                    summary: "Ethereums roadmap is ambitious. In our last article, we described the Ethereum 2.0 vision...",
                    date: "7th September, 2018"
                }, {
                    url: "https://medium.com/rocket-pool/ethereum-2-0-76d0c8a76605",
                    title: "Ethereum 2.0",
                    summary: "Ethereums rise over the last three years has been extraordinary. A whole new industry of software developers, innovators, and entrepreneurs are building products on Ethereum...",
                    date: "8th August, 2018"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-beta-v1-guide-bed1d99bd84",
                    title: "Rocket Pool Beta v1 Guide",
                    summary: "Welcome one and all to the very first Rocket Pool beta! This guide will walk you through how to set your computer up to interact with the beta when it launches on the 19th of July, see the state of the Rocket Pool network, make a deposit into it, track the state of that deposit, and finally, withdraw your ether plus rewards earned back into your account.",
                    date: "18th July, 2018"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-v1-beta-launch-19th-july-7c71ee758036",
                    title: "Rocket Pool v1 Beta Launch  19th July",
                    summary: "Were proud to announce that the Rocket Pool v1 Beta will be starting in a few weeks, on the 19th July, 2018 UTC. The beta site will be running from https://beta.rocketpool.net, be fully open to the public and will run for a month at the least. The current Rocket Pool website has also been given a face lift with our new modern look, please check it out if your havent had the chance or just want to learn a bit more about what were on about.",
                    date: "6th July, 2018"
                }, {
                    url: "https://medium.com/rocket-pool/development-update-12th-june-2018-c35b40172c7a",
                    title: "Development Update  12th June, 2018",
                    summary: "Welcome to another exciting Rocket Pool dev update! Did someone say new modern re-brand, full 0.2.0 Casper integration and a public beta release where you can actually use Casper for the first time? Well someone has now.",
                    date: "12th June, 2018"
                }, {
                    url: "https://techcrunch.com/2018/05/12/consensys-ventures-invests-in-five-companies-and-launches-its-accelerator/",
                    title: "ConsenSys Backs Rocket Pool",
                    summary: "ConsenSys Ventures, the venture arm of the ConsenSys Ethereum blockchain powerhouse, has invested in Rocket Pool as it seeks to form a relationship with the first announced Casper staking pool. ConsenSys has elaborated on the thinking behind these investments: Its very important for us to invest into companies that both embody the ethos of decentralization while also pushing the Ethereum ecosystem forward.",
                    date: "12th May, 2018"
                }, {
                    url: "https://medium.com/rocket-pool/development-update-11th-may-2018-92bfa66c0da9",
                    title: "Development Update  11th May, 2018",
                    summary: "This update comes to you hot on the heels of Edcon where there was much talk about Caspers Proof of Stake, Pools and a surprise talk by Vitalik on how to be a validator for Casper. Of course Rocket Pool was attending and made an abundance of new potential relationships which we hope to leverage in the future; more info on that to come.",
                    date: "11th May, 2018"
                }, {
                    url: "https://medium.com/rocket-pool/development-update-29th-march-2018-569ba881c12e",
                    title: "Development Update  29th March, 2018",
                    summary: "Its been over a month since our last, but for very good reason, weve been extremely busy! 2018 began with the launch of the Casper testnet, a much welcomed event that saw the next generation of Ethereums new Proof of Stake consensus protocol rolled out for testing. While the testnet has had its share of networking problems due to the issues with Pythereum (an internal client used primarily for R&D testing by the Ethereum Foundation), we have nontheless been busy preparing Rocket Pool for its future beta release.",
                    date: "29th March, 2018"
                }, {
                    url: "https://medium.com/ddcfund/rocket-pool-rpl-the-leading-decentralized-staking-pool-for-ethereum-8101cbea9c5d",
                    title: "Rocket Pool analysis by the Divergence Digital Currency Fund",
                    summary: "A very in depth, balanced and comprehensive analysis was done on Rocket Pool by the Divergence Digital Currency Fund (DDC), a hedge fund co-managed by Yida Gao and Adam Struck. The fund invests in cryptoassets and associated early-stage projects leveraging distributed technology.",
                    date: "18th March, 2018"
                }, {
                    title: "We're growing, welcome to Darren and Jake",
                    summary: "Rocket Pool has largely been designed and developed by a dedicated but small team. With Casper coming into its own on the testnet and interest growing around Rocket Pool, our next main goals are to ensure we have the development talent and skills to continue Rocket Pools current trajectory and ensure it becomes synonymous with staking. Today we welcome two new permanent and highly skilled team members to Rocket Pool, Darren Langely and Jake Pospischil. Both have a diverse range of skill sets needed to continue to build Rocket Pool into a true next generation staking pool.",
                    date: "5th March, 2018"
                }, {
                    url: "https://medium.com/rocket-pool/development-update-3rd-feb-2017-c13944f07465",
                    title: "Development Update  3rd Feb, 2018",
                    summary: "After a hectic and successful 2017, it looks like 2018 will be no different. The last few months have been a whirlwind of activity and meetings. Todays development update covers our approach to the smart node liveliness and monitoring + extensive role based permissions added and Casper testnet compatibility.",
                    date: "3rd Feb, 2018"
                }, {
                    title: "Token Crowdsale Success",
                    summary: "In a huge finale, the Rocket Pool RPL token crowdsale finished in spectaculor fashion with the crowdsale contract receiving over 50% more ether than the target required. Due to the proportional distribution and refund model used, this excess ether was refunded to all participants, with everyone receiving some tokens and almost 55% of their contribution back in ether. A huge thank you to all who participated and made the sale such a great success.",
                    date: "29th January, 2018"
                }],
                a = [{
                    title: "Token Crowdsale Extended & Xmas Wishes",
                    summary: "Due to coming quite close to hitting the crowdsale target, we've gauged the communities feedback and decided to extend the deadline to the 7th of Jan, 2018. This is a hard deadline which means if the sale doesn't complete by then, all contributors can claim a full refund of their ether from the contract, there won't be another extension. We'll then look at organising another crowdsale closer to Caspers launch on Testnet when hype is building and more awareness about its impact is known.",
                    date: "24th December, 2017"
                }, {
                    url: "https://www.meetup.com/en-AU/SydEthereum/events/244417514/",
                    title: "ConsenSys picks Rocket Pool to pitch to them in Sydney!",
                    summary: "ConsenSys is launching a $50 million venture capital fund to be managed by social impact expert Kavita Gupta and they have hand picked 4 Australian projects from all over to pitch to them at the Sydney Ethereum Meetup on the 14th November and you guessed it, Rocket Pool got picked! It was Sydney Ethereums biggest meetup ever with over 300 people attending and some major industry players.",
                    date: "16th November, 2017"
                }, {
                    url: "https://medium.com/rocket-pool/rocket-pool-token-crowdsale-600e60434b95",
                    title: "Rocket Pool Public Token Crowdsale",
                    summary: "After the very successful presale in September, Rocket Pool is now aiming to launch its next and final token sale starting on November 25th and running through to December 23rd. This new public crowdsale will feature a new type of token distribution system which will allow anyone to claim some RPL tokens from the sale, regardless of the amount they contribute or the time they contribute. Like the original presale, it's built using our own token distribution platform, the Sale Agent.",
                    date: "30th October, 2017"
                }, {
                    url: "https://medium.com/rocket-pool/development-update-13th-oct-2017-46d8f5691c2f",
                    title: "Development Update  13th Oct, 2017",
                    summary: "With the RPL presale in the rear view mirror, efforts over the last few weeks have been concentrated on working on some core elements of Rocket Pool that will be required for its beta release hopefully on the Kovan testnet in the first quarter of 2018. Some of these core elements are the smart node service scripts and the design / functionality of the Rocket Pool beta UI.",
                    date: "13th October, 2017"
                }, {
                    url: "/files/BrisbaneEthereumRocketPool.pdf",
                    title: "Ethereum Brisbane - Rocket Pool, Anatomy of a Dapp",
                    summary: "Rocket Pool got a special invitation to give a talk on our Dapp + Network to the Brisbane Ethereum Meetup group on the 4th October. Had a great turn out of 60-80 people and spent a good hour going over all Rocket Pools tech, how it was made and what it was made using. Slides from the event are linked above.",
                    date: "10th October, 2017"
                }, {
                    url: "https://etherdelta.com/#RPL-ETH",
                    title: "RPL Token listed at EtherDelta",
                    summary: "Our primary protocol token RPL has been quickly listed at EtherDelta after the initial token presale. EtherDelta is a decentralised exchange for Ethereum tokens.",
                    date: "28th September, 2017"
                }, {
                    url: "https://medium.com/rocket-pool/development-update-21th-sept-2017-56c677b7c53f",
                    title: "Development Update  21st Sept, 2017",
                    summary: "Original development started on Rocket Pool in late 2016 and with Solidity being a new language, it is undergoing constant updates, so part of the work put in over the last few weeks has been updating Rocket Pool in full to run with and utilise the strengths of the latest Solidity 0.4.15...",
                    date: "21st September, 2017"
                }, {
                    url: "https://blog.status.im/ethereum-dapp-creators-issue-12-rocket-pool-6dd137123054",
                    title: "Ethereum DApp Creators // Issue #12 Rocket Pool",
                    summary: "David had the pleasure of being interviewed by Status on Rocket Pool and how he got started in the industry. Great chat with lots of extra info about Rocket Pool, how it intends to take on Casper and bring staking to everyday users.",
                    date: "11th August, 2017"
                }];
            return (c, l) => (fe(), be("div", FT, [m("div", UT, [m("div", HT, [zT, q(J(is), {
                as: "div",
                class: "mt-6 p-6 bg-gray-50",
                defaultOpen: ""
            }, {
                default: Ze(({
                    open: u
                }) => [m("dt", jT, [q(J(ss), {
                    class: "text-left w-full flex justify-between items-start text-gray-400"
                }, {
                    default: Ze(() => [VT, m("span", GT, [q(J(as), {
                        class: Rt([u ? "-rotate-180" : "rotate-0", "h-6 w-6 transform"]),
                        "aria-hidden": "true"
                    }, null, 8, ["class"])])]),
                    _: 2
                }, 1024)]), q(J(os), {
                    as: "dd",
                    class: "mt-2 pr-12 bg-gray-50"
                }, {
                    default: Ze(() => [m("div", WT, [(fe(), be(Ye, null, xt(e, f => m("div", {
                        key: f.title,
                        target: "_blank",
                        rel: "noreferrer"
                    }, [m("p", QT, [m("time", {
                        datetime: f.date
                    }, ue(f.date), 9, JT)]), m("a", {
                        href: f.url,
                        class: "mt-2 block"
                    }, [m("p", ZT, ue(f.title), 1), m("p", YT, ue(f.summary), 1)], 8, KT), m("div", XT, [m("a", {
                        href: f.url,
                        target: "_blank",
                        rel: "noreferrer",
                        class: "inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"
                    }, " Read full story ", 8, qT)])])), 64))])]),
                    _: 1
                })]),
                _: 1
            }), $T, q(J(is), {
                as: "div",
                class: "mt-6 p-6 bg-gray-50"
            }, {
                default: Ze(({
                    open: u
                }) => [m("dt", e9, [q(J(ss), {
                    class: "text-left w-full flex justify-between items-start text-gray-400"
                }, {
                    default: Ze(() => [t9, m("span", n9, [q(J(as), {
                        class: Rt([u ? "-rotate-180" : "rotate-0", "h-6 w-6 transform"]),
                        "aria-hidden": "true"
                    }, null, 8, ["class"])])]),
                    _: 2
                }, 1024)]), q(J(os), {
                    as: "dd",
                    class: "mt-2 pr-12 bg-gray-50"
                }, {
                    default: Ze(() => [m("div", r9, [(fe(), be(Ye, null, xt(n, f => m("div", {
                        key: f.title,
                        target: "_blank",
                        rel: "noreferrer"
                    }, [m("p", i9, [m("time", {
                        datetime: f.date
                    }, ue(f.date), 9, s9)]), m("a", {
                        href: f.url,
                        class: "mt-2 block"
                    }, [m("p", a9, ue(f.title), 1), m("p", l9, ue(f.summary), 1)], 8, o9), m("div", c9, [m("a", {
                        href: f.url,
                        target: "_blank",
                        rel: "noreferrer",
                        class: "inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"
                    }, " Read full story ", 8, u9)])])), 64))])]),
                    _: 1
                })]),
                _: 1
            }), f9, q(J(is), {
                as: "div",
                class: "p-6 bg-gray-50"
            }, {
                default: Ze(({
                    open: u
                }) => [m("dt", d9, [q(J(ss), {
                    class: "text-left w-full flex justify-between items-start text-gray-400"
                }, {
                    default: Ze(() => [h9, m("span", p9, [q(J(as), {
                        class: Rt([u ? "-rotate-180" : "rotate-0", "h-6 w-6 transform"]),
                        "aria-hidden": "true"
                    }, null, 8, ["class"])])]),
                    _: 2
                }, 1024)]), q(J(os), {
                    as: "dd",
                    class: "mt-2 pr-12 bg-gray-50"
                }, {
                    default: Ze(() => [m("div", m9, [(fe(), be(Ye, null, xt(r, f => m("div", {
                        key: f.title,
                        target: "_blank",
                        rel: "noreferrer"
                    }, [m("p", g9, [m("time", {
                        datetime: f.date
                    }, ue(f.date), 9, y9)]), m("a", {
                        href: f.url,
                        class: "mt-2 block"
                    }, [m("p", b9, ue(f.title), 1), m("p", w9, ue(f.summary), 1)], 8, v9), m("div", x9, [m("a", {
                        href: f.url,
                        target: "_blank",
                        class: "inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"
                    }, " Read full story ", 8, A9)])])), 64))])]),
                    _: 1
                })]),
                _: 1
            }), k9, q(J(is), {
                as: "div",
                class: "p-6 bg-gray-50"
            }, {
                default: Ze(({
                    open: u
                }) => [m("dt", _9, [q(J(ss), {
                    class: "text-left w-full flex justify-between items-start text-gray-400"
                }, {
                    default: Ze(() => [E9, m("span", P9, [q(J(as), {
                        class: Rt([u ? "-rotate-180" : "rotate-0", "h-6 w-6 transform"]),
                        "aria-hidden": "true"
                    }, null, 8, ["class"])])]),
                    _: 2
                }, 1024)]), q(J(os), {
                    as: "dd",
                    class: "mt-2 pr-12 bg-gray-50"
                }, {
                    default: Ze(() => [m("div", S9, [(fe(), be(Ye, null, xt(i, f => m("div", {
                        key: f.title,
                        target: "_blank"
                    }, [m("p", N9, [m("time", {
                        datetime: f.date
                    }, ue(f.date), 9, R9)]), m("a", {
                        href: f.url,
                        class: "mt-2 block"
                    }, [m("p", O9, ue(f.title), 1), m("p", T9, ue(f.summary), 1)], 8, C9), m("div", B9, [m("a", {
                        href: f.url,
                        target: "_blank",
                        class: "inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"
                    }, " Read full story ", 8, I9)])])), 64))])]),
                    _: 1
                })]),
                _: 1
            }), D9, q(J(is), {
                as: "div",
                class: "p-6 bg-gray-50"
            }, {
                default: Ze(({
                    open: u
                }) => [m("dt", L9, [q(J(ss), {
                    class: "text-left w-full flex justify-between items-start text-gray-400"
                }, {
                    default: Ze(() => [M9, m("span", F9, [q(J(as), {
                        class: Rt([u ? "-rotate-180" : "rotate-0", "h-6 w-6 transform"]),
                        "aria-hidden": "true"
                    }, null, 8, ["class"])])]),
                    _: 2
                }, 1024)]), q(J(os), {
                    as: "dd",
                    class: "mt-2 pr-12 bg-gray-50"
                }, {
                    default: Ze(() => [m("div", U9, [(fe(), be(Ye, null, xt(s, f => m("div", {
                        key: f.title,
                        target: "_blank"
                    }, [m("p", H9, [m("time", {
                        datetime: f.date
                    }, ue(f.date), 9, z9)]), m("a", {
                        href: f.url,
                        class: "mt-2 block"
                    }, [m("p", V9, ue(f.title), 1), m("p", G9, ue(f.summary), 1)], 8, j9), m("div", W9, [m("a", {
                        href: f.url,
                        target: "_blank",
                        class: "inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"
                    }, " Read full story ", 8, Q9)])])), 64))])]),
                    _: 1
                })]),
                _: 1
            }), J9, q(J(is), {
                as: "div",
                class: "p-6 bg-gray-50"
            }, {
                default: Ze(({
                    open: u
                }) => [m("dt", K9, [q(J(ss), {
                    class: "text-left w-full flex justify-between items-start text-gray-400"
                }, {
                    default: Ze(() => [Z9, m("span", Y9, [q(J(as), {
                        class: Rt([u ? "-rotate-180" : "rotate-0", "h-6 w-6 transform"]),
                        "aria-hidden": "true"
                    }, null, 8, ["class"])])]),
                    _: 2
                }, 1024)]), q(J(os), {
                    as: "dd",
                    class: "mt-2 pr-12 bg-gray-50"
                }, {
                    default: Ze(() => [m("div", X9, [(fe(), be(Ye, null, xt(o, f => m("div", {
                        key: f.title,
                        target: "_blank",
                        rel: "noreferrer"
                    }, [m("p", q9, [m("time", {
                        datetime: f.date
                    }, ue(f.date), 9, $9)]), m("a", {
                        href: f.url,
                        class: "mt-2 block"
                    }, [m("p", t7, ue(f.title), 1), m("p", n7, ue(f.summary), 1)], 8, e7), m("div", r7, [m("a", {
                        href: f.url,
                        target: "_blank",
                        class: "inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"
                    }, " Read full story ", 8, i7)])])), 64))])]),
                    _: 1
                })]),
                _: 1
            }), s7, q(J(is), {
                as: "div",
                class: "p-6 bg-gray-50"
            }, {
                default: Ze(({
                    open: u
                }) => [m("dt", o7, [q(J(ss), {
                    class: "text-left w-full flex justify-between items-start text-gray-400"
                }, {
                    default: Ze(() => [a7, m("span", l7, [q(J(as), {
                        class: Rt([u ? "-rotate-180" : "rotate-0", "h-6 w-6 transform"]),
                        "aria-hidden": "true"
                    }, null, 8, ["class"])])]),
                    _: 2
                }, 1024)]), q(J(os), {
                    as: "dd",
                    class: "mt-2 pr-12 bg-gray-50"
                }, {
                    default: Ze(() => [m("div", c7, [(fe(), be(Ye, null, xt(a, f => m("div", {
                        key: f.title,
                        target: "_blank"
                    }, [m("p", u7, [m("time", {
                        datetime: f.date
                    }, ue(f.date), 9, f7)]), m("a", {
                        href: f.url,
                        class: "mt-2 block"
                    }, [m("p", h7, ue(f.title), 1), m("p", p7, ue(f.summary), 1)], 8, d7), m("div", m7, [m("a", {
                        href: f.url,
                        target: "_blank",
                        class: "inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"
                    }, " Read full story ", 8, g7)])])), 64))])]),
                    _: 1
                })]),
                _: 1
            })])])]))
        }
    }),
    v7 = {
        class: "bg-white pb-20",
        "aria-labelledby": "footer-heading"
    },
    b7 = m("h2", {
        id: "footer-heading",
        class: "sr-only"
    }, "Footer", -1),
    w7 = {
        class: "max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:py-16 lg:px-8"
    },
    x7 = {
        class: "xl:grid xl:grid-cols-3 xl:gap-8"
    },
    A7 = {
        class: "space-y-8 xl:col-span-1"
    },
    k7 = m("img", {
        class: "h-10",
        src: R2,
        alt: "Rocket Pool"
    }, null, -1),
    _7 = m("p", {
        class: "text-gray-500 text-base"
    }, "Decentralised Ethereum Staking Protocol", -1),
    E7 = {
        class: "flex space-x-6"
    },
    P7 = ["href"],
    S7 = {
        class: "sr-only"
    },
    N7 = {
        class: "mt-12 grid grid-cols-2 gap-8 xl:mt-0 xl:col-span-2"
    },
    R7 = {
        class: "md:grid md:grid-cols-2 md:gap-8"
    },
    C7 = m("h3", {
        class: "text-sm font-semibold text-gray-400 tracking-wider uppercase"
    }, "Staking", -1),
    O7 = {
        role: "list",
        class: "mt-4 space-y-4"
    },
    T7 = ["href"],
    B7 = {
        class: "mt-12 md:mt-0"
    },
    I7 = m("h3", {
        class: "text-sm font-semibold text-gray-400 tracking-wider uppercase"
    }, "Node Operation", -1),
    D7 = {
        role: "list",
        class: "mt-4 space-y-4"
    },
    L7 = ["href"],
    M7 = {
        class: "md:grid md:grid-cols-2 md:gap-8"
    },
    F7 = m("h3", {
        class: "text-sm font-semibold text-gray-400 tracking-wider uppercase"
    }, "Learn", -1),
    U7 = {
        role: "list",
        class: "mt-4 space-y-4"
    },
    H7 = ["href"],
    z7 = {
        class: "mt-12 md:mt-0"
    },
    j7 = m("h3", {
        class: "text-sm font-semibold text-gray-400 tracking-wider uppercase"
    }, "Governance", -1),
    V7 = {
        role: "list",
        class: "mt-4 space-y-4"
    },
    G7 = ["href"],
    W7 = {
        class: "mt-12 border-t border-gray-200 pt-8"
    },
    Q7 = {
        class: "text-base text-gray-400 xl:text-center pb-5"
    },
    J7 = ["href"],
    K7 = m("p", {
        class: "text-base text-gray-400 xl:text-center"
    }, [m("span", {
        class: "pr-4"
    }, " Rocket Pool Pty Ltd.")], -1),
    tf = nt({
        __name: "footer",
        setup(t) {
            const e = {
                staking: [{
                    name: "Overview",
                    href: "https://docs.rocketpool.net/guides/staking/overview.html"
                }, {
                    name: "ETH2 Staking",
                    href: "https://docs.rocketpool.net/guides/staking/overview.html#how-eth2-staking-works"
                }, {
                    name: "Rocket Pool Staking",
                    href: "https://docs.rocketpool.net/guides/staking/overview.html#how-rocket-pool-works"
                }, {
                    name: "rEth Token",
                    href: "https://docs.rocketpool.net/guides/staking/overview.html#the-reth-token"
                }],
                nodes: [{
                    name: "How it works",
                    href: "https://docs.rocketpool.net/guides/node/responsibilities.html#how-rocket-pool-nodes-work"
                }, {
                    name: "Local Nodes",
                    href: "https://docs.rocketpool.net/guides/node/local/hardware.html"
                }, {
                    name: "Cloud Nodes",
                    href: "https://docs.rocketpool.net/guides/node/vps/providers.html"
                }, {
                    name: "Install Rocket Pool",
                    href: "https://docs.rocketpool.net/guides/node/eth-clients.html"
                }],
                learn: [{
                    name: "Introduction",
                    href: "https://docs.rocketpool.net/overview/"
                }, {
                    name: "Explainer Series",
                    href: "https://medium.com/rocket-pool/rocket-pool-staking-protocol-part-1-8be4859e5fbd"
                }, {
                    name: "Guides",
                    href: "https://docs.rocketpool.net/guides/"
                }, {
                    name: "Developers",
                    href: "https://docs.rocketpool.net/developers/"
                }],
                governance: [{
                    name: "Forum",
                    href: "https://dao.rocketpool.net/"
                }, {
                    name: "Proposals",
                    href: "https://vote.rocketpool.net/"
                }, {
                    name: "Delegates",
                    href: "https://delegates.rocketpool.net/"
                }],
                legal: [{
                    name: "Privacy Policy",
                    href: "/files/privacy-policy.pdf"
                }, {
                    name: "Terms of Service",
                    href: "/files/terms-of-service.pdf"
                }],
                social: [{
                    name: "Discord",
                    href: "https://discord.gg/rocketpool",
                    icon: ["fab", "discord"]
                }, {
                    name: "Medium",
                    href: "https://medium.com/rocket-pool",
                    icon: ["fab", "medium"]
                }, {
                    name: "Twitter",
                    href: "https://twitter.com/Rocket_Pool",
                    icon: ["fab", "x-twitter"]
                }, {
                    name: "GitHub",
                    href: "https://github.com/rocket-pool",
                    icon: ["fab", "github"]
                }, {
                    name: "Forum",
                    href: "https://dao.rocketpool.net",
                    icon: ["fab", "discourse"]
                }, {
                    name: "Youtube",
                    href: "https://youtube.com/rocketpool",
                    icon: ["fab", "youtube"]
                }, {
                    name: "Reddit",
                    href: "https://www.reddit.com/r/rocketpool",
                    icon: ["fab", "reddit"]
                }]
            };
            return (n, r) => {
                const i = Lr("fa");
                return fe(), be("footer", v7, [b7, m("div", w7, [m("div", x7, [m("div", A7, [k7, _7, m("div", E7, [(fe(!0), be(Ye, null, xt(e.social, s => (fe(), be("a", {
                    key: s.name,
                    href: s.href,
                    class: "text-gray-400 hover:text-gray-500",
                    target: "_blank",
                    rel: "noreferrer"
                }, [m("span", S7, ue(s.name), 1), q(i, {
                    icon: s.icon,
                    class: "h-6 w-6",
                    "aria-hidden": "true"
                }, null, 8, ["icon"])], 8, P7))), 128))])]), m("div", N7, [m("div", R7, [m("div", null, [C7, m("ul", O7, [(fe(!0), be(Ye, null, xt(e.staking, s => (fe(), be("li", {
                    key: s.name
                }, [m("a", {
                    href: s.href,
                    class: "text-base text-gray-500 hover:text-gray-900",
                    target: "_blank",
                    rel: "noreferrer"
                }, ue(s.name), 9, T7)]))), 128))])]), m("div", B7, [I7, m("ul", D7, [(fe(!0), be(Ye, null, xt(e.nodes, s => (fe(), be("li", {
                    key: s.name
                }, [m("a", {
                    href: s.href,
                    class: "text-base text-gray-500 hover:text-gray-900",
                    target: "_blank",
                    rel: "noreferrer"
                }, ue(s.name), 9, L7)]))), 128))])])]), m("div", M7, [m("div", null, [F7, m("ul", U7, [(fe(!0), be(Ye, null, xt(e.learn, s => (fe(), be("li", {
                    key: s.name
                }, [m("a", {
                    href: s.href,
                    class: "text-base text-gray-500 hover:text-gray-900",
                    target: "_blank",
                    rel: "noreferrer"
                }, ue(s.name), 9, H7)]))), 128))])]), m("div", z7, [j7, m("ul", V7, [(fe(!0), be(Ye, null, xt(e.governance, s => (fe(), be("li", {
                    key: s.name
                }, [m("a", {
                    href: s.href,
                    class: "text-base text-gray-500 hover:text-gray-900",
                    target: "_blank",
                    rel: "noreferrer"
                }, ue(s.name), 9, G7)]))), 128))])])])])]), m("div", W7, [m("p", Q7, [(fe(!0), be(Ye, null, xt(e.legal, s => (fe(), be("span", {
                    key: s.name,
                    class: "pr-4"
                }, [m("a", {
                    href: s.href,
                    class: "text-base xl:text-center text-gray-400 hover:text-gray-900",
                    target: "_blank",
                    rel: "noreferrer"
                }, ue(s.name), 9, J7)]))), 128))]), K7])])])
            }
        }
    }),
    Z7 = {
        key: 0
    },
    Y7 = {
        class: "fixed inset-x-0 bottom-0 z-50"
    },
    X7 = {
        class: "bg-gray-800"
    },
    q7 = {
        class: "max-w-7xl mx-auto py-3 px-3 sm:px-6 lg:px-8"
    },
    $7 = {
        class: "flex items-center justify-between flex-wrap"
    },
    eB = Ko('<div class="w-0 flex-1 flex items-center"><span class="flex p-2"><img src="' + N2 + '"></span><p class="ml-3 text-sm sm:text-base font-medium text-white"><span class="md:hidden">Join our Immunefi bug bounty!</span><span class="hidden md:inline"> Are you a security researcher? In line with our commitment to security, we have partnered with Immunifi and have launched an official bug bounty program. Join today! </span></p></div><div class="order-3 mt-2 flex-shrink-0 w-full sm:order-2 sm:mt-0 sm:w-auto"><a href="https://immunefi.com/bounty/rocketpool/" target="_blank" rel="noreferrer" class="flex items-center justify-center px-4 py-2 rounded-md text-sm font-semibold text-white rp-button"> Learn more </a></div>', 2),
    tB = {
        class: "order-2 flex-shrink-0 sm:order-3 sm:ml-3"
    },
    nB = m("span", {
        class: "sr-only"
    }, "Dismiss", -1),
    rB = nt({
        __name: "bug-bounty",
        setup(t) {
            const e = we("bugBounty");

            function n() {
                e.value = !0
            }
            return (r, i) => J(e) ? Ea("", !0) : (fe(), be("div", Z7, [m("div", Y7, [m("div", X7, [m("div", q7, [m("div", $7, [eB, m("div", tB, [m("button", {
                type: "button",
                class: "-mr-1 flex p-2 rounded-md hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-white sm:-mr-2",
                onClickOnce: n
            }, [nB, q(J(MT), {
                class: "h-6 w-6 text-white",
                "aria-hidden": "true"
            })], 32)])])])])])]))
        }
    }),
    iB = {
        id: "home"
    },
    sB = {
        href: "#header",
        class: "hidden",
        id: "#header"
    },
    oB = {
        href: "#stake-run-node",
        class: "hidden",
        id: "#stake-run-node"
    },
    aB = {
        href: "#security",
        class: "hidden",
        id: "#security"
    },
    lB = {
        href: "#how-it-works",
        class: "hidden",
        id: "#how-it-works"
    },
    cB = {
        href: "#community",
        class: "hidden",
        id: "#community"
    },
    uB = {
        href: "#news",
        class: "hidden",
        id: "#news"
    },
    fB = {
        href: "#team",
        class: "hidden",
        id: "#team"
    },
    dB = {
        href: "#dao",
        class: "hidden",
        id: "#dao"
    },
    hB = {
        href: "#node-operator-interest",
        class: "hidden",
        id: "#node-operator-interest"
    },
    pB = {
        href: "#footer",
        class: "hidden",
        id: "#footer"
    },
    mB = nt({
        __name: "home",
        setup(t) {
            const e = we("emitter"),
                n = Z(!1),
                r = Z(null),
                i = Z(!1);
            Xe(i, () => {
                i.value && e.emit("load-tweets")
            }), V4(r, ([{
                isIntersecting: g
            }], b) => {
                i.value = g
            });

            function s([{
                isIntersecting: g
            }]) {
                g && n.value && e.emit("update-hash-header")
            }

            function o([{
                isIntersecting: g
            }]) {
                g && n.value && e.emit("update-hash-stake-run-node")
            }

            function a([{
                isIntersecting: g
            }]) {
                g && (n.value = !0, e.emit("update-hash-security"))
            }

            function c([{
                isIntersecting: g
            }]) {
                g && e.emit("update-hash-how-it-works")
            }

            function l([{
                isIntersecting: g
            }]) {
                g && e.emit("update-hash-community")
            }

            function u([{
                isIntersecting: g
            }]) {
                g && e.emit("update-hash-news")
            }

            function f([{
                isIntersecting: g
            }]) {
                g && e.emit("update-hash-team")
            }

            function d([{
                isIntersecting: g
            }]) {
                g && e.emit("update-hash-dao")
            }

            function h([{
                isIntersecting: g
            }]) {
                g && e.emit("update-hash-node-operator-interest")
            }

            function p([{
                isIntersecting: g
            }]) {
                g && e.emit("update-hash-footer")
            }
            return (g, b) => {
                const x = qk("smooth-scroll");
                return fe(), be("div", iB, [Bt((fe(), be("a", sB, [Ke("Header")])), [
                    [x]
                ]), Bt((fe(), be("a", oB, [Ke("stake-run-node")])), [
                    [x]
                ]), Bt((fe(), be("a", aB, [Ke("Security")])), [
                    [x]
                ]), Bt((fe(), be("a", lB, [Ke("How it works")])), [
                    [x]
                ]), Bt((fe(), be("a", cB, [Ke("Community")])), [
                    [x]
                ]), Bt((fe(), be("a", uB, [Ke("News")])), [
                    [x]
                ]), Bt((fe(), be("a", fB, [Ke("Team")])), [
                    [x]
                ]), Bt((fe(), be("a", dB, [Ke("Dao")])), [
                    [x]
                ]), Bt((fe(), be("a", hB, [Ke("Node Operator Interest")])), [
                    [x]
                ]), Bt((fe(), be("a", pB, [Ke("Footer")])), [
                    [x]
                ]), Bt(q(XR, {
                    id: "header"
                }, null, 512), [
                    [J(yr), s]
                ]), Bt(q(HC, {
                    id: "stake-run-node"
                }, null, 512), [
                    [J(yr), o]
                ]), Bt(q(tO, {
                    id: "security"
                }, null, 512), [
                    [J(yr), a]
                ]), Bt(q(fO, {
                    id: "how-it-works"
                }, null, 512), [
                    [J(yr), c]
                ]), Bt(q(Wp, {
                    id: "community"
                }, null, 512), [
                    [J(yr), l]
                ]), Bt(q(y7, {
                    id: "news"
                }, null, 512), [
                    [J(yr), u]
                ]), Bt(q(bT, {
                    id: "team",
                    ref_key: "twitterPreloadTrigger",
                    ref: r
                }, null, 512), [
                    [J(yr), f]
                ]), Bt(q(ZO, {
                    id: "dao"
                }, null, 512), [
                    [J(yr), d]
                ]), Bt(q(QC, {
                    id: "node-operator-interest"
                }, null, 512), [
                    [J(yr), h]
                ]), Bt(q(tf, {
                    id: "footer"
                }, null, 512), [
                    [J(yr), p]
                ]), q(rB)])
            }
        }
    }),
    gB = {},
    yB = {
        class: "bg-gradient-to-r from-rporange-bg to-rppink-bg"
    },
    vB = Ko('<div class="bg-header relative overflow-hidden smaller"><div class="bg-fx"></div><div class="bg-clouds-top"></div><div class="relative overflow-hidden"><div class="relative pt-6 pb-16 sm:pb-24"><main class="mt-16 mx-auto max-w-7xl px-4 sm:mt-24"><div class="flex justify-center"><a href="/"><img src="' + k2 + '" class="md:max-w-3xl"></a></div></main></div></div></div>', 1),
    bB = [vB];

function wB(t, e) {
    return fe(), be("div", yB, bB)
}
const Zp = ef(gB, [
        ["render", wB]
    ]),
    xB = {
        class: "py-20 bg-white"
    },
    AB = {
        class: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"
    },
    kB = m("div", {
        class: "lg:text-center"
    }, [m("h2", {
        class: "py-2 text-center text-3xl font-extrabold tracking-tight sm:text-5xl bg-gradient-to-r from-red-500 via-yellow-400 to-red-400 bg-clip-text text-transparent leading-8"
    }, " Why become a Rocket Pool node operator? "), m("p", {
        class: "mt-6 max-w-7xl text-xl text-gray-600 mx-auto font-semibold text-center"
    }, "Rocket Pool is the easiest way to participate in Ethereum proof-of-stake.")], -1),
    _B = {
        class: "bg-gray-100 p-6 mt-6 rounded-lg"
    },
    EB = {
        class: "space-y-10 lg:space-y-0 lg:grid lg:grid-cols-3 lg:gap-8"
    },
    PB = {
        class: "flex justify-center"
    },
    SB = {
        class: "flex items-center justify-center h-20 w-20 rounded-full bg-gradient-to-b from-red-500 to-yellow-400 text-white"
    },
    NB = {
        class: "mt-5 text-lg leading-6 font-semibold text-gray-900 text-center"
    },
    RB = {
        class: "mt-2 text-base text-gray-500 text-center px-2"
    },
    CB = nt({
        __name: "why",
        setup(t) {
            const e = [{
                name: "Permissionless",
                description: "Anyone can join the Rocket Pool as a node operator and help secure the Ethereum protocol!",
                icon: ["fas", "network-wired"]
            }, {
                name: "Less than 32 ETH",
                description: "Participate in Ethereum proof-of-stake from the minimum of 10.4 ETH (8 ETH + 2.4 ETH of RPL as collateral).",
                icon: ["fab", "ethereum"]
            }, {
                name: "Earn commission & rewards",
                description: "Earn commission from staking ETH in the deposit pool and RPL rewards from providing RPL collateral.",
                icon: ["fas", "dollar-sign"]
            }];
            return (n, r) => {
                const i = Lr("fa");
                return fe(), be("div", xB, [m("div", AB, [kB, m("div", _B, [m("dl", EB, [(fe(), be(Ye, null, xt(e, s => m("div", {
                    key: s.name
                }, [m("dt", null, [m("div", PB, [m("div", SB, [q(i, {
                    icon: s.icon,
                    class: "h-10 w-10",
                    size: "3x",
                    "aria-hidden": "true"
                }, null, 8, ["icon"])])]), m("p", NB, ue(s.name), 1)]), m("dd", RB, ue(s.description), 1)])), 64))])])])])
            }
        }
    });

function Eh(t, e, n) {
    var r, i, s, o, a;
    e == null && (e = 100);

    function c() {
        var u = Date.now() - o;
        u < e && u >= 0 ? r = setTimeout(c, e - u) : (r = null, n || (a = t.apply(s, i), s = i = null))
    }
    var l = function() {
        s = this, i = arguments, o = Date.now();
        var u = n && !r;
        return r || (r = setTimeout(c, e)), u && (a = t.apply(s, i), s = i = null), a
    };
    return l.clear = function() {
        r && (clearTimeout(r), r = null)
    }, l.flush = function() {
        r && (a = t.apply(s, i), s = i = null, clearTimeout(r), r = null)
    }, l
}
Eh.debounce = Eh;
var vd = Eh;

function OB(t, e, n) {
    pt(t) ? Xe(t, (r, i) => {
        i ? .removeEventListener(e, n), r ? .addEventListener(e, n)
    }) : sn(() => {
        t.addEventListener(e, n)
    }), vl(() => {
        var r;
        (r = J(t)) === null || r === void 0 || r.removeEventListener(e, n)
    })
}

function TB(t, e) {
    const n = "pointerdown";
    return typeof window > "u" || !window ? void 0 : OB(window, n, i => {
        const s = J(t);
        s && (s === i.target || i.composedPath().includes(s) || e(i))
    })
}

function BB(t, e, n) {
    let r = null;
    const i = Z(!1);
    sn(() => {
        (t.content !== void 0 || n.value) && (i.value = !0), r = new MutationObserver(s), r.observe(e.value, {
            childList: !0,
            subtree: !0
        })
    }), vl(() => r.disconnect()), Xe(n, o => {
        o ? i.value = !0 : i.value = !1
    });
    const s = () => {
        t.content ? i.value = !0 : i.value = !1
    };
    return {
        hasContent: i
    }
}

function zo(t, e) {
    var n = t.getBoundingClientRect(),
        r = 1,
        i = 1;
    return {
        width: n.width / r,
        height: n.height / i,
        top: n.top / i,
        right: n.right / r,
        bottom: n.bottom / i,
        left: n.left / r,
        x: n.left / r,
        y: n.top / i
    }
}

function hr(t) {
    if (t == null) return window;
    if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument;
        return e && e.defaultView || window
    }
    return t
}

function Yp(t) {
    var e = hr(t),
        n = e.pageXOffset,
        r = e.pageYOffset;
    return {
        scrollLeft: n,
        scrollTop: r
    }
}

function ol(t) {
    var e = hr(t).Element;
    return t instanceof e || t instanceof Element
}

function Jn(t) {
    var e = hr(t).HTMLElement;
    return t instanceof e || t instanceof HTMLElement
}

function G2(t) {
    if (typeof ShadowRoot > "u") return !1;
    var e = hr(t).ShadowRoot;
    return t instanceof e || t instanceof ShadowRoot
}

function IB(t) {
    return {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    }
}

function DB(t) {
    return t === hr(t) || !Jn(t) ? Yp(t) : IB(t)
}

function Dr(t) {
    return t ? (t.nodeName || "").toLowerCase() : null
}

function Ki(t) {
    return ((ol(t) ? t.ownerDocument : t.document) || window.document).documentElement
}

function Xp(t) {
    return zo(Ki(t)).left + Yp(t).scrollLeft
}

function oi(t) {
    return hr(t).getComputedStyle(t)
}

function qp(t) {
    var e = oi(t),
        n = e.overflow,
        r = e.overflowX,
        i = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + i + r)
}

function LB(t) {
    var e = t.getBoundingClientRect(),
        n = e.width / t.offsetWidth || 1,
        r = e.height / t.offsetHeight || 1;
    return n !== 1 || r !== 1
}

function MB(t, e, n) {
    n === void 0 && (n = !1);
    var r = Jn(e);
    Jn(e) && LB(e);
    var i = Ki(e),
        s = zo(t),
        o = {
            scrollLeft: 0,
            scrollTop: 0
        },
        a = {
            x: 0,
            y: 0
        };
    return (r || !r && !n) && ((Dr(e) !== "body" || qp(i)) && (o = DB(e)), Jn(e) ? (a = zo(e), a.x += e.clientLeft, a.y += e.clientTop) : i && (a.x = Xp(i))), {
        x: s.left + o.scrollLeft - a.x,
        y: s.top + o.scrollTop - a.y,
        width: s.width,
        height: s.height
    }
}

function $p(t) {
    var e = zo(t),
        n = t.offsetWidth,
        r = t.offsetHeight;
    return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
        x: t.offsetLeft,
        y: t.offsetTop,
        width: n,
        height: r
    }
}

function nf(t) {
    return Dr(t) === "html" ? t : t.assignedSlot || t.parentNode || (G2(t) ? t.host : null) || Ki(t)
}

function W2(t) {
    return ["html", "body", "#document"].indexOf(Dr(t)) >= 0 ? t.ownerDocument.body : Jn(t) && qp(t) ? t : W2(nf(t))
}

function Ia(t, e) {
    var n;
    e === void 0 && (e = []);
    var r = W2(t),
        i = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
        s = hr(r),
        o = i ? [s].concat(s.visualViewport || [], qp(r) ? r : []) : r,
        a = e.concat(o);
    return i ? a : a.concat(Ia(nf(o)))
}

function FB(t) {
    return ["table", "td", "th"].indexOf(Dr(t)) >= 0
}

function J1(t) {
    return !Jn(t) || oi(t).position === "fixed" ? null : t.offsetParent
}

function UB(t) {
    var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1,
        n = navigator.userAgent.indexOf("Trident") !== -1;
    if (n && Jn(t)) {
        var r = oi(t);
        if (r.position === "fixed") return null
    }
    for (var i = nf(t); Jn(i) && ["html", "body"].indexOf(Dr(i)) < 0;) {
        var s = oi(i);
        if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none") return i;
        i = i.parentNode
    }
    return null
}

function Cl(t) {
    for (var e = hr(t), n = J1(t); n && FB(n) && oi(n).position === "static";) n = J1(n);
    return n && (Dr(n) === "html" || Dr(n) === "body" && oi(n).position === "static") ? e : n || UB(t) || e
}
var Kn = "top",
    ur = "bottom",
    fr = "right",
    Zn = "left",
    em = "auto",
    Ol = [Kn, ur, fr, Zn],
    jo = "start",
    al = "end",
    HB = "clippingParents",
    Q2 = "viewport",
    fa = "popper",
    zB = "reference",
    K1 = Ol.reduce(function(t, e) {
        return t.concat([e + "-" + jo, e + "-" + al])
    }, []),
    J2 = [].concat(Ol, [em]).reduce(function(t, e) {
        return t.concat([e, e + "-" + jo, e + "-" + al])
    }, []),
    jB = "beforeRead",
    VB = "read",
    GB = "afterRead",
    WB = "beforeMain",
    QB = "main",
    JB = "afterMain",
    KB = "beforeWrite",
    ZB = "write",
    YB = "afterWrite",
    XB = [jB, VB, GB, WB, QB, JB, KB, ZB, YB];

function qB(t) {
    var e = new Map,
        n = new Set,
        r = [];
    t.forEach(function(s) {
        e.set(s.name, s)
    });

    function i(s) {
        n.add(s.name);
        var o = [].concat(s.requires || [], s.requiresIfExists || []);
        o.forEach(function(a) {
            if (!n.has(a)) {
                var c = e.get(a);
                c && i(c)
            }
        }), r.push(s)
    }
    return t.forEach(function(s) {
        n.has(s.name) || i(s)
    }), r
}

function $B(t) {
    var e = qB(t);
    return XB.reduce(function(n, r) {
        return n.concat(e.filter(function(i) {
            return i.phase === r
        }))
    }, [])
}

function eI(t) {
    var e;
    return function() {
        return e || (e = new Promise(function(n) {
            Promise.resolve().then(function() {
                e = void 0, n(t())
            })
        })), e
    }
}

function Tr(t) {
    return t.split("-")[0]
}

function tI(t) {
    var e = t.reduce(function(n, r) {
        var i = n[r.name];
        return n[r.name] = i ? Object.assign({}, i, r, {
            options: Object.assign({}, i.options, r.options),
            data: Object.assign({}, i.data, r.data)
        }) : r, n
    }, {});
    return Object.keys(e).map(function(n) {
        return e[n]
    })
}

function nI(t) {
    var e = hr(t),
        n = Ki(t),
        r = e.visualViewport,
        i = n.clientWidth,
        s = n.clientHeight,
        o = 0,
        a = 0;
    return r && (i = r.width, s = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = r.offsetLeft, a = r.offsetTop)), {
        width: i,
        height: s,
        x: o + Xp(t),
        y: a
    }
}
var zi = Math.max,
    ll = Math.min,
    vc = Math.round;

function rI(t) {
    var e, n = Ki(t),
        r = Yp(t),
        i = (e = t.ownerDocument) == null ? void 0 : e.body,
        s = zi(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0),
        o = zi(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0),
        a = -r.scrollLeft + Xp(t),
        c = -r.scrollTop;
    return oi(i || n).direction === "rtl" && (a += zi(n.clientWidth, i ? i.clientWidth : 0) - s), {
        width: s,
        height: o,
        x: a,
        y: c
    }
}

function K2(t, e) {
    var n = e.getRootNode && e.getRootNode();
    if (t.contains(e)) return !0;
    if (n && G2(n)) {
        var r = e;
        do {
            if (r && t.isSameNode(r)) return !0;
            r = r.parentNode || r.host
        } while (r)
    }
    return !1
}

function Ph(t) {
    return Object.assign({}, t, {
        left: t.x,
        top: t.y,
        right: t.x + t.width,
        bottom: t.y + t.height
    })
}

function iI(t) {
    var e = zo(t);
    return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e
}

function Z1(t, e) {
    return e === Q2 ? Ph(nI(t)) : Jn(e) ? iI(e) : Ph(rI(Ki(t)))
}

function sI(t) {
    var e = Ia(nf(t)),
        n = ["absolute", "fixed"].indexOf(oi(t).position) >= 0,
        r = n && Jn(t) ? Cl(t) : t;
    return ol(r) ? e.filter(function(i) {
        return ol(i) && K2(i, r) && Dr(i) !== "body"
    }) : []
}

function oI(t, e, n) {
    var r = e === "clippingParents" ? sI(t) : [].concat(e),
        i = [].concat(r, [n]),
        s = i[0],
        o = i.reduce(function(a, c) {
            var l = Z1(t, c);
            return a.top = zi(l.top, a.top), a.right = ll(l.right, a.right), a.bottom = ll(l.bottom, a.bottom), a.left = zi(l.left, a.left), a
        }, Z1(t, s));
    return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o
}

function Vo(t) {
    return t.split("-")[1]
}

function tm(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
}

function Z2(t) {
    var e = t.reference,
        n = t.element,
        r = t.placement,
        i = r ? Tr(r) : null,
        s = r ? Vo(r) : null,
        o = e.x + e.width / 2 - n.width / 2,
        a = e.y + e.height / 2 - n.height / 2,
        c;
    switch (i) {
        case Kn:
            c = {
                x: o,
                y: e.y - n.height
            };
            break;
        case ur:
            c = {
                x: o,
                y: e.y + e.height
            };
            break;
        case fr:
            c = {
                x: e.x + e.width,
                y: a
            };
            break;
        case Zn:
            c = {
                x: e.x - n.width,
                y: a
            };
            break;
        default:
            c = {
                x: e.x,
                y: e.y
            }
    }
    var l = i ? tm(i) : null;
    if (l != null) {
        var u = l === "y" ? "height" : "width";
        switch (s) {
            case jo:
                c[l] = c[l] - (e[u] / 2 - n[u] / 2);
                break;
            case al:
                c[l] = c[l] + (e[u] / 2 - n[u] / 2);
                break
        }
    }
    return c
}

function Y2() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}

function X2(t) {
    return Object.assign({}, Y2(), t)
}

function q2(t, e) {
    return e.reduce(function(n, r) {
        return n[r] = t, n
    }, {})
}

function nm(t, e) {
    e === void 0 && (e = {});
    var n = e,
        r = n.placement,
        i = r === void 0 ? t.placement : r,
        s = n.boundary,
        o = s === void 0 ? HB : s,
        a = n.rootBoundary,
        c = a === void 0 ? Q2 : a,
        l = n.elementContext,
        u = l === void 0 ? fa : l,
        f = n.altBoundary,
        d = f === void 0 ? !1 : f,
        h = n.padding,
        p = h === void 0 ? 0 : h,
        g = X2(typeof p != "number" ? p : q2(p, Ol)),
        b = u === fa ? zB : fa,
        x = t.rects.popper,
        w = t.elements[d ? b : u],
        O = oI(ol(w) ? w : w.contextElement || Ki(t.elements.popper), o, c),
        N = zo(t.elements.reference),
        U = Z2({
            reference: N,
            element: x,
            strategy: "absolute",
            placement: i
        }),
        H = Ph(Object.assign({}, x, U)),
        M = u === fa ? H : N,
        y = {
            top: O.top - M.top + g.top,
            bottom: M.bottom - O.bottom + g.bottom,
            left: O.left - M.left + g.left,
            right: M.right - O.right + g.right
        },
        v = t.modifiersData.offset;
    if (u === fa && v) {
        var A = v[i];
        Object.keys(y).forEach(function(E) {
            var P = [fr, ur].indexOf(E) >= 0 ? 1 : -1,
                R = [Kn, ur].indexOf(E) >= 0 ? "y" : "x";
            y[E] += A[R] * P
        })
    }
    return y
}
var Y1 = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};

function X1() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    return !e.some(function(r) {
        return !(r && typeof r.getBoundingClientRect == "function")
    })
}

function aI(t) {
    t === void 0 && (t = {});
    var e = t,
        n = e.defaultModifiers,
        r = n === void 0 ? [] : n,
        i = e.defaultOptions,
        s = i === void 0 ? Y1 : i;
    return function(a, c, l) {
        l === void 0 && (l = s);
        var u = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, Y1, s),
                modifiersData: {},
                elements: {
                    reference: a,
                    popper: c
                },
                attributes: {},
                styles: {}
            },
            f = [],
            d = !1,
            h = {
                state: u,
                setOptions: function(x) {
                    var w = typeof x == "function" ? x(u.options) : x;
                    g(), u.options = Object.assign({}, s, u.options, w), u.scrollParents = {
                        reference: ol(a) ? Ia(a) : a.contextElement ? Ia(a.contextElement) : [],
                        popper: Ia(c)
                    };
                    var O = $B(tI([].concat(r, u.options.modifiers)));
                    return u.orderedModifiers = O.filter(function(N) {
                        return N.enabled
                    }), p(), h.update()
                },
                forceUpdate: function() {
                    if (!d) {
                        var x = u.elements,
                            w = x.reference,
                            O = x.popper;
                        if (X1(w, O)) {
                            u.rects = {
                                reference: MB(w, Cl(O), u.options.strategy === "fixed"),
                                popper: $p(O)
                            }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(A) {
                                return u.modifiersData[A.name] = Object.assign({}, A.data)
                            });
                            for (var N = 0; N < u.orderedModifiers.length; N++) {
                                if (u.reset === !0) {
                                    u.reset = !1, N = -1;
                                    continue
                                }
                                var U = u.orderedModifiers[N],
                                    H = U.fn,
                                    M = U.options,
                                    y = M === void 0 ? {} : M,
                                    v = U.name;
                                typeof H == "function" && (u = H({
                                    state: u,
                                    options: y,
                                    name: v,
                                    instance: h
                                }) || u)
                            }
                        }
                    }
                },
                update: eI(function() {
                    return new Promise(function(b) {
                        h.forceUpdate(), b(u)
                    })
                }),
                destroy: function() {
                    g(), d = !0
                }
            };
        if (!X1(a, c)) return h;
        h.setOptions(l).then(function(b) {
            !d && l.onFirstUpdate && l.onFirstUpdate(b)
        });

        function p() {
            u.orderedModifiers.forEach(function(b) {
                var x = b.name,
                    w = b.options,
                    O = w === void 0 ? {} : w,
                    N = b.effect;
                if (typeof N == "function") {
                    var U = N({
                            state: u,
                            name: x,
                            instance: h,
                            options: O
                        }),
                        H = function() {};
                    f.push(U || H)
                }
            })
        }

        function g() {
            f.forEach(function(b) {
                return b()
            }), f = []
        }
        return h
    }
}
var bc = {
    passive: !0
};

function lI(t) {
    var e = t.state,
        n = t.instance,
        r = t.options,
        i = r.scroll,
        s = i === void 0 ? !0 : i,
        o = r.resize,
        a = o === void 0 ? !0 : o,
        c = hr(e.elements.popper),
        l = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return s && l.forEach(function(u) {
            u.addEventListener("scroll", n.update, bc)
        }), a && c.addEventListener("resize", n.update, bc),
        function() {
            s && l.forEach(function(u) {
                u.removeEventListener("scroll", n.update, bc)
            }), a && c.removeEventListener("resize", n.update, bc)
        }
}
var cI = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function() {},
    effect: lI,
    data: {}
};

function uI(t) {
    var e = t.state,
        n = t.name;
    e.modifiersData[n] = Z2({
        reference: e.rects.reference,
        element: e.rects.popper,
        strategy: "absolute",
        placement: e.placement
    })
}
var fI = {
        name: "popperOffsets",
        enabled: !0,
        phase: "read",
        fn: uI,
        data: {}
    },
    dI = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
    };

function hI(t) {
    var e = t.x,
        n = t.y,
        r = window,
        i = r.devicePixelRatio || 1;
    return {
        x: vc(vc(e * i) / i) || 0,
        y: vc(vc(n * i) / i) || 0
    }
}

function q1(t) {
    var e, n = t.popper,
        r = t.popperRect,
        i = t.placement,
        s = t.variation,
        o = t.offsets,
        a = t.position,
        c = t.gpuAcceleration,
        l = t.adaptive,
        u = t.roundOffsets,
        f = u === !0 ? hI(o) : typeof u == "function" ? u(o) : o,
        d = f.x,
        h = d === void 0 ? 0 : d,
        p = f.y,
        g = p === void 0 ? 0 : p,
        b = o.hasOwnProperty("x"),
        x = o.hasOwnProperty("y"),
        w = Zn,
        O = Kn,
        N = window;
    if (l) {
        var U = Cl(n),
            H = "clientHeight",
            M = "clientWidth";
        U === hr(n) && (U = Ki(n), oi(U).position !== "static" && a === "absolute" && (H = "scrollHeight", M = "scrollWidth")), U = U, (i === Kn || (i === Zn || i === fr) && s === al) && (O = ur, g -= U[H] - r.height, g *= c ? 1 : -1), (i === Zn || (i === Kn || i === ur) && s === al) && (w = fr, h -= U[M] - r.width, h *= c ? 1 : -1)
    }
    var y = Object.assign({
        position: a
    }, l && dI);
    if (c) {
        var v;
        return Object.assign({}, y, (v = {}, v[O] = x ? "0" : "", v[w] = b ? "0" : "", v.transform = (N.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + g + "px)" : "translate3d(" + h + "px, " + g + "px, 0)", v))
    }
    return Object.assign({}, y, (e = {}, e[O] = x ? g + "px" : "", e[w] = b ? h + "px" : "", e.transform = "", e))
}

function pI(t) {
    var e = t.state,
        n = t.options,
        r = n.gpuAcceleration,
        i = r === void 0 ? !0 : r,
        s = n.adaptive,
        o = s === void 0 ? !0 : s,
        a = n.roundOffsets,
        c = a === void 0 ? !0 : a,
        l = {
            placement: Tr(e.placement),
            variation: Vo(e.placement),
            popper: e.elements.popper,
            popperRect: e.rects.popper,
            gpuAcceleration: i
        };
    e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, q1(Object.assign({}, l, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: o,
        roundOffsets: c
    })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, q1(Object.assign({}, l, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: c
    })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
    })
}
var mI = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: pI,
    data: {}
};

function gI(t) {
    var e = t.state;
    Object.keys(e.elements).forEach(function(n) {
        var r = e.styles[n] || {},
            i = e.attributes[n] || {},
            s = e.elements[n];
        !Jn(s) || !Dr(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(o) {
            var a = i[o];
            a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a)
        }))
    })
}

function yI(t) {
    var e = t.state,
        n = {
            popper: {
                position: e.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
            },
            arrow: {
                position: "absolute"
            },
            reference: {}
        };
    return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
        function() {
            Object.keys(e.elements).forEach(function(r) {
                var i = e.elements[r],
                    s = e.attributes[r] || {},
                    o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]),
                    a = o.reduce(function(c, l) {
                        return c[l] = "", c
                    }, {});
                !Jn(i) || !Dr(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function(c) {
                    i.removeAttribute(c)
                }))
            })
        }
}
var vI = {
        name: "applyStyles",
        enabled: !0,
        phase: "write",
        fn: gI,
        effect: yI,
        requires: ["computeStyles"]
    },
    bI = [cI, fI, mI, vI],
    wI = aI({
        defaultModifiers: bI
    });

function xI(t) {
    return t === "x" ? "y" : "x"
}

function Fc(t, e, n) {
    return zi(t, ll(e, n))
}

function AI(t) {
    var e = t.state,
        n = t.options,
        r = t.name,
        i = n.mainAxis,
        s = i === void 0 ? !0 : i,
        o = n.altAxis,
        a = o === void 0 ? !1 : o,
        c = n.boundary,
        l = n.rootBoundary,
        u = n.altBoundary,
        f = n.padding,
        d = n.tether,
        h = d === void 0 ? !0 : d,
        p = n.tetherOffset,
        g = p === void 0 ? 0 : p,
        b = nm(e, {
            boundary: c,
            rootBoundary: l,
            padding: f,
            altBoundary: u
        }),
        x = Tr(e.placement),
        w = Vo(e.placement),
        O = !w,
        N = tm(x),
        U = xI(N),
        H = e.modifiersData.popperOffsets,
        M = e.rects.reference,
        y = e.rects.popper,
        v = typeof g == "function" ? g(Object.assign({}, e.rects, {
            placement: e.placement
        })) : g,
        A = {
            x: 0,
            y: 0
        };
    if (H) {
        if (s || a) {
            var E = N === "y" ? Kn : Zn,
                P = N === "y" ? ur : fr,
                R = N === "y" ? "height" : "width",
                F = H[N],
                _ = H[N] + b[E],
                S = H[N] - b[P],
                I = h ? -y[R] / 2 : 0,
                B = w === jo ? M[R] : y[R],
                j = w === jo ? -y[R] : -M[R],
                Y = e.elements.arrow,
                te = h && Y ? $p(Y) : {
                    width: 0,
                    height: 0
                },
                he = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : Y2(),
                Te = he[E],
                Be = he[P],
                ve = Fc(0, M[R], te[R]),
                X = O ? M[R] / 2 - I - ve - Te - v : B - ve - Te - v,
                V = O ? -M[R] / 2 + I + ve + Be + v : j + ve + Be + v,
                oe = e.elements.arrow && Cl(e.elements.arrow),
                ae = oe ? N === "y" ? oe.clientTop || 0 : oe.clientLeft || 0 : 0,
                Ae = e.modifiersData.offset ? e.modifiersData.offset[e.placement][N] : 0,
                Fe = H[N] + X - Ae - ae,
                C = H[N] + V - Ae;
            if (s) {
                var T = Fc(h ? ll(_, Fe) : _, F, h ? zi(S, C) : S);
                H[N] = T, A[N] = T - F
            }
            if (a) {
                var z = N === "x" ? Kn : Zn,
                    Q = N === "x" ? ur : fr,
                    $ = H[U],
                    ne = $ + b[z],
                    ge = $ - b[Q],
                    ce = Fc(h ? ll(ne, Fe) : ne, $, h ? zi(ge, C) : ge);
                H[U] = ce, A[U] = ce - $
            }
        }
        e.modifiersData[r] = A
    }
}
var kI = {
        name: "preventOverflow",
        enabled: !0,
        phase: "main",
        fn: AI,
        requiresIfExists: ["offset"]
    },
    _I = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
    };

function Uc(t) {
    return t.replace(/left|right|bottom|top/g, function(e) {
        return _I[e]
    })
}
var EI = {
    start: "end",
    end: "start"
};

function $1(t) {
    return t.replace(/start|end/g, function(e) {
        return EI[e]
    })
}

function PI(t, e) {
    e === void 0 && (e = {});
    var n = e,
        r = n.placement,
        i = n.boundary,
        s = n.rootBoundary,
        o = n.padding,
        a = n.flipVariations,
        c = n.allowedAutoPlacements,
        l = c === void 0 ? J2 : c,
        u = Vo(r),
        f = u ? a ? K1 : K1.filter(function(p) {
            return Vo(p) === u
        }) : Ol,
        d = f.filter(function(p) {
            return l.indexOf(p) >= 0
        });
    d.length === 0 && (d = f);
    var h = d.reduce(function(p, g) {
        return p[g] = nm(t, {
            placement: g,
            boundary: i,
            rootBoundary: s,
            padding: o
        })[Tr(g)], p
    }, {});
    return Object.keys(h).sort(function(p, g) {
        return h[p] - h[g]
    })
}

function SI(t) {
    if (Tr(t) === em) return [];
    var e = Uc(t);
    return [$1(t), e, $1(e)]
}

function NI(t) {
    var e = t.state,
        n = t.options,
        r = t.name;
    if (!e.modifiersData[r]._skip) {
        for (var i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !0 : o, c = n.fallbackPlacements, l = n.padding, u = n.boundary, f = n.rootBoundary, d = n.altBoundary, h = n.flipVariations, p = h === void 0 ? !0 : h, g = n.allowedAutoPlacements, b = e.options.placement, x = Tr(b), w = x === b, O = c || (w || !p ? [Uc(b)] : SI(b)), N = [b].concat(O).reduce(function(Be, ve) {
                return Be.concat(Tr(ve) === em ? PI(e, {
                    placement: ve,
                    boundary: u,
                    rootBoundary: f,
                    padding: l,
                    flipVariations: p,
                    allowedAutoPlacements: g
                }) : ve)
            }, []), U = e.rects.reference, H = e.rects.popper, M = new Map, y = !0, v = N[0], A = 0; A < N.length; A++) {
            var E = N[A],
                P = Tr(E),
                R = Vo(E) === jo,
                F = [Kn, ur].indexOf(P) >= 0,
                _ = F ? "width" : "height",
                S = nm(e, {
                    placement: E,
                    boundary: u,
                    rootBoundary: f,
                    altBoundary: d,
                    padding: l
                }),
                I = F ? R ? fr : Zn : R ? ur : Kn;
            U[_] > H[_] && (I = Uc(I));
            var B = Uc(I),
                j = [];
            if (s && j.push(S[P] <= 0), a && j.push(S[I] <= 0, S[B] <= 0), j.every(function(Be) {
                    return Be
                })) {
                v = E, y = !1;
                break
            }
            M.set(E, j)
        }
        if (y)
            for (var Y = p ? 3 : 1, te = function(ve) {
                    var X = N.find(function(V) {
                        var oe = M.get(V);
                        if (oe) return oe.slice(0, ve).every(function(ae) {
                            return ae
                        })
                    });
                    if (X) return v = X, "break"
                }, he = Y; he > 0; he--) {
                var Te = te(he);
                if (Te === "break") break
            }
        e.placement !== v && (e.modifiersData[r]._skip = !0, e.placement = v, e.reset = !0)
    }
}
var RI = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: NI,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};

function CI(t, e, n) {
    var r = Tr(t),
        i = [Zn, Kn].indexOf(r) >= 0 ? -1 : 1,
        s = typeof n == "function" ? n(Object.assign({}, e, {
            placement: t
        })) : n,
        o = s[0],
        a = s[1];
    return o = o || 0, a = (a || 0) * i, [Zn, fr].indexOf(r) >= 0 ? {
        x: a,
        y: o
    } : {
        x: o,
        y: a
    }
}

function OI(t) {
    var e = t.state,
        n = t.options,
        r = t.name,
        i = n.offset,
        s = i === void 0 ? [0, 0] : i,
        o = J2.reduce(function(u, f) {
            return u[f] = CI(f, e.rects, s), u
        }, {}),
        a = o[e.placement],
        c = a.x,
        l = a.y;
    e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += c, e.modifiersData.popperOffsets.y += l), e.modifiersData[r] = o
}
var TI = {
        name: "offset",
        enabled: !0,
        phase: "main",
        requires: ["popperOffsets"],
        fn: OI
    },
    BI = function(e, n) {
        return e = typeof e == "function" ? e(Object.assign({}, n.rects, {
            placement: n.placement
        })) : e, X2(typeof e != "number" ? e : q2(e, Ol))
    };

function II(t) {
    var e, n = t.state,
        r = t.name,
        i = t.options,
        s = n.elements.arrow,
        o = n.modifiersData.popperOffsets,
        a = Tr(n.placement),
        c = tm(a),
        l = [Zn, fr].indexOf(a) >= 0,
        u = l ? "height" : "width";
    if (!(!s || !o)) {
        var f = BI(i.padding, n),
            d = $p(s),
            h = c === "y" ? Kn : Zn,
            p = c === "y" ? ur : fr,
            g = n.rects.reference[u] + n.rects.reference[c] - o[c] - n.rects.popper[u],
            b = o[c] - n.rects.reference[c],
            x = Cl(s),
            w = x ? c === "y" ? x.clientHeight || 0 : x.clientWidth || 0 : 0,
            O = g / 2 - b / 2,
            N = f[h],
            U = w - d[u] - f[p],
            H = w / 2 - d[u] / 2 + O,
            M = Fc(N, H, U),
            y = c;
        n.modifiersData[r] = (e = {}, e[y] = M, e.centerOffset = M - H, e)
    }
}

function DI(t) {
    var e = t.state,
        n = t.options,
        r = n.element,
        i = r === void 0 ? "[data-popper-arrow]" : r;
    i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || K2(e.elements.popper, i) && (e.elements.arrow = i))
}
var LI = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: II,
    effect: DI,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};
const bd = t => parseInt(t, 10);

function MI({
    arrowPadding: t,
    emit: e,
    locked: n,
    offsetDistance: r,
    offsetSkid: i,
    placement: s,
    popperNode: o,
    triggerNode: a
}) {
    const c = gl({
            isOpen: !1,
            popperInstance: null
        }),
        l = g => {
            var b;
            (b = c.popperInstance) === null || b === void 0 || b.setOptions(x => ({ ...x,
                modifiers: [...x.modifiers, {
                    name: "eventListeners",
                    enabled: g
                }]
            }))
        },
        u = () => l(!0),
        f = () => l(!1),
        d = () => {
            c.isOpen && (c.isOpen = !1, e("close:popper"))
        },
        h = () => {
            c.isOpen || (c.isOpen = !0, e("open:popper"))
        };
    Xe([() => c.isOpen, s], async ([g]) => {
        g ? (await p(), u()) : f()
    });
    const p = async () => {
        await yl(), c.popperInstance = wI(a.value, o.value, {
            placement: s.value,
            modifiers: [kI, RI, {
                name: "flip",
                enabled: !n.value
            }, LI, {
                name: "arrow",
                options: {
                    padding: bd(t.value)
                }
            }, TI, {
                name: "offset",
                options: {
                    offset: [bd(i.value), bd(r.value)]
                }
            }]
        }), c.popperInstance.update()
    };
    return vl(() => {
        var g;
        (g = c.popperInstance) === null || g === void 0 || g.destroy()
    }), { ...oo(c),
        open: h,
        close: d
    }
}
const FI = {
    id: "arrow",
    "data-popper-arrow": ""
};

function UI(t, e) {
    return fe(), be("div", FI)
}

function $2(t, e) {
    e === void 0 && (e = {});
    var n = e.insertAt;
    if (!(!t || typeof document > "u")) {
        var r = document.head || document.getElementsByTagName("head")[0],
            i = document.createElement("style");
        i.type = "text/css", n === "top" && r.firstChild ? r.insertBefore(i, r.firstChild) : r.appendChild(i), i.styleSheet ? i.styleSheet.cssText = t : i.appendChild(document.createTextNode(t))
    }
}
var HI = `
#arrow[data-v-20b7fd4a],
  #arrow[data-v-20b7fd4a]::before {
    transition: background 250ms ease-in-out;
    position: absolute;
    width: calc(10px - var(--popper-theme-border-width, 0px));
    height: calc(10px - var(--popper-theme-border-width, 0px));
    box-sizing: border-box;
    background: var(--popper-theme-background-color);
}
#arrow[data-v-20b7fd4a] {
    visibility: hidden;
}
#arrow[data-v-20b7fd4a]::before {
    visibility: visible;
    content: "";
    transform: rotate(45deg);
}

  /* Top arrow */
.popper[data-popper-placement^="top"] > #arrow[data-v-20b7fd4a] {
    bottom: -5px;
}
.popper[data-popper-placement^="top"] > #arrow[data-v-20b7fd4a]::before {
    border-right: var(--popper-theme-border-width)
      var(--popper-theme-border-style) var(--popper-theme-border-color);
    border-bottom: var(--popper-theme-border-width)
      var(--popper-theme-border-style) var(--popper-theme-border-color);
}

  /* Bottom arrow */
.popper[data-popper-placement^="bottom"] > #arrow[data-v-20b7fd4a] {
    top: -5px;
}
.popper[data-popper-placement^="bottom"] > #arrow[data-v-20b7fd4a]::before {
    border-left: var(--popper-theme-border-width)
      var(--popper-theme-border-style) var(--popper-theme-border-color);
    border-top: var(--popper-theme-border-width)
      var(--popper-theme-border-style) var(--popper-theme-border-color);
}

  /* Left arrow */
.popper[data-popper-placement^="left"] > #arrow[data-v-20b7fd4a] {
    right: -5px;
}
.popper[data-popper-placement^="left"] > #arrow[data-v-20b7fd4a]::before {
    border-right: var(--popper-theme-border-width)
      var(--popper-theme-border-style) var(--popper-theme-border-color);
    border-top: var(--popper-theme-border-width)
      var(--popper-theme-border-style) var(--popper-theme-border-color);
}

  /* Right arrow */
.popper[data-popper-placement^="right"] > #arrow[data-v-20b7fd4a] {
    left: -5px;
}
`;
$2(HI);
const rm = {};
rm.render = UI;
rm.__scopeId = "data-v-20b7fd4a";
var zI = rm;
const jI = ["onKeyup"];
var ex = {
        props: {
            placement: {
                type: String,
                default: "bottom",
                validator: function(t) {
                    return ["auto", "auto-start", "auto-end", "top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "right", "right-start", "right-end", "left", "left-start", "left-end"].includes(t)
                }
            },
            disableClickAway: {
                type: Boolean,
                default: !1
            },
            offsetSkid: {
                type: String,
                default: "0"
            },
            offsetDistance: {
                type: String,
                default: "12"
            },
            hover: {
                type: Boolean,
                default: !1
            },
            show: {
                type: Boolean,
                default: null
            },
            disabled: {
                type: Boolean,
                default: !1
            },
            openDelay: {
                type: [Number, String],
                default: 0
            },
            closeDelay: {
                type: [Number, String],
                default: 0
            },
            zIndex: {
                type: [Number, String],
                default: 9999
            },
            arrow: {
                type: Boolean,
                default: !1
            },
            arrowPadding: {
                type: String,
                default: "0"
            },
            interactive: {
                type: Boolean,
                default: !0
            },
            locked: {
                type: Boolean,
                default: !1
            },
            content: {
                type: String,
                default: null
            }
        },
        emits: ["open:popper", "close:popper"],
        setup(t, {
            emit: e
        }) {
            const n = t;
            v4(B => ({
                c81fc0a4: t.zIndex
            }));
            const r = y_(),
                i = Z(null),
                s = Z(null),
                o = Z(null),
                a = Z(!1);
            sn(() => {
                const B = r.default();
                if (B && B.length > 1) return console.error(`[Popper]: The <Popper> component expects only one child element at its root. You passed ${B.length} child nodes.`)
            });
            const {
                arrowPadding: c,
                closeDelay: l,
                content: u,
                disableClickAway: f,
                disabled: d,
                interactive: h,
                locked: p,
                offsetDistance: g,
                offsetSkid: b,
                openDelay: x,
                placement: w,
                show: O
            } = oo(n), {
                isOpen: N,
                open: U,
                close: H
            } = MI({
                arrowPadding: c,
                emit: e,
                locked: p,
                offsetDistance: g,
                offsetSkid: b,
                placement: w,
                popperNode: s,
                triggerNode: o
            }), {
                hasContent: M
            } = BB(r, s, u), y = ze(() => O.value !== null), v = ze(() => d.value || !M.value), A = ze(() => N.value && !v.value), E = ze(() => !f.value && !y.value), P = ze(() => h.value ? `border: ${g.value}px solid transparent; margin: -${g.value}px;` : null), R = vd.debounce(U, x.value), F = vd.debounce(H, l.value), _ = async () => {
                v.value || y.value || (F.clear(), R())
            }, S = async () => {
                y.value || (R.clear(), F())
            }, I = () => {
                N.value ? S() : _()
            };
            return Xe([M, d], ([B, j]) => {
                N.value && (!B || j) && H()
            }), Xe(N, B => {
                B ? a.value = !0 : vd.debounce(() => {
                    a.value = !1
                }, 200)
            }), Zc(() => {
                y.value && (O.value ? R() : F())
            }), Zc(() => {
                E.value && TB(i, S)
            }), (B, j) => (fe(), be("div", {
                class: "inline-block",
                style: Eu(J(P)),
                onMouseleave: j[2] || (j[2] = Y => t.hover && S()),
                ref: (Y, te) => {
                    te.popperContainerNode = Y, i.value = Y
                }
            }, [m("div", {
                ref: (Y, te) => {
                    te.triggerNode = Y, o.value = Y
                },
                onMouseover: j[0] || (j[0] = Y => t.hover && _()),
                onClick: I,
                onFocus: _,
                onKeyup: x4(S, ["esc"])
            }, [Zm(B.$slots, "default")], 40, jI), q(up, {
                name: "fade"
            }, {
                default: Ze(() => [Bt(m("div", {
                    onClick: j[1] || (j[1] = Y => !J(h) && S()),
                    class: "popper",
                    ref: (Y, te) => {
                        te.popperNode = Y, s.value = Y
                    }
                }, [Zm(B.$slots, "content", {
                    close: J(H),
                    isOpen: a.value
                }, () => [Ke(ue(J(u)), 1)]), t.arrow ? (fe(), fi(zI, {
                    key: 0
                })) : Ea("", !0)], 512), [
                    [i4, J(A)]
                ])]),
                _: 3
            })], 36))
        }
    },
    VI = `
.inline-block[data-v-5784ed69] {
    display: inline-block;
}
.popper[data-v-5784ed69] {
    transition: background 250ms ease-in-out;
    background: var(--popper-theme-background-color);
    padding: var(--popper-theme-padding);
    color: var(--popper-theme-text-color);
    border-radius: var(--popper-theme-border-radius);
    border-width: var(--popper-theme-border-width);
    border-style: var(--popper-theme-border-style);
    border-color: var(--popper-theme-border-color);
    box-shadow: var(--popper-theme-box-shadow);
    z-index: var(--c81fc0a4);
}
.popper[data-v-5784ed69]:hover,
  .popper:hover > #arrow[data-v-5784ed69]::before {
    background: var(--popper-theme-background-color-hover);
}
.inline-block[data-v-5784ed69] {
    display: inline-block;
}
.fade-enter-active[data-v-5784ed69],
  .fade-leave-active[data-v-5784ed69] {
    transition: opacity 0.2s ease;
}
.fade-enter-from[data-v-5784ed69],
  .fade-leave-to[data-v-5784ed69] {
    opacity: 0;
}
`;
$2(VI);
ex.__scopeId = "data-v-5784ed69";
var ki = (() => {
    const t = ex;
    return t.install = e => {
        e.component("Popper", t)
    }, t
})();
const GI = m("svg", {
        class: "h-4 w-4",
        fill: "none",
        viewBox: "0 0 12 12"
    }, [m("path", {
        d: "M4 8l2-2m0 0l2-2M6 6L4 4m2 2l2 2",
        stroke: "white",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    })], -1),
    WI = [GI],
    QI = m("svg", {
        class: "h-4 w-4",
        fill: "white",
        viewBox: "0 0 12 12"
    }, [m("path", {
        d: "M3.707 5.293a1 1 0 00-1.414 1.414l1.414-1.414zM5 8l-.707.707a1 1 0 001.414 0L5 8zm4.707-3.293a1 1 0 00-1.414-1.414l1.414 1.414zm-7.414 2l2 2 1.414-1.414-2-2-1.414 1.414zm3.414 2l4-4-1.414-1.414-4 4 1.414 1.414z"
    })], -1),
    JI = [QI],
    KI = nt({
        __name: "switch-smoothing-pool",
        setup(t) {
            const e = we("smoothingPoolEnabled");
            return (n, r) => (fe(), fi(J(Jp), {
                as: "div",
                class: "flex items-center justify-between"
            }, {
                default: Ze(() => [q(J(Kp), {
                    modelValue: J(e),
                    "onUpdate:modelValue": r[0] || (r[0] = i => pt(e) ? e.value = i : null),
                    class: Rt([J(e) ? "bg-slate-100" : "bg-slate-50", "relative inline-flex flex-shrink-0 h-10 w-20 border-2 border-slate-400 rounded-full cursor-pointer transition-colors ease-in-out duration-200 ring-1 ring-slate-100"])
                }, {
                    default: Ze(() => [m("span", {
                        class: Rt([J(e) ? "translate-x-10" : "translate-x-0", "pointer-events-none relative inline-block h-9 w-9 rounded-full shadow transform ring-0 transition ease-in-out duration-200 bg-slate-900"])
                    }, [m("span", {
                        class: Rt([J(e) ? "opacity-0 ease-out duration-100" : "opacity-100 ease-in duration-200", "absolute inset-0 h-full w-full flex items-center justify-center transition-opacity"]),
                        "aria-hidden": "true"
                    }, WI, 2), m("span", {
                        class: Rt([J(e) ? "opacity-100 ease-in duration-200" : "opacity-0 ease-out duration-100", "absolute inset-0 h-full w-full flex items-center justify-center transition-opacity"]),
                        "aria-hidden": "true"
                    }, JI, 2)], 2)]),
                    _: 1
                }, 8, ["modelValue", "class"])]),
                _: 1
            }))
        }
    }),
    ZI = {
        class: "relative pt-16 pb-20 px-4 sm:px-6 lg:pt-24 lg:pb-28 lg:px-8 team overflow-hidden"
    },
    YI = m("div", {
        class: "bg-fx"
    }, null, -1),
    XI = m("div", {
        class: "bg-clouds-bottom"
    }, null, -1),
    qI = m("div", {
        class: "bg-clouds-top"
    }, null, -1),
    $I = {
        class: "relative max-w-7xl text-center md:text-left mx-auto py-12 px-4 sm:px-6 lg:px-8 lg:py-24 z-20"
    },
    eD = m("div", {
        class: "lg:text-center"
    }, [m("h2", {
        class: "py-2 text-center text-4xl font-extrabold tracking-tight sm:text-5xl bg-gradient-to-r from-pink-100 via-yellow-300 to-yellow-200 bg-clip-text text-transparent leading-8"
    }, " What can I earn as a Rocket Pool node operator? "), m("p", {
        class: "mt-6 max-w-7xl text-xl text-gray-50 mx-auto font-semibold text-center"
    }, " You earn beacon chain rewards on your staked ETH, commission on pool staked ETH, and RPL rewards for providing collateral. ")], -1),
    tD = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    nD = {
        class: "bg-white p-6 mt-6 rounded-lg"
    },
    rD = {
        class: "text-center"
    },
    iD = {
        class: "text-5xl font-extrabold purple-gradient bg-clip-text text-transparent tracking-tight"
    },
    sD = m("p", {
        class: "mt-2 text-lg leading-6 font-medium text-gray-500 text-gray-500"
    }, "ETH Rewards", -1),
    oD = m("p", {
        class: "bg-gray-100 p-6 mt-6 rounded-lg text-gray-500"
    }, " As an ethereum proof-of-stake validator you earn rewards on your staked Ethereum. Additionally you receive a commission on the ETH you stake for Rocket Pool. ", -1),
    aD = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    lD = {
        class: "text-gray-500"
    },
    cD = {
        class: "text-gray-500"
    },
    uD = {
        class: "font-bold text-gray-500"
    },
    fD = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    dD = {
        class: "text-gray-500"
    },
    hD = {
        class: "text-gray-500"
    },
    pD = {
        class: "font-bold text-gray-500"
    },
    mD = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    gD = {
        class: "text-gray-500 pt-2"
    },
    yD = {
        class: "flex flex-row justify-center items-center pt-4 lg:pt-0"
    },
    vD = {
        class: "flex-1"
    },
    bD = {
        class: "mt-16 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    wD = {
        class: "text-gray-500"
    },
    xD = {
        key: 0
    },
    AD = {
        class: "flex flex-row justify-center items-center pt-4 lg:pt-0"
    },
    kD = {
        class: "flex-1"
    },
    _D = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    ED = {
        class: "text-gray-500"
    },
    PD = {
        key: 0
    },
    SD = {
        class: "flex flex-row justify-center items-center pt-4 lg:pt-0"
    },
    ND = {
        class: "flex-1"
    },
    RD = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    CD = m("p", {
        class: "text-gray-500"
    }, "Return (per minipool)", -1),
    OD = {
        class: "font-bold text-gray-500"
    },
    TD = {
        class: "bg-gray-100 p-6 mt-6 rounded-lg text-gray-500 text-sm hidden"
    },
    BD = m("p", {
        class: "font-bold pb-2"
    }, "Calculation: Return", -1),
    ID = m("pre", {
        class: "pb-2 whitespace-normal"
    }, "Return (per minipool) = (Beacon Chain Return + Commission + Priority Fees + MEV", -1),
    DD = {
        class: "bg-gray-100 p-6 mt-6 rounded-lg text-gray-500 text-sm hidden"
    },
    LD = m("p", {
        class: "font-bold pb-2"
    }, "Calculation: APR", -1),
    MD = m("pre", {
        class: "pb-2 whitespace-normal"
    }, "APR = (Calculated ETH Return / ETH per Minipool) * 100", -1),
    FD = {
        class: "bg-gray-100 p-6 mt-6 rounded-lg text-gray-500 text-sm hidden"
    },
    UD = m("p", {
        class: "font-bold pb-2"
    }, "Calculation: Priority Fees & MEV", -1),
    HD = m("pre", {
        class: "pb-2 whitespace-normal"
    }, "Priority Fees = (Value + Commission", -1),
    zD = m("pre", {
        class: "pt-4 pb-2 whitespace-normal"
    }, "MEV = (Value + Commission", -1),
    jD = {
        class: "bg-white p-6 mt-6 rounded-lg"
    },
    VD = {
        class: "text-center"
    },
    GD = {
        class: "text-5xl font-extrabold purple-gradient bg-clip-text text-transparent tracking-tight"
    },
    WD = m("p", {
        class: "mt-2 text-lg leading-6 font-medium text-gray-500"
    }, "RPL Rewards", -1),
    QD = m("p", {
        class: "bg-gray-100 p-6 mt-6 rounded-lg pb-12 text-gray-500"
    }, " By providing RPL collateral as an insurance promise to the protocol, you receive RPL rewards from RPL inflation every 28 days. ", -1),
    JD = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    KD = {
        class: "text-gray-500"
    },
    ZD = {
        class: "flex flex-row justify-center items-center pt-4 lg:pt-0"
    },
    YD = {
        class: "flex-1"
    },
    XD = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    qD = {
        class: "text-gray-500"
    },
    $D = {
        class: "flex flex-row justify-center items-center pt-4 lg:pt-0"
    },
    eL = {
        class: "flex-1"
    },
    tL = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    nL = {
        class: "text-gray-500"
    },
    rL = {
        class: "text-gray-500"
    },
    iL = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    sL = m("p", {
        class: "text-gray-500"
    }, "Return", -1),
    oL = {
        class: "font-bold text-gray-500"
    },
    aL = {
        class: "font-bold text-gray-500"
    },
    lL = {
        class: "bg-gray-100 p-6 mt-6 rounded-lg text-gray-500 text-sm"
    },
    cL = m("p", {
        class: "font-bold pb-2"
    }, "Calculation:", -1),
    uL = m("pre", {
        class: "pb-2 whitespace-normal"
    }, "RPL Return = (Your RPL Staked / Protocol RPL Staked) * (RPL Supply * Inflation * Node Operator Share)", -1),
    fL = {
        class: "whitespace-normal"
    },
    dL = {
        class: "bg-gray-100 p-6 mt-6 rounded-lg"
    },
    hL = m("p", {
        class: "text-lg leading-6 font-semibold text-gray-900"
    }, "Important: there are a number of factors to consider when estimating returns over time.", -1),
    pL = m("p", {
        class: "mt-6 text-gray-500 font-bold"
    }, "ETH rewards", -1),
    mL = {
        class: "mt-2 text-gray-500 list-disc ml-6"
    },
    gL = m("li", null, "rewards are subject to the rate of issuance from the Ethereum beacon chain", -1),
    yL = m("li", null, "the beacon chain will decrease issuance as more ETH is staked", -1),
    vL = {
        key: 0
    },
    bL = m("p", {
        class: "mt-6 text-gray-500 font-bold"
    }, "RPL rewards", -1),
    wL = m("ul", {
        class: "mt-2 text-gray-500 list-disc ml-6"
    }, [m("li", null, "rewards will decrease over time as more RPL is staked"), m("li", null, "as more RPL is staked, this will take it out of supply")], -1),
    xL = nt({
        __name: "earn",
        setup(t) {
            const e = we("emitter"),
                n = we("commission"),
                r = we("yourRPLStaked"),
                i = we("yourRPLStakedPercentage"),
                s = we("rplAPRPercentage"),
                o = we("rplReturn"),
                a = we("rplETHRatio"),
                c = we("rplETHRatioBN"),
                l = we("rplReturnETH"),
                u = we("beaconChainAPR"),
                f = we("ethAPRPercentage"),
                d = we("calculatedETHReturn"),
                h = we("totalEffectiveRPLStaked"),
                p = we("inflation"),
                g = we("nodeOperatorShare"),
                b = we("rplSupply"),
                x = we("rplSupplyBN"),
                w = we("beaconChainReturnAsDecimalFormatted"),
                O = we("priorityFees"),
                N = we("priorityFeesBN"),
                U = we("priorityFeesCommission"),
                H = we("mev"),
                M = we("mevBN"),
                y = we("mevCommission"),
                v = we("smoothingPoolEnabled"),
                A = we("totalEffectiveRPLStakedDefault"),
                E = we("yourRPLStakedDefault"),
                P = we("yourRPLStakedOptions"),
                R = we("commissionValueBN");

            function F() {
                e.emit("recalculate")
            }
            const _ = {
                    range: {
                        min: .01,
                        max: 1
                    },
                    step: .01
                },
                S = function(X) {
                    return ba(X).format("0.00a") + " ETH"
                },
                I = {
                    range: {
                        min: .01,
                        max: 1
                    },
                    step: .01
                },
                B = function(X) {
                    return ba(X).format("0.00a") + " ETH"
                },
                j = {
                    range: {
                        min: 1e6,
                        max: x.value.toNumber()
                    },
                    step: 1e5
                },
                Y = function(X) {
                    return ba(X).format("0.0a") + " RPL"
                },
                te = function(X) {
                    const oe = new me(X).multipliedBy(c.value).dividedBy(24).multipliedBy(100);
                    return i.value = oe.toFormat(0), `${ba(X).format("0")} RPL (${i.value}%)`
                };

            function he() {
                v.value ? O.value = .28 : O.value = .1
            }

            function Te() {
                v.value ? H.value = .28 : H.value = .1
            }

            function Be() {
                h.value = A.value
            }

            function ve() {
                r.value = E.value
            }
            return (X, V) => (fe(), be("div", ZI, [YI, XI, qI, m("div", $I, [eD, m("div", tD, [m("div", nD, [m("div", rD, [m("p", iD, ue(J(f)) + "% APR", 1), sD]), oD, m("div", aD, [q(J(ki), {
                placement: "top",
                arrow: "",
                content: "The estimated return from the Beacon Chain"
            }, {
                default: Ze(() => [m("p", lD, [Ke(" Beacon chain return "), q(J(Ai), {
                    class: "h-5 w-5 cursor-pointer inline-block relative top-[-2px]",
                    "aria-hidden": "true"
                })])]),
                _: 1
            }), m("p", cD, [Ke(ue(J(u)) + "% (", 1), m("span", uD, ue(J(w)), 1), Ke(" ETH) ")])]), m("div", fD, [q(J(ki), {
                placement: "top",
                arrow: "",
                content: "Rocket Pool Commission"
            }, {
                default: Ze(() => [m("p", dD, [Ke(" Commission "), q(J(Ai), {
                    class: "h-5 w-5 cursor-pointer inline-block relative top-[-2px]",
                    "aria-hidden": "true"
                })])]),
                _: 1
            }), m("p", hD, [Ke(ue(J(n)) + "% (", 1), m("span", pD, ue(J(R).toFormat(5)), 1), Ke(" ETH) ")])]), m("div", mD, [q(J(ki), {
                placement: "top",
                arrow: "",
                content: "Node has opted into the Smoothing Pool."
            }, {
                default: Ze(() => [m("p", gD, [Ke(" Smoothing Pool "), q(J(Ai), {
                    class: "h-5 w-5 cursor-pointer inline-block relative top-[-2px]",
                    "aria-hidden": "true"
                })])]),
                _: 1
            }), m("div", yD, [m("div", vD, [q(KI)])])]), m("div", bD, [q(J(ki), {
                placement: "top",
                arrow: "",
                content: "Priority Fees (tips)"
            }, {
                default: Ze(() => [m("p", wD, [J(v) ? (fe(), be("span", xD, "Median ")) : Ea("", !0), Ke("Priority Fees "), q(J(Ai), {
                    class: "h-5 w-5 cursor-pointer inline-block relative top-[-2px]",
                    "aria-hidden": "true"
                })])]),
                _: 1
            }), m("div", AD, [m("div", kD, [q(J($r), {
                modelValue: J(O),
                "onUpdate:modelValue": V[0] || (V[0] = oe => pt(O) ? O.value = oe : null),
                options: _,
                format: S,
                lazy: !1,
                onUpdate: F
            }, null, 8, ["modelValue"])]), m("span", {
                class: "ml-2 flex justify-center items-center px-2 py-1 rounded-full text-xs font-medium text-white hover:text-yellow-300 cursor-pointer backdrop-blur-md bg-slate-900/80 text-slate-100 hover:bg-slate-900/90 hover:text-yellow-300",
                onClick: he
            }, " Reset ")])]), m("div", _D, [q(J(ki), {
                placement: "top",
                arrow: "",
                content: "Maximal Extractable Value (MEV)"
            }, {
                default: Ze(() => [m("p", ED, [J(v) ? (fe(), be("span", PD, "Median ")) : Ea("", !0), Ke("MEV "), q(J(Ai), {
                    class: "h-5 w-5 cursor-pointer inline-block relative top-[-2px]",
                    "aria-hidden": "true"
                })])]),
                _: 1
            }), m("div", SD, [m("div", ND, [q(J($r), {
                modelValue: J(H),
                "onUpdate:modelValue": V[1] || (V[1] = oe => pt(H) ? H.value = oe : null),
                options: I,
                format: B,
                lazy: !1,
                onUpdate: F
            }, null, 8, ["modelValue"])]), m("span", {
                class: "ml-2 flex justify-center items-center px-2 py-1 rounded-full text-xs font-medium text-white hover:text-yellow-300 cursor-pointer backdrop-blur-md bg-slate-900/80 text-slate-100 hover:bg-slate-900/90 hover:text-yellow-300",
                onClick: Te
            }, " Reset ")])]), m("div", RD, [CD, m("p", null, [m("span", OD, ue(J(d)), 1), Ke(" ETH ")])]), m("div", TD, [BD, ID, m("pre", null, ue(J(d)) + " = (" + ue(J(w)) + " + " + ue(J(R).toFormat(2, J(me).ROUND_DOWN)) + ") + " + ue(J(N).toFormat(2, J(me).ROUND_DOWN)) + " + " + ue(J(M).toFormat(2, J(me).ROUND_DOWN)) + " ", 1)]), m("div", DD, [LD, MD, m("pre", null, ue(J(f)) + " = (" + ue(J(d)) + " / 8) * 100 ", 1)]), m("div", FD, [UD, HD, m("pre", null, ue(J(N).toFormat(2, J(me).ROUND_DOWN)) + " = " + ue(J(O)) + " + " + ue(J(U).toFormat(2, J(me).ROUND_DOWN)) + " ", 1), zD, m("pre", null, ue(J(M).toFormat(2, J(me).ROUND_DOWN)) + " = " + ue(J(H)) + " + " + ue(J(y).toFormat(2, J(me).ROUND_DOWN)) + " ", 1)])]), m("div", jD, [m("div", VD, [m("p", GD, ue(J(s)) + "% APR", 1), WD]), QD, m("div", JD, [q(J(ki), {
                placement: "top",
                arrow: "",
                content: "Amount of RPL staked on the Rocket Pool Protocol"
            }, {
                default: Ze(() => [m("p", KD, [Ke(" Protocol RPL Staked "), q(J(Ai), {
                    class: "h-5 w-5 cursor-pointer inline-block relative top-[-2px]",
                    "aria-hidden": "true"
                })])]),
                _: 1
            }), m("div", ZD, [m("div", YD, [q(J($r), {
                modelValue: J(h),
                "onUpdate:modelValue": V[2] || (V[2] = oe => pt(h) ? h.value = oe : null),
                options: j,
                format: Y,
                lazy: !1,
                onUpdate: F
            }, null, 8, ["modelValue"])]), m("span", {
                class: "ml-2 flex justify-center items-center px-2 py-1 rounded-full text-xs font-medium text-white hover:text-yellow-300 cursor-pointer backdrop-blur-md bg-slate-900/80 text-slate-100 hover:bg-slate-900/90 hover:text-yellow-300",
                onClick: Be
            }, " Reset ")])]), m("div", XD, [q(J(ki), {
                placement: "top",
                arrow: "",
                content: "The amount of RPL you plan to stake."
            }, {
                default: Ze(() => [m("p", qD, [Ke(" Your RPL Staked "), q(J(Ai), {
                    class: "h-5 w-5 cursor-pointer inline-block relative top-[-2px]",
                    "aria-hidden": "true"
                })])]),
                _: 1
            }), m("div", $D, [m("div", eL, [q(J($r), {
                modelValue: J(r),
                "onUpdate:modelValue": V[3] || (V[3] = oe => pt(r) ? r.value = oe : null),
                options: J(P),
                format: te,
                lazy: !1,
                onUpdate: F
            }, null, 8, ["modelValue", "options"])]), m("span", {
                class: "ml-2 flex justify-center items-center px-2 py-1 rounded-full text-xs font-medium text-white hover:text-yellow-300 cursor-pointer backdrop-blur-md bg-slate-900/80 text-slate-100 hover:bg-slate-900/90 hover:text-yellow-300",
                onClick: ve
            }, " Reset ")])]), m("div", tL, [q(J(ki), {
                placement: "top",
                arrow: "",
                content: "The RPL/ETH Price Ratio"
            }, {
                default: Ze(() => [m("p", nL, [Ke(" RPL/ETH Price "), q(J(Ai), {
                    class: "h-5 w-5 cursor-pointer inline-block relative top-[-2px]",
                    "aria-hidden": "true"
                })])]),
                _: 1
            }), m("p", rL, ue(J(a)) + " ETH", 1)]), m("div", iL, [sL, m("p", null, [m("span", oL, ue(J(o)), 1), Ke(" RPL ("), m("span", aL, ue(J(l)), 1), Ke(" ETH) ")])]), m("div", lL, [cL, uL, m("pre", fL, ue(J(o)) + " = (" + ue(J(r)) + " / " + ue(J(h)) + ") * (" + ue(J(b)) + " * " + ue(J(p)) + " * " + ue(J(g)) + ")", 1)])])]), m("div", dL, [hL, pL, m("ul", mL, [gL, yL, J(v) ? (fe(), be("li", vL, " regarding the smoothing pool, please note that median (rather than mean) MEV/Priority fees were used to represent the common experience; there will be a very small number of validators that receive extremely high MEV/Priority fees. The median results are better for the smoothing pool because participants share in the few lucky block proposals. ")) : Ea("", !0)]), bL, wL])])]))
        }
    }),
    AL = m("svg", {
        class: "h-4 w-4",
        fill: "none",
        viewBox: "0 0 12 12"
    }, [m("path", {
        d: "M4 8l2-2m0 0l2-2M6 6L4 4m2 2l2 2",
        stroke: "white",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    })], -1),
    kL = [AL],
    _L = m("svg", {
        class: "h-4 w-4",
        fill: "white",
        viewBox: "0 0 12 12"
    }, [m("path", {
        d: "M3.707 5.293a1 1 0 00-1.414 1.414l1.414-1.414zM5 8l-.707.707a1 1 0 001.414 0L5 8zm4.707-3.293a1 1 0 00-1.414-1.414l1.414 1.414zm-7.414 2l2 2 1.414-1.414-2-2-1.414 1.414zm3.414 2l4-4-1.414-1.414-4 4 1.414 1.414z"
    })], -1),
    EL = [_L],
    PL = {
        class: "flex-grow flex flex-col pl-4"
    },
    SL = {
        class: "font-bold"
    },
    NL = nt({
        __name: "switch-claim-rpl",
        setup(t) {
            const e = we("claimRPL"),
                n = we("ongoingClaimCost");
            return (r, i) => (fe(), fi(J(Jp), {
                as: "div",
                class: "flex items-center justify-between"
            }, {
                default: Ze(() => [q(J(Kp), {
                    modelValue: J(e),
                    "onUpdate:modelValue": i[0] || (i[0] = s => pt(e) ? e.value = s : null),
                    class: Rt([J(e) ? "bg-gray-100" : "bg-gray-50", "relative inline-flex flex-shrink-0 h-10 w-20 border-2 border-gray-400 rounded-full cursor-pointer transition-colors ease-in-out duration-200 ring-1 ring-gray-200"])
                }, {
                    default: Ze(() => [m("span", {
                        class: Rt([J(e) ? "translate-x-10" : "translate-x-0", "pointer-events-none relative inline-block h-9 w-9 rounded-full shadow transform ring-0 transition ease-in-out duration-200 bg-slate-900"])
                    }, [m("span", {
                        class: Rt([J(e) ? "opacity-0 ease-out duration-100" : "opacity-100 ease-in duration-200", "absolute inset-0 h-full w-full flex items-center justify-center transition-opacity"]),
                        "aria-hidden": "true"
                    }, kL, 2), m("span", {
                        class: Rt([J(e) ? "opacity-100 ease-in duration-200" : "opacity-0 ease-out duration-100", "absolute inset-0 h-full w-full flex items-center justify-center transition-opacity"]),
                        "aria-hidden": "true"
                    }, EL, 2)], 2)]),
                    _: 1
                }, 8, ["modelValue", "class"]), m("span", PL, [q(J(mu), {
                    as: "span",
                    class: "text-2xl text-gray-500"
                }, {
                    default: Ze(() => [Ke("Claim RPL Rewards")]),
                    _: 1
                }), q(J(mu), {
                    as: "span",
                    class: "text-md text-gray-500"
                }, {
                    default: Ze(() => [Ke(" Claim RPL reward: "), m("span", SL, ue(J(n)), 1), Ke(" ETH ")]),
                    _: 1
                })])]),
                _: 1
            }))
        }
    }),
    RL = m("svg", {
        class: "h-4 w-4",
        fill: "none",
        viewBox: "0 0 12 12"
    }, [m("path", {
        d: "M4 8l2-2m0 0l2-2M6 6L4 4m2 2l2 2",
        stroke: "white",
        "stroke-width": "2",
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
    })], -1),
    CL = [RL],
    OL = m("svg", {
        class: "h-4 w-4",
        fill: "white",
        viewBox: "0 0 12 12"
    }, [m("path", {
        d: "M3.707 5.293a1 1 0 00-1.414 1.414l1.414-1.414zM5 8l-.707.707a1 1 0 001.414 0L5 8zm4.707-3.293a1 1 0 00-1.414-1.414l1.414 1.414zm-7.414 2l2 2 1.414-1.414-2-2-1.414 1.414zm3.414 2l4-4-1.414-1.414-4 4 1.414 1.414z"
    })], -1),
    TL = [OL],
    BL = {
        class: "flex-grow flex flex-col pl-4"
    },
    IL = {
        class: "font-bold"
    },
    DL = nt({
        __name: "switch-restake-rpl",
        setup(t) {
            const e = we("restakeRPL"),
                n = we("ongoingStakeCost");
            return (r, i) => (fe(), fi(J(Jp), {
                as: "div",
                class: "flex items-center justify-between"
            }, {
                default: Ze(() => [q(J(Kp), {
                    modelValue: J(e),
                    "onUpdate:modelValue": i[0] || (i[0] = s => pt(e) ? e.value = s : null),
                    class: Rt([J(e) ? "bg-slate-100" : "bg-slate-50", "relative inline-flex flex-shrink-0 h-10 w-20 border-2 border-slate-400 rounded-full cursor-pointer transition-colors ease-in-out duration-200 ring-1 ring-slate-100"])
                }, {
                    default: Ze(() => [m("span", {
                        class: Rt([J(e) ? "translate-x-10" : "translate-x-0", "pointer-events-none relative inline-block h-9 w-9 rounded-full shadow transform ring-0 transition ease-in-out duration-200 bg-slate-900"])
                    }, [m("span", {
                        class: Rt([J(e) ? "opacity-0 ease-out duration-100" : "opacity-100 ease-in duration-200", "absolute inset-0 h-full w-full flex items-center justify-center transition-opacity"]),
                        "aria-hidden": "true"
                    }, CL, 2), m("span", {
                        class: Rt([J(e) ? "opacity-100 ease-in duration-200" : "opacity-0 ease-out duration-100", "absolute inset-0 h-full w-full flex items-center justify-center transition-opacity"]),
                        "aria-hidden": "true"
                    }, TL, 2)], 2)]),
                    _: 1
                }, 8, ["modelValue", "class"]), m("span", BL, [q(J(mu), {
                    as: "span",
                    class: "text-2xl text-gray-500"
                }, {
                    default: Ze(() => [Ke("Restake RPL Rewards")]),
                    _: 1
                }), q(J(mu), {
                    as: "span",
                    class: "text-md text-gray-500"
                }, {
                    default: Ze(() => [Ke(" Stake RPL reward: "), m("span", IL, ue(J(n)), 1), Ke(" ETH ")]),
                    _: 1
                })])]),
                _: 1
            }))
        }
    }),
    LL = {
        class: "py-20 bg-white"
    },
    ML = {
        class: "relative max-w-7xl text-center md:text-left mx-auto px-4 sm:px-6 lg:px-8"
    },
    FL = m("div", {
        class: "lg:text-center"
    }, [m("h2", {
        class: "py-2 text-center text-4xl font-extrabold tracking-tight sm:text-5xl bg-gradient-to-r from-red-500 via-yellow-400 to-red-400 bg-clip-text text-transparent leading-8"
    }, " What are the costs of running a Rocket Pool node? "), m("p", {
        class: "mt-6 max-w-7xl text-xl text-gray-600 mx-auto font-semibold text-center"
    }, "Rocket Pool node operators incur costs when interacting with the protocol smart contracts.")], -1),
    UL = {
        class: "gas-costs bg-gray-100 p-6 mt-12 rounded-lg"
    },
    HL = m("h3", {
        class: "text-3xl text-gray-600 mx-auto font-semibold text-center text-gray-500"
    }, "Gas Costs", -1),
    zL = m("p", {
        class: "bg-gray-50 p-6 mt-6 rounded-lg text-gray-500"
    }, "The estimates use the average gas price which you can set here.", -1),
    jL = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-3 lg:max-w-none"
    },
    VL = m("p", {
        class: "text-center md:text-right pt-4 md:pt-0"
    }, "Gas Price", -1),
    GL = {
        class: "flex flex-row justify-center items-center"
    },
    WL = {
        class: "flex-1"
    },
    QL = {
        class: "max-w-full mx-auto grid gap-10 sm:gap-20 lg:grid-cols-2 lg:max-w-none"
    },
    JL = {
        class: "initial bg-gray-100 p-6 mt-6 rounded-lg"
    },
    KL = m("h3", {
        class: "text-3xl text-gray-600 mx-auto font-semibold text-center mb-10"
    }, "Initial", -1),
    ZL = {
        class: "text-center"
    },
    YL = {
        class: "text-5xl font-extrabold purple-gradient bg-clip-text text-transparent tracking-tight"
    },
    XL = m("span", {
        class: "text-gray-600 font-semibold text-3xl tracking-normal text-gray-500"
    }, "ETH", -1),
    qL = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    $L = m("p", {
        class: "text-gray-500"
    }, "Node initialisation", -1),
    eM = {
        class: "text-gray-500"
    },
    tM = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    nM = m("p", {
        class: "text-gray-500"
    }, "Number of 8 ETH deposits (minipools)", -1),
    rM = {
        class: "flex flex-row justify-center items-center pt-4 lg:pt-0"
    },
    iM = {
        class: "flex-1"
    },
    sM = {
        class: "mt-12 max-w-full mx-auto grid gap-5 lg:grid-cols-2 lg:max-w-none"
    },
    oM = m("p", {
        class: "text-gray-500"
    }, "Minipool initialisation", -1),
    aM = {
        class: "text-gray-500"
    },
    lM = {
        class: "ongoing bg-gray-100 p-6 mt-6 rounded-lg"
    },
    cM = m("h3", {
        class: "text-3xl text-gray-600 mx-auto font-semibold text-center mb-10"
    }, "Ongoing", -1),
    uM = {
        class: "text-center"
    },
    fM = {
        class: "text-5xl font-extrabold purple-gradient bg-clip-text text-transparent tracking-tight"
    },
    dM = m("span", {
        class: "text-gray-600 font-semibold text-3xl tracking-normal text-gray-500"
    }, "ETH / claim", -1),
    hM = {
        class: "hidden"
    },
    pM = m("label", {
        for: "frequency",
        class: "mt-8 mb-2 pl-2 block text-2xl text-gray-500"
    }, "Claim Frequency", -1),
    mM = m("option", {
        value: "yearly"
    }, "Yearly", -1),
    gM = m("option", {
        value: "bi-yearly"
    }, "Bi-Yearly", -1),
    yM = m("option", {
        value: "quarterly"
    }, "Quarterly", -1),
    vM = m("option", {
        value: "monthly"
    }, "Monthly", -1),
    bM = [mM, gM, yM, vM],
    wM = {
        class: "mt-12 max-w-full mx-auto"
    },
    xM = {
        class: "mt-12 max-w-full mx-auto"
    },
    AM = m("p", {
        class: "bg-gray-50 p-6 mt-12 rounded-lg text-gray-500"
    }, [Ke(" Since our "), m("a", {
        href: "https://medium.com/rocket-pool/rocket-pool-the-merge-redstone-601d9efd6b4",
        target: "_blank",
        rel: "noreferrer",
        class: "text-orange-500 font-bold"
    }, "Redstone"), Ke(' upgrade, rewards have transitioned from mandatory claiming every 28 days to a more flexible "claim when it works for you" system. '), m("a", {
        href: "https://medium.com/rocket-pool/rocket-pool-the-merge-redstone-601d9efd6b4",
        target: "_blank",
        rel: "noreferrer",
        class: "text-orange-500 font-bold"
    }, "Learn more"), Ke(" . ")], -1),
    kM = nt({
        __name: "costs",
        setup(t) {
            const e = we("emitter"),
                n = we("gasPrice"),
                r = Z(new me(n.value)),
                i = we("minipools"),
                s = Z(null),
                o = Z(new me(0)),
                a = Z(null),
                c = Z(new me(0)),
                l = Z(new me(0)),
                u = Z(null),
                f = Z(new me(0)),
                d = Z(new me(0)),
                h = we("gasNodeETHTransfer"),
                p = we("gasNodeRPLTransfer"),
                g = we("gasNodeApprove"),
                b = we("gasNodeStakeRPL"),
                x = we("gasNodeTestWithdrawalAddress"),
                w = we("gasNodeSetWithdrawalAddress"),
                O = we("gasNodeConfirmWithdrawalAddress"),
                N = we("gasMinipoolDeposit"),
                U = we("gasMinipoolStake"),
                H = Z(null);
            de("ongoingStakeCost", H);
            const M = Z(new me(0)),
                y = Z(new me(0)),
                v = we("gasRPLNodeClaim"),
                A = we("gasRPLNodeTransfer"),
                E = we("gasRPLNodeStake"),
                P = Z(null);
            de("ongoingClaimCost", P);
            const R = Z(new me(0)),
                F = Z(new me(0)),
                _ = Z(null),
                S = Z(new me(0)),
                I = we("restakeRPL"),
                B = we("claimRPL"),
                j = Z("yearly"),
                Y = Z("year");
            sn(() => {
                te()
            }), Xe(n, () => {
                te()
            }), Xe(i, () => {
                te()
            }), Xe(I, () => {
                te()
            }), Xe(B, () => {
                te()
            }), Xe(j, () => {
                te()
            });

            function te() {
                r.value = new me(n.value), V(), X(), ve(), Te(), Be(), he(), e.emit("recalculate")
            }

            function he() {
                S.value = new me(0), I.value && (S.value = S.value.plus(M.value)), B.value && (S.value = S.value.plus(R.value)), _.value = S.value.toFormat(5)
            }

            function Te() {
                switch (y.value = new me.sum(v.value, A.value, E.value), j.value) {
                    case "yearly":
                        y.value = new me("285000"), Y.value = "year";
                        break;
                    case "bi-yearly":
                        y.value = new me("285000"), Y.value = "6 months";
                        break;
                    case "quarterly":
                        y.value = new me("285000"), Y.value = "quarter";
                        break;
                    case "monthly":
                        y.value = new me("285000"), Y.value = "month";
                        break;
                    default:
                        y.value = new me("285000")
                }
                M.value = y.value.multipliedBy(r.value).multipliedBy(new me("0.000000001")), H.value = M.value.toFormat(5)
            }

            function Be() {
                switch (j.value) {
                    case "yearly":
                        F.value = new me("129507");
                        break;
                    case "bi-yearly":
                        F.value = new me("129507");
                        break;
                    case "quarterly":
                        F.value = new me("129507");
                        break;
                    case "monthly":
                        F.value = new me("129507");
                        break;
                    default:
                        F.value = new me("129507")
                }
                R.value = F.value.multipliedBy(r.value).multipliedBy(new me("0.000000001")), P.value = R.value.toFormat(5)
            }

            function ve() {
                o.value = f.value.plus(c.value), s.value = o.value.toFormat(5)
            }

            function X() {
                d.value = new me.sum(N.value, U.value);
                const T = new me(i.value);
                f.value = d.value.multipliedBy(r.value).multipliedBy(new me("0.000000001").multipliedBy(T)), u.value = f.value.toFormat(5)
            }

            function V() {
                l.value = new me.sum(h.value, p.value, g.value, b.value, x.value, w.value, O.value), c.value = l.value.multipliedBy(r.value).multipliedBy(new me("0.000000001")), a.value = c.value.toFormat(5)
            }

            function oe() {
                i.value = 1
            }

            function ae() {
                n.value = 20
            }
            const Ae = {
                    range: {
                        min: 10,
                        max: 150
                    },
                    step: 1
                },
                Fe = {
                    prefix: "",
                    suffix: " gwei",
                    decimals: 0,
                    thousand: ","
                },
                C = {
                    range: {
                        min: 1,
                        max: 100
                    },
                    step: 1
                };
            return (T, z) => (fe(), be("div", LL, [m("div", ML, [FL, m("div", UL, [HL, zL, m("div", jL, [VL, m("div", GL, [m("div", WL, [q(J($r), {
                modelValue: J(n),
                "onUpdate:modelValue": z[0] || (z[0] = Q => pt(n) ? n.value = Q : null),
                options: Ae,
                format: Fe
            }, null, 8, ["modelValue"])]), m("span", {
                class: "ml-2 flex justify-center items-center px-2 py-1 rounded-full text-xs font-medium text-white hover:text-yellow-300 cursor-pointer backdrop-blur-md bg-slate-900/80 text-slate-100 hover:bg-slate-900/90 hover:text-yellow-300",
                onClick: ae
            }, " Reset ")])])]), m("div", QL, [m("div", JL, [KL, m("div", ZL, [m("p", YL, [Ke(ue(s.value) + " ", 1), XL])]), m("div", qL, [$L, m("p", eM, ue(a.value) + " ETH", 1)]), m("div", tM, [nM, m("div", rM, [m("div", iM, [q(J($r), {
                modelValue: J(i),
                "onUpdate:modelValue": z[1] || (z[1] = Q => pt(i) ? i.value = Q : null),
                options: C
            }, null, 8, ["modelValue"])]), m("span", {
                class: "ml-2 flex justify-center items-center px-2 py-1 rounded-full text-xs font-medium text-white hover:text-yellow-300 cursor-pointer backdrop-blur-md bg-slate-900/80 text-slate-100 hover:bg-slate-900/90 hover:text-yellow-300",
                onClick: oe
            }, " Reset ")])]), m("div", sM, [oM, m("p", aM, ue(u.value) + " ETH", 1)])]), m("div", lM, [cM, m("div", uM, [m("p", fM, [Ke(ue(_.value) + " ", 1), dM])]), m("div", hM, [pM, Bt(m("select", {
                id: "frequency",
                "onUpdate:modelValue": z[2] || (z[2] = Q => j.value = Q),
                name: "location",
                class: "mt-1 block w-full rounded-md border-gray-300 py-2 pl-3 pr-10 text-base focus:border-indigo-500 focus:outline-none focus:ring-indigo-500"
            }, bM, 512), [
                [b4, j.value]
            ])]), m("div", wM, [q(NL)]), m("div", xM, [q(DL)]), AM])])])]))
        }
    }),
    _M = {
        class: "responsibilities relative pt-16 pb-20 px-4 sm:px-6 lg:pt-24 lg:pb-28 lg:px-8 overflow-hidden"
    },
    EM = m("div", {
        class: "bg-fx"
    }, null, -1),
    PM = m("div", {
        class: "bg-clouds-bottom"
    }, null, -1),
    SM = m("div", {
        class: "bg-clouds-top"
    }, null, -1),
    NM = {
        class: "relative max-w-7xl text-center sm:text-left mx-auto py-12 px-4 sm:px-6 lg:px-8 lg:py-24 z-20"
    },
    RM = m("div", {
        class: "lg:text-center"
    }, [m("h2", {
        class: "py-2 text-center text-4xl font-extrabold tracking-tight sm:text-5xl bg-gradient-to-r from-pink-100 via-yellow-300 to-yellow-200 bg-clip-text text-transparent leading-8"
    }, " What are my responsibilities as a Rocket Pool node operator? "), m("p", {
        class: "mt-6 max-w-7xl text-xl text-gray-50 mx-auto font-semibold text-center"
    }, "With great power, comes great responsibility.")], -1),
    CM = {
        class: "bg-gray-100 p-6 mt-6 rounded-lg"
    },
    OM = {
        class: "space-y-10 lg:space-y-0 lg:grid lg:grid-cols-3 lg:gap-8"
    },
    TM = {
        class: "flex justify-center"
    },
    BM = {
        class: "flex items-center justify-center h-20 w-20 rounded-full bg-gradient-to-b from-red-500 to-yellow-400 text-white"
    },
    IM = {
        class: "mt-5 text-lg leading-6 font-semibold text-gray-900 text-center"
    },
    DM = {
        class: "mt-2 text-base text-gray-500 text-center px-2"
    },
    LM = m("div", {
        class: "bg-gray-100 p-6 mt-6 rounded-lg"
    }, [m("p", {
        class: "text-lg leading-6 font-semibold text-gray-900"
    }, "Need some help?"), m("p", {
        class: "mt-2 text-gray-500"
    }, " Being a Rocket Pool node operator is a big responsibility, you are responsible for your performance. If you're fairly new to using the command line or computer maintenance, this can seem like a scary challenge. Our guides are packed with walkthroughs, and information that will help you understand how to run a great Rocket Pool node. ")], -1),
    MM = nt({
        __name: "responsibilities",
        setup(t) {
            const e = [{
                name: "Security",
                description: "Safeguard the security of your node, to ensure your funds are safe and you contribute to Ethereum security.",
                icon: ["fas", "key"]
            }, {
                name: "Uptime",
                description: "There are mild penalties for infrequent downtime but to maximise your return you want high uptime.",
                icon: ["fas", "satellite-dish"]
            }, {
                name: "Maintenance",
                description: "Perform regular maintenance and monitoring of your node. Our smart node stack makes this a breeze.",
                icon: ["fas", "wrench"]
            }];
            return (n, r) => {
                const i = Lr("fa");
                return fe(), be("div", _M, [EM, PM, SM, m("div", NM, [RM, m("div", CM, [m("dl", OM, [(fe(), be(Ye, null, xt(e, s => m("div", {
                    key: s.name
                }, [m("dt", null, [m("div", TM, [m("div", BM, [q(i, {
                    icon: s.icon,
                    class: "h-10 w-10",
                    size: "3x",
                    "aria-hidden": "true"
                }, null, 8, ["icon"])])]), m("p", IM, ue(s.name), 1)]), m("dd", DM, ue(s.description), 1)])), 64))])]), LM])])
            }
        }
    }),
    FM = {
        class: "py-20 bg-white"
    },
    UM = {
        class: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"
    },
    HM = m("div", {
        class: "lg:text-center"
    }, [m("h2", {
        class: "py-2 text-center text-4xl font-extrabold tracking-tight sm:text-5xl bg-gradient-to-r from-red-500 via-yellow-400 to-red-400 bg-clip-text text-transparent leading-8"
    }, " Why Rocket Pool vs solo staking? "), m("p", {
        class: "mt-6 max-w-7xl text-xl text-gray-600 mx-auto font-semibold text-center"
    }, "Rocket Pool FTW")], -1),
    zM = {
        class: "mt-10"
    },
    jM = {
        class: "max-w-full mx-auto grid gap-10 sm:gap-20 lg:grid-cols-2 lg:max-w-none"
    },
    VM = m("h3", {
        class: "text-3xl text-gray-600 mx-auto font-semibold text-center my-10"
    }, "It's Easier", -1),
    GM = {
        class: "space-y-10 md:space-y-0 md:grid md:grid-cols-1 md:gap-x-8 md:gap-y-10"
    },
    WM = {
        class: "flex items-center justify-center h-20 w-20 rounded-full border-2 border-yellow-200 text-red-500"
    },
    QM = {
        class: "flex ml-4 text-base text-gray-500 items-center justify-center"
    },
    JM = m("h3", {
        class: "text-3xl text-gray-600 mx-auto font-semibold text-center mt-20 mb-10 sm:my-10"
    }, "You Earn More", -1),
    KM = {
        class: "space-y-10 md:space-y-0 md:grid md:grid-cols-1 md:gap-x-8 md:gap-y-10"
    },
    ZM = {
        class: "flex items-center justify-center h-20 w-20 rounded-full border-2 border-yellow-200 text-red-500"
    },
    YM = {
        class: "flex ml-4 text-base text-gray-500 items-center justify-center"
    },
    XM = nt({
        __name: "rp-vs-solo",
        setup(t) {
            const e = [{
                    description: "Our Smart node software makes setting up an Ethereum node super simple.",
                    icon: ["fas", "laptop-code"]
                }, {
                    description: "Choose from any client and get the same experience.",
                    icon: ["fas", "chart-pie-simple"]
                }, {
                    description: "Our supportive community of node operators will help you develop the confidence to run an Ethereum node.",
                    icon: ["fas", "house-laptop"]
                }],
                n = [{
                    description: "Rewards on your ETH",
                    icon: ["fas", "coins"]
                }, {
                    description: "Commission on ETH you stake for the pool.",
                    icon: ["fas", "circle-dollar"]
                }, {
                    description: "RPL rewards based on how much you stake as collateral.",
                    icon: ["fas", "hand-holding-dollar"]
                }];
            return (r, i) => {
                const s = Lr("fa");
                return fe(), be("div", FM, [m("div", UM, [HM, m("div", zM, [m("div", jM, [m("div", null, [VM, m("dl", GM, [(fe(), be(Ye, null, xt(e, o => m("div", {
                    key: o.name,
                    class: "flex flex-row"
                }, [m("dt", null, [m("div", WM, [q(s, {
                    icon: o.icon,
                    class: "h-10 w-10",
                    size: "3x",
                    "aria-hidden": "true"
                }, null, 8, ["icon"])])]), m("dd", QM, ue(o.description), 1)])), 64))])]), m("div", null, [JM, m("dl", KM, [(fe(), be(Ye, null, xt(n, o => m("div", {
                    key: o.name,
                    class: "flex flex-row"
                }, [m("dt", null, [m("div", ZM, [q(s, {
                    icon: o.icon,
                    class: "h-10 w-10",
                    size: "3x",
                    "aria-hidden": "true"
                }, null, 8, ["icon"])])]), m("dd", YM, ue(o.description), 1)])), 64))])])])])])])
            }
        }
    }),
    qM = {
        class: "relative pt-16 pb-20 px-4 sm:px-6 lg:pt-24 lg:pb-28 lg:px-8 community overflow-hidden"
    },
    $M = m("div", {
        class: "bg-fx"
    }, null, -1),
    eF = m("div", {
        class: "bg-clouds-bottom"
    }, null, -1),
    tF = m("div", {
        class: "bg-clouds-top"
    }, null, -1),
    nF = {
        class: "relative max-w-7xl mx-auto"
    },
    rF = m("div", {
        class: "text-center"
    }, [m("h2", {
        class: "py-2 text-center text-4xl font-extrabold tracking-tight sm:text-5xl bg-gradient-to-r from-pink-200 to-yellow-500 bg-clip-text text-transparent leading-8"
    }, " How do I start with Rocket Pool? "), m("p", {
        class: "mt-3 max-w-7xl mx-auto text-xl text-gray-50 sm:mt-4"
    }, "Let's get you on the path to participating in Ethereum proof-of-stake.")], -1),
    iF = {
        class: "px-4 mt-12 max-w-lg mx-auto grid gap-5 lg:grid-cols-3 lg:max-w-none"
    },
    sF = {
        class: "flex-shrink-0"
    },
    oF = {
        class: "bg-gray-800"
    },
    aF = {
        class: "flex-1 bg-white p-6 flex flex-col justify-between"
    },
    lF = {
        class: "flex-1"
    },
    cF = ["href"],
    uF = {
        class: "text-xl font-semibold text-gray-900"
    },
    fF = {
        class: "mt-3 text-base text-gray-500"
    },
    dF = {
        class: "mt-6 flex items-center justify-center"
    },
    hF = ["href"],
    pF = nt({
        __name: "how",
        setup(t) {
            const e = [{
                title: "Guides",
                href: "https://docs.rocketpool.net/guides/node/responsibilities.html",
                description: "Follow our guides to become a master node operator.",
                imageUrl: ["fas", "file-alt"],
                cta: "Read the guides"
            }, {
                title: "Testnet",
                href: "https://docs.rocketpool.net/guides/testnet/overview.html",
                description: "Practice on our testnet, test your skills and build confidence.",
                imageUrl: ["fas", "flask"],
                cta: "Try the testnet"
            }, {
                title: "Discord",
                href: "https://discord.gg/rocketpool",
                description: "Ask questions, find answers, knowledge up.",
                imageUrl: ["fab", "discord"],
                cta: "Chat on discord"
            }];
            return (n, r) => {
                const i = Lr("fa");
                return fe(), be("div", qM, [$M, eF, tF, m("div", nF, [rF, m("div", iF, [(fe(), be(Ye, null, xt(e, s => m("div", {
                    key: s.title,
                    class: "flex flex-col rounded-lg shadow-lg overflow-hidden"
                }, [m("div", sF, [m("div", oF, [q(i, {
                    icon: s.imageUrl,
                    size: "8x",
                    class: "h-48 w-48 mx-auto p-4 text-white block",
                    "aria-hidden": "true"
                }, null, 8, ["icon"])])]), m("div", aF, [m("div", lF, [m("a", {
                    href: s.href,
                    class: "block mt-2"
                }, [m("p", uF, ue(s.title), 1), m("p", fF, ue(s.description), 1)], 8, cF)]), m("div", dF, [m("a", {
                    href: s.href,
                    target: "_blank",
                    rel: "noreferrer",
                    class: "inline-flex items-center justify-center px-5 py-3 border border-transparent text-base font-semibold rounded-md text-white rp-button"
                }, ue(s.cta), 9, hF)])])])), 64))])])])
            }
        }
    }),
    mF = {
        id: "node-operators"
    },
    gF = nt({
        __name: "node-operators",
        setup(t) {
            return (e, n) => (fe(), be("div", mF, [q(Zp), q(CB), q(xL), q(kM), q(MM), q(XM), q(pF), q(tf)]))
        }
    });

function tx(t, e) {
    return fe(), be("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true"
    }, [m("path", {
        "fill-rule": "evenodd",
        d: "M16.28 11.47a.75.75 0 010 1.06l-7.5 7.5a.75.75 0 01-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 011.06-1.06l7.5 7.5z",
        "clip-rule": "evenodd"
    })])
}
const yF = {
        class: "bg-white"
    },
    vF = {
        class: "max-w-7xl w-full mx-auto px-4 sm:px-6 lg:px-8"
    },
    bF = {
        class: "max-w-xl mx-auto py-16 sm:py-24"
    },
    wF = m("div", {
        class: "text-center"
    }, [m("h2", {
        class: "py-2 text-center text-4xl font-extrabold tracking-tight sm:text-6xl bg-gradient-to-r from-red-500 via-yellow-400 to-red-400 bg-clip-text text-transparent leading-8"
    }, "Error"), m("p", {
        class: "mt-4 max-w-2xl text-xl text-gray-600 lg:mx-auto font-semibold"
    }, "Something didn't go right.")], -1),
    xF = {
        class: "mt-12"
    },
    AF = m("h2", {
        class: "text-sm font-semibold text-gray-500 tracking-wide uppercase"
    }, "Popular pages", -1),
    kF = {
        role: "list",
        class: "mt-4 border-t border-b border-gray-200 divide-y divide-gray-200"
    },
    _F = {
        class: "flex-shrink-0"
    },
    EF = {
        class: "flex items-center justify-center h-12 w-12 rounded-lg bg-purple-50"
    },
    PF = {
        class: "min-w-0 flex-1"
    },
    SF = {
        class: "text-base font-medium text-gray-900"
    },
    NF = {
        class: "rounded-sm"
    },
    RF = ["href"],
    CF = m("span", {
        class: "absolute inset-0",
        "aria-hidden": "true"
    }, null, -1),
    OF = {
        class: "text-base text-gray-500"
    },
    TF = {
        class: "flex-shrink-0 self-center"
    },
    BF = m("div", {
        class: "mt-8"
    }, [m("a", {
        href: "/",
        class: "text-base font-medium text-purple-700 hover:text-purple-800"
    }, [Ke(" Or go back home "), m("span", {
        "aria-hidden": "true"
    }, "")])], -1),
    IF = nt({
        __name: "error",
        setup(t) {
            const e = [{
                title: "How it works",
                description: "Find out more about how Rocket Pool works",
                icon: V2,
                href: "https://docs.rocketpool.net/guides/node/responsibilities.html#how-rocket-pool-nodes-work"
            }, {
                title: "Explainer Series",
                description: "Our explainer series covers all aspects of Rocket Pool",
                icon: H2,
                href: "https://medium.com/rocket-pool/rocket-pool-staking-protocol-part-1-8be4859e5fbd"
            }, {
                title: "Guides & Documentation",
                description: "Installation guides that cover popular setups",
                icon: z2,
                href: "https://docs.rocketpool.net/guides/"
            }, {
                title: "Developers",
                description: "A complete API reference for our libraries",
                icon: j2,
                href: "https://docs.rocketpool.net/developers/"
            }];
            return (n, r) => (fe(), be("div", yF, [m("main", vF, [m("div", bF, [wF, m("div", xF, [AF, m("ul", kF, [(fe(), be(Ye, null, xt(e, (i, s) => m("li", {
                key: s,
                class: "relative py-6 flex items-start space-x-4"
            }, [m("div", _F, [m("span", EF, [(fe(), fi(gv(i.icon), {
                class: "h-6 w-6 text-purple-700",
                "aria-hidden": "true"
            }))])]), m("div", PF, [m("h3", SF, [m("span", NF, [m("a", {
                href: i.href,
                class: "focus:outline-none",
                target: "_blank",
                rel: "noreferrer"
            }, [CF, Ke(" " + ue(i.title), 1)], 8, RF)])]), m("p", OF, ue(i.description), 1)]), m("div", TF, [q(J(tx), {
                class: "h-5 w-5 text-gray-400",
                "aria-hidden": "true"
            })])])), 64))]), BF])])])]))
        }
    }),
    DF = {
        id: "error"
    },
    ey = nt({
        __name: "error",
        setup(t) {
            return (e, n) => (fe(), be("div", DF, [q(Zp), q(IF), q(Wp), q(tf)]))
        }
    }),
    LF = {
        class: "bg-white"
    },
    MF = {
        class: "max-w-7xl w-full mx-auto px-4 sm:px-6 lg:px-8"
    },
    FF = {
        class: "max-w-xl mx-auto py-16 sm:py-24"
    },
    UF = m("div", {
        class: "text-center"
    }, [m("h2", {
        class: "py-2 text-center text-4xl font-extrabold tracking-tight sm:text-6xl bg-gradient-to-r from-red-500 via-yellow-400 to-red-400 bg-clip-text text-transparent leading-8"
    }, " Maintenance "), m("p", {
        class: "mt-4 max-w-2xl text-xl text-gray-600 lg:mx-auto font-semibold"
    }, "Rocket Pool is currently down for maintenance.")], -1),
    HF = {
        class: "mt-12"
    },
    zF = m("h2", {
        class: "text-sm font-semibold text-gray-500 tracking-wide uppercase"
    }, "Popular pages", -1),
    jF = {
        role: "list",
        class: "mt-4 border-t border-b border-gray-200 divide-y divide-gray-200"
    },
    VF = {
        class: "flex-shrink-0"
    },
    GF = {
        class: "flex items-center justify-center h-12 w-12 rounded-lg bg-purple-50"
    },
    WF = {
        class: "min-w-0 flex-1"
    },
    QF = {
        class: "text-base font-medium text-gray-900"
    },
    JF = {
        class: "rounded-sm"
    },
    KF = ["href"],
    ZF = m("span", {
        class: "absolute inset-0",
        "aria-hidden": "true"
    }, null, -1),
    YF = {
        class: "text-base text-gray-500"
    },
    XF = {
        class: "flex-shrink-0 self-center"
    },
    qF = m("div", {
        class: "mt-8"
    }, [m("a", {
        href: "/",
        class: "text-base font-medium text-purple-700 hover:text-purple-800"
    }, [Ke(" Or go back home "), m("span", {
        "aria-hidden": "true"
    }, "")])], -1),
    $F = nt({
        __name: "maintenance",
        setup(t) {
            const e = [{
                title: "How it works",
                description: "Find out more about how Rocket Pool works",
                icon: V2,
                href: "https://docs.rocketpool.net/guides/node/responsibilities.html#how-rocket-pool-nodes-work"
            }, {
                title: "Explainer Series",
                description: "Our explainer series covers all aspects of Rocket Pool",
                icon: H2,
                href: "https://medium.com/rocket-pool/rocket-pool-staking-protocol-part-1-8be4859e5fbd"
            }, {
                title: "Guides & Documenation",
                description: "Installation guides that cover popular setups",
                icon: z2,
                href: "https://docs.rocketpool.net/guides/"
            }, {
                title: "Developers",
                description: "A complete API reference for our libraries",
                icon: j2,
                href: "https://docs.rocketpool.net/developers/"
            }];
            return (n, r) => (fe(), be("div", LF, [m("main", MF, [m("div", FF, [UF, m("div", HF, [zF, m("ul", jF, [(fe(), be(Ye, null, xt(e, (i, s) => m("li", {
                key: s,
                class: "relative py-6 flex items-start space-x-4"
            }, [m("div", VF, [m("span", GF, [(fe(), fi(gv(i.icon), {
                class: "h-6 w-6 text-purple-700",
                "aria-hidden": "true"
            }))])]), m("div", WF, [m("h3", QF, [m("span", JF, [m("a", {
                href: i.href,
                class: "focus:outline-none",
                target: "_blank"
            }, [ZF, Ke(" " + ue(i.title), 1)], 8, KF)])]), m("p", YF, ue(i.description), 1)]), m("div", XF, [q(J(tx), {
                class: "h-5 w-5 text-gray-400",
                "aria-hidden": "true"
            })])])), 64))]), qF])])])]))
        }
    }),
    eU = {
        id: "maintenance"
    },
    tU = nt({
        __name: "maintenance",
        setup(t) {
            return (e, n) => (fe(), be("div", eU, [q(Zp), q($F), q(Wp), q(tf)]))
        }
    }),
    nU = [{
        path: "/",
        component: mB,
        meta: {
            title: "Rocket Pool - Your friendly decentralised Ethereum staking protocol"
        }
    }, {
        path: "/node-operators",
        component: gF,
        meta: {
            title: "Become a Rocket Pool Node Operator"
        }
    }, {
        path: "/node-operator",
        redirect: {
            path: "/node-operators"
        }
    }, {
        path: "/error",
        component: ey,
        meta: {
            title: "Error"
        }
    }, {
        path: "/maintenance",
        component: tU,
        meta: {
            title: "Maintenance"
        }
    }, {
        path: "/:path(.*)",
        component: ey,
        meta: {
            title: "Error"
        }
    }];

function nx(t, e) {
    return function() {
        return t.apply(e, arguments)
    }
}
const {
    toString: rU
} = Object.prototype, {
    getPrototypeOf: im
} = Object, rf = (t => e => {
    const n = rU.call(e);
    return t[n] || (t[n] = n.slice(8, -1).toLowerCase())
})(Object.create(null)), Mr = t => (t = t.toLowerCase(), e => rf(e) === t), sf = t => e => typeof e === t, {
    isArray: $o
} = Array, cl = sf("undefined");

function iU(t) {
    return t !== null && !cl(t) && t.constructor !== null && !cl(t.constructor) && Yn(t.constructor.isBuffer) && t.constructor.isBuffer(t)
}
const rx = Mr("ArrayBuffer");

function sU(t) {
    let e;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && rx(t.buffer), e
}
const oU = sf("string"),
    Yn = sf("function"),
    ix = sf("number"),
    of = t => t !== null && typeof t == "object",
    aU = t => t === !0 || t === !1,
    Hc = t => {
        if (rf(t) !== "object") return !1;
        const e = im(t);
        return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
    },
    lU = Mr("Date"),
    cU = Mr("File"),
    uU = Mr("Blob"),
    fU = Mr("FileList"),
    dU = t => of (t) && Yn(t.pipe),
    hU = t => {
        let e;
        return t && (typeof FormData == "function" && t instanceof FormData || Yn(t.append) && ((e = rf(t)) === "formdata" || e === "object" && Yn(t.toString) && t.toString() === "[object FormData]"))
    },
    pU = Mr("URLSearchParams"),
    mU = t => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");

function Tl(t, e, {
    allOwnKeys: n = !1
} = {}) {
    if (t === null || typeof t > "u") return;
    let r, i;
    if (typeof t != "object" && (t = [t]), $o(t))
        for (r = 0, i = t.length; r < i; r++) e.call(null, t[r], r, t);
    else {
        const s = n ? Object.getOwnPropertyNames(t) : Object.keys(t),
            o = s.length;
        let a;
        for (r = 0; r < o; r++) a = s[r], e.call(null, t[a], a, t)
    }
}

function sx(t, e) {
    e = e.toLowerCase();
    const n = Object.keys(t);
    let r = n.length,
        i;
    for (; r-- > 0;)
        if (i = n[r], e === i.toLowerCase()) return i;
    return null
}
const ox = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(),
    ax = t => !cl(t) && t !== ox;

function Sh() {
    const {
        caseless: t
    } = ax(this) && this || {}, e = {}, n = (r, i) => {
        const s = t && sx(e, i) || i;
        Hc(e[s]) && Hc(r) ? e[s] = Sh(e[s], r) : Hc(r) ? e[s] = Sh({}, r) : $o(r) ? e[s] = r.slice() : e[s] = r
    };
    for (let r = 0, i = arguments.length; r < i; r++) arguments[r] && Tl(arguments[r], n);
    return e
}
const gU = (t, e, n, {
        allOwnKeys: r
    } = {}) => (Tl(e, (i, s) => {
        n && Yn(i) ? t[s] = nx(i, n) : t[s] = i
    }, {
        allOwnKeys: r
    }), t),
    yU = t => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t),
    vU = (t, e, n, r) => {
        t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", {
            value: e.prototype
        }), n && Object.assign(t.prototype, n)
    },
    bU = (t, e, n, r) => {
        let i, s, o;
        const a = {};
        if (e = e || {}, t == null) return e;
        do {
            for (i = Object.getOwnPropertyNames(t), s = i.length; s-- > 0;) o = i[s], (!r || r(o, t, e)) && !a[o] && (e[o] = t[o], a[o] = !0);
            t = n !== !1 && im(t)
        } while (t && (!n || n(t, e)) && t !== Object.prototype);
        return e
    },
    wU = (t, e, n) => {
        t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
        const r = t.indexOf(e, n);
        return r !== -1 && r === n
    },
    xU = t => {
        if (!t) return null;
        if ($o(t)) return t;
        let e = t.length;
        if (!ix(e)) return null;
        const n = new Array(e);
        for (; e-- > 0;) n[e] = t[e];
        return n
    },
    AU = (t => e => t && e instanceof t)(typeof Uint8Array < "u" && im(Uint8Array)),
    kU = (t, e) => {
        const r = (t && t[Symbol.iterator]).call(t);
        let i;
        for (;
            (i = r.next()) && !i.done;) {
            const s = i.value;
            e.call(t, s[0], s[1])
        }
    },
    _U = (t, e) => {
        let n;
        const r = [];
        for (;
            (n = t.exec(e)) !== null;) r.push(n);
        return r
    },
    EU = Mr("HTMLFormElement"),
    PU = t => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(n, r, i) {
        return r.toUpperCase() + i
    }),
    ty = (({
        hasOwnProperty: t
    }) => (e, n) => t.call(e, n))(Object.prototype),
    SU = Mr("RegExp"),
    lx = (t, e) => {
        const n = Object.getOwnPropertyDescriptors(t),
            r = {};
        Tl(n, (i, s) => {
            let o;
            (o = e(i, s, t)) !== !1 && (r[s] = o || i)
        }), Object.defineProperties(t, r)
    },
    NU = t => {
        lx(t, (e, n) => {
            if (Yn(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1) return !1;
            const r = t[n];
            if (Yn(r)) {
                if (e.enumerable = !1, "writable" in e) {
                    e.writable = !1;
                    return
                }
                e.set || (e.set = () => {
                    throw Error("Can not rewrite read-only method '" + n + "'")
                })
            }
        })
    },
    RU = (t, e) => {
        const n = {},
            r = i => {
                i.forEach(s => {
                    n[s] = !0
                })
            };
        return $o(t) ? r(t) : r(String(t).split(e)), n
    },
    CU = () => {},
    OU = (t, e) => (t = +t, Number.isFinite(t) ? t : e),
    wd = "abcdefghijklmnopqrstuvwxyz",
    ny = "0123456789",
    cx = {
        DIGIT: ny,
        ALPHA: wd,
        ALPHA_DIGIT: wd + wd.toUpperCase() + ny
    },
    TU = (t = 16, e = cx.ALPHA_DIGIT) => {
        let n = "";
        const {
            length: r
        } = e;
        for (; t--;) n += e[Math.random() * r | 0];
        return n
    };

function BU(t) {
    return !!(t && Yn(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator])
}
const IU = t => {
        const e = new Array(10),
            n = (r, i) => {
                if ( of (r)) {
                    if (e.indexOf(r) >= 0) return;
                    if (!("toJSON" in r)) {
                        e[i] = r;
                        const s = $o(r) ? [] : {};
                        return Tl(r, (o, a) => {
                            const c = n(o, i + 1);
                            !cl(c) && (s[a] = c)
                        }), e[i] = void 0, s
                    }
                }
                return r
            };
        return n(t, 0)
    },
    DU = Mr("AsyncFunction"),
    LU = t => t && ( of (t) || Yn(t)) && Yn(t.then) && Yn(t.catch),
    ee = {
        isArray: $o,
        isArrayBuffer: rx,
        isBuffer: iU,
        isFormData: hU,
        isArrayBufferView: sU,
        isString: oU,
        isNumber: ix,
        isBoolean: aU,
        isObject: of ,
        isPlainObject: Hc,
        isUndefined: cl,
        isDate: lU,
        isFile: cU,
        isBlob: uU,
        isRegExp: SU,
        isFunction: Yn,
        isStream: dU,
        isURLSearchParams: pU,
        isTypedArray: AU,
        isFileList: fU,
        forEach: Tl,
        merge: Sh,
        extend: gU,
        trim: mU,
        stripBOM: yU,
        inherits: vU,
        toFlatObject: bU,
        kindOf: rf,
        kindOfTest: Mr,
        endsWith: wU,
        toArray: xU,
        forEachEntry: kU,
        matchAll: _U,
        isHTMLForm: EU,
        hasOwnProperty: ty,
        hasOwnProp: ty,
        reduceDescriptors: lx,
        freezeMethods: NU,
        toObjectSet: RU,
        toCamelCase: PU,
        noop: CU,
        toFiniteNumber: OU,
        findKey: sx,
        global: ox,
        isContextDefined: ax,
        ALPHABET: cx,
        generateString: TU,
        isSpecCompliantForm: BU,
        toJSONObject: IU,
        isAsyncFn: DU,
        isThenable: LU
    };

function it(t, e, n, r, i) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), i && (this.response = i)
}
ee.inherits(it, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: ee.toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        }
    }
});
const ux = it.prototype,
    fx = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(t => {
    fx[t] = {
        value: t
    }
});
Object.defineProperties(it, fx);
Object.defineProperty(ux, "isAxiosError", {
    value: !0
});
it.from = (t, e, n, r, i, s) => {
    const o = Object.create(ux);
    return ee.toFlatObject(t, o, function(c) {
        return c !== Error.prototype
    }, a => a !== "isAxiosError"), it.call(o, t.message, e, n, r, i), o.cause = t, o.name = t.name, s && Object.assign(o, s), o
};
const MU = null;

function Nh(t) {
    return ee.isPlainObject(t) || ee.isArray(t)
}

function dx(t) {
    return ee.endsWith(t, "[]") ? t.slice(0, -2) : t
}

function ry(t, e, n) {
    return t ? t.concat(e).map(function(i, s) {
        return i = dx(i), !n && s ? "[" + i + "]" : i
    }).join(n ? "." : "") : e
}

function FU(t) {
    return ee.isArray(t) && !t.some(Nh)
}
const UU = ee.toFlatObject(ee, {}, null, function(e) {
    return /^is[A-Z]/.test(e)
});

function af(t, e, n) {
    if (!ee.isObject(t)) throw new TypeError("target must be an object");
    e = e || new FormData, n = ee.toFlatObject(n, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(g, b) {
        return !ee.isUndefined(b[g])
    });
    const r = n.metaTokens,
        i = n.visitor || u,
        s = n.dots,
        o = n.indexes,
        c = (n.Blob || typeof Blob < "u" && Blob) && ee.isSpecCompliantForm(e);
    if (!ee.isFunction(i)) throw new TypeError("visitor must be a function");

    function l(p) {
        if (p === null) return "";
        if (ee.isDate(p)) return p.toISOString();
        if (!c && ee.isBlob(p)) throw new it("Blob is not supported. Use a Buffer instead.");
        return ee.isArrayBuffer(p) || ee.isTypedArray(p) ? c && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p
    }

    function u(p, g, b) {
        let x = p;
        if (p && !b && typeof p == "object") {
            if (ee.endsWith(g, "{}")) g = r ? g : g.slice(0, -2), p = JSON.stringify(p);
            else if (ee.isArray(p) && FU(p) || (ee.isFileList(p) || ee.endsWith(g, "[]")) && (x = ee.toArray(p))) return g = dx(g), x.forEach(function(O, N) {
                !(ee.isUndefined(O) || O === null) && e.append(o === !0 ? ry([g], N, s) : o === null ? g : g + "[]", l(O))
            }), !1
        }
        return Nh(p) ? !0 : (e.append(ry(b, g, s), l(p)), !1)
    }
    const f = [],
        d = Object.assign(UU, {
            defaultVisitor: u,
            convertValue: l,
            isVisitable: Nh
        });

    function h(p, g) {
        if (!ee.isUndefined(p)) {
            if (f.indexOf(p) !== -1) throw Error("Circular reference detected in " + g.join("."));
            f.push(p), ee.forEach(p, function(x, w) {
                (!(ee.isUndefined(x) || x === null) && i.call(e, x, ee.isString(w) ? w.trim() : w, g, d)) === !0 && h(x, g ? g.concat(w) : [w])
            }), f.pop()
        }
    }
    if (!ee.isObject(t)) throw new TypeError("data must be an object");
    return h(t), e
}

function iy(t) {
    const e = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {
        return e[r]
    })
}

function sm(t, e) {
    this._pairs = [], t && af(t, this, e)
}
const hx = sm.prototype;
hx.append = function(e, n) {
    this._pairs.push([e, n])
};
hx.toString = function(e) {
    const n = e ? function(r) {
        return e.call(this, r, iy)
    } : iy;
    return this._pairs.map(function(i) {
        return n(i[0]) + "=" + n(i[1])
    }, "").join("&")
};

function HU(t) {
    return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}

function px(t, e, n) {
    if (!e) return t;
    const r = n && n.encode || HU,
        i = n && n.serialize;
    let s;
    if (i ? s = i(e, n) : s = ee.isURLSearchParams(e) ? e.toString() : new sm(e, n).toString(r), s) {
        const o = t.indexOf("#");
        o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + s
    }
    return t
}
class zU {
    constructor() {
        this.handlers = []
    }
    use(e, n, r) {
        return this.handlers.push({
            fulfilled: e,
            rejected: n,
            synchronous: r ? r.synchronous : !1,
            runWhen: r ? r.runWhen : null
        }), this.handlers.length - 1
    }
    eject(e) {
        this.handlers[e] && (this.handlers[e] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(e) {
        ee.forEach(this.handlers, function(r) {
            r !== null && e(r)
        })
    }
}
const sy = zU,
    mx = {
        silentJSONParsing: !0,
        forcedJSONParsing: !0,
        clarifyTimeoutError: !1
    },
    jU = typeof URLSearchParams < "u" ? URLSearchParams : sm,
    VU = typeof FormData < "u" ? FormData : null,
    GU = typeof Blob < "u" ? Blob : null,
    WU = {
        isBrowser: !0,
        classes: {
            URLSearchParams: jU,
            FormData: VU,
            Blob: GU
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
    },
    gx = typeof window < "u" && typeof document < "u",
    QU = (t => gx && ["ReactNative", "NativeScript", "NS"].indexOf(t) < 0)(typeof navigator < "u" && navigator.product),
    JU = (() => typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(),
    KU = Object.freeze(Object.defineProperty({
        __proto__: null,
        hasBrowserEnv: gx,
        hasStandardBrowserEnv: QU,
        hasStandardBrowserWebWorkerEnv: JU
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    kr = { ...KU,
        ...WU
    };

function ZU(t, e) {
    return af(t, new kr.classes.URLSearchParams, Object.assign({
        visitor: function(n, r, i, s) {
            return kr.isNode && ee.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments)
        }
    }, e))
}

function YU(t) {
    return ee.matchAll(/\w+|\[(\w*)]/g, t).map(e => e[0] === "[]" ? "" : e[1] || e[0])
}

function XU(t) {
    const e = {},
        n = Object.keys(t);
    let r;
    const i = n.length;
    let s;
    for (r = 0; r < i; r++) s = n[r], e[s] = t[s];
    return e
}

function yx(t) {
    function e(n, r, i, s) {
        let o = n[s++];
        const a = Number.isFinite(+o),
            c = s >= n.length;
        return o = !o && ee.isArray(i) ? i.length : o, c ? (ee.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !a) : ((!i[o] || !ee.isObject(i[o])) && (i[o] = []), e(n, r, i[o], s) && ee.isArray(i[o]) && (i[o] = XU(i[o])), !a)
    }
    if (ee.isFormData(t) && ee.isFunction(t.entries)) {
        const n = {};
        return ee.forEachEntry(t, (r, i) => {
            e(YU(r), i, n, 0)
        }), n
    }
    return null
}

function qU(t, e, n) {
    if (ee.isString(t)) try {
        return (e || JSON.parse)(t), ee.trim(t)
    } catch (r) {
        if (r.name !== "SyntaxError") throw r
    }
    return (n || JSON.stringify)(t)
}
const om = {
    transitional: mx,
    adapter: ["xhr", "http"],
    transformRequest: [function(e, n) {
        const r = n.getContentType() || "",
            i = r.indexOf("application/json") > -1,
            s = ee.isObject(e);
        if (s && ee.isHTMLForm(e) && (e = new FormData(e)), ee.isFormData(e)) return i && i ? JSON.stringify(yx(e)) : e;
        if (ee.isArrayBuffer(e) || ee.isBuffer(e) || ee.isStream(e) || ee.isFile(e) || ee.isBlob(e)) return e;
        if (ee.isArrayBufferView(e)) return e.buffer;
        if (ee.isURLSearchParams(e)) return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
        let a;
        if (s) {
            if (r.indexOf("application/x-www-form-urlencoded") > -1) return ZU(e, this.formSerializer).toString();
            if ((a = ee.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
                const c = this.env && this.env.FormData;
                return af(a ? {
                    "files[]": e
                } : e, c && new c, this.formSerializer)
            }
        }
        return s || i ? (n.setContentType("application/json", !1), qU(e)) : e
    }],
    transformResponse: [function(e) {
        const n = this.transitional || om.transitional,
            r = n && n.forcedJSONParsing,
            i = this.responseType === "json";
        if (e && ee.isString(e) && (r && !this.responseType || i)) {
            const o = !(n && n.silentJSONParsing) && i;
            try {
                return JSON.parse(e)
            } catch (a) {
                if (o) throw a.name === "SyntaxError" ? it.from(a, it.ERR_BAD_RESPONSE, this, null, this.response) : a
            }
        }
        return e
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: kr.classes.FormData,
        Blob: kr.classes.Blob
    },
    validateStatus: function(e) {
        return e >= 200 && e < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
ee.forEach(["delete", "get", "head", "post", "put", "patch"], t => {
    om.headers[t] = {}
});
const am = om,
    $U = ee.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
    eH = t => {
        const e = {};
        let n, r, i;
        return t && t.split(`
`).forEach(function(o) {
            i = o.indexOf(":"), n = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!n || e[n] && $U[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r)
        }), e
    },
    oy = Symbol("internals");

function da(t) {
    return t && String(t).trim().toLowerCase()
}

function zc(t) {
    return t === !1 || t == null ? t : ee.isArray(t) ? t.map(zc) : String(t)
}

function tH(t) {
    const e = Object.create(null),
        n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let r;
    for (; r = n.exec(t);) e[r[1]] = r[2];
    return e
}
const nH = t => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());

function xd(t, e, n, r, i) {
    if (ee.isFunction(r)) return r.call(this, e, n);
    if (i && (e = n), !!ee.isString(e)) {
        if (ee.isString(r)) return e.indexOf(r) !== -1;
        if (ee.isRegExp(r)) return r.test(e)
    }
}

function rH(t) {
    return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r)
}

function iH(t, e) {
    const n = ee.toCamelCase(" " + e);
    ["get", "set", "has"].forEach(r => {
        Object.defineProperty(t, r + n, {
            value: function(i, s, o) {
                return this[r].call(this, e, i, s, o)
            },
            configurable: !0
        })
    })
}
class lf {
    constructor(e) {
        e && this.set(e)
    }
    set(e, n, r) {
        const i = this;

        function s(a, c, l) {
            const u = da(c);
            if (!u) throw new Error("header name must be a non-empty string");
            const f = ee.findKey(i, u);
            (!f || i[f] === void 0 || l === !0 || l === void 0 && i[f] !== !1) && (i[f || c] = zc(a))
        }
        const o = (a, c) => ee.forEach(a, (l, u) => s(l, u, c));
        return ee.isPlainObject(e) || e instanceof this.constructor ? o(e, n) : ee.isString(e) && (e = e.trim()) && !nH(e) ? o(eH(e), n) : e != null && s(n, e, r), this
    }
    get(e, n) {
        if (e = da(e), e) {
            const r = ee.findKey(this, e);
            if (r) {
                const i = this[r];
                if (!n) return i;
                if (n === !0) return tH(i);
                if (ee.isFunction(n)) return n.call(this, i, r);
                if (ee.isRegExp(n)) return n.exec(i);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(e, n) {
        if (e = da(e), e) {
            const r = ee.findKey(this, e);
            return !!(r && this[r] !== void 0 && (!n || xd(this, this[r], r, n)))
        }
        return !1
    }
    delete(e, n) {
        const r = this;
        let i = !1;

        function s(o) {
            if (o = da(o), o) {
                const a = ee.findKey(r, o);
                a && (!n || xd(r, r[a], a, n)) && (delete r[a], i = !0)
            }
        }
        return ee.isArray(e) ? e.forEach(s) : s(e), i
    }
    clear(e) {
        const n = Object.keys(this);
        let r = n.length,
            i = !1;
        for (; r--;) {
            const s = n[r];
            (!e || xd(this, this[s], s, e, !0)) && (delete this[s], i = !0)
        }
        return i
    }
    normalize(e) {
        const n = this,
            r = {};
        return ee.forEach(this, (i, s) => {
            const o = ee.findKey(r, s);
            if (o) {
                n[o] = zc(i), delete n[s];
                return
            }
            const a = e ? rH(s) : String(s).trim();
            a !== s && delete n[s], n[a] = zc(i), r[a] = !0
        }), this
    }
    concat(...e) {
        return this.constructor.concat(this, ...e)
    }
    toJSON(e) {
        const n = Object.create(null);
        return ee.forEach(this, (r, i) => {
            r != null && r !== !1 && (n[i] = e && ee.isArray(r) ? r.join(", ") : r)
        }), n
    }[Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`)
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(e) {
        return e instanceof this ? e : new this(e)
    }
    static concat(e, ...n) {
        const r = new this(e);
        return n.forEach(i => r.set(i)), r
    }
    static accessor(e) {
        const r = (this[oy] = this[oy] = {
                accessors: {}
            }).accessors,
            i = this.prototype;

        function s(o) {
            const a = da(o);
            r[a] || (iH(i, o), r[a] = !0)
        }
        return ee.isArray(e) ? e.forEach(s) : s(e), this
    }
}
lf.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ee.reduceDescriptors(lf.prototype, ({
    value: t
}, e) => {
    let n = e[0].toUpperCase() + e.slice(1);
    return {
        get: () => t,
        set(r) {
            this[n] = r
        }
    }
});
ee.freezeMethods(lf);
const ri = lf;

function Ad(t, e) {
    const n = this || am,
        r = e || n,
        i = ri.from(r.headers);
    let s = r.data;
    return ee.forEach(t, function(a) {
        s = a.call(n, s, i.normalize(), e ? e.status : void 0)
    }), i.normalize(), s
}

function vx(t) {
    return !!(t && t.__CANCEL__)
}

function Bl(t, e, n) {
    it.call(this, t ? ? "canceled", it.ERR_CANCELED, e, n), this.name = "CanceledError"
}
ee.inherits(Bl, it, {
    __CANCEL__: !0
});

function sH(t, e, n) {
    const r = n.config.validateStatus;
    !n.status || !r || r(n.status) ? t(n) : e(new it("Request failed with status code " + n.status, [it.ERR_BAD_REQUEST, it.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n))
}
const oH = kr.hasStandardBrowserEnv ? {
    write(t, e, n, r, i, s) {
        const o = [t + "=" + encodeURIComponent(e)];
        ee.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), ee.isString(r) && o.push("path=" + r), ee.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ")
    },
    read(t) {
        const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
        return e ? decodeURIComponent(e[3]) : null
    },
    remove(t) {
        this.write(t, "", Date.now() - 864e5)
    }
} : {
    write() {},
    read() {
        return null
    },
    remove() {}
};

function aH(t) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)
}

function lH(t, e) {
    return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t
}

function bx(t, e) {
    return t && !aH(e) ? lH(t, e) : e
}
const cH = kr.hasStandardBrowserEnv ? function() {
    const e = /(msie|trident)/i.test(navigator.userAgent),
        n = document.createElement("a");
    let r;

    function i(s) {
        let o = s;
        return e && (n.setAttribute("href", o), o = n.href), n.setAttribute("href", o), {
            href: n.href,
            protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
            host: n.host,
            search: n.search ? n.search.replace(/^\?/, "") : "",
            hash: n.hash ? n.hash.replace(/^#/, "") : "",
            hostname: n.hostname,
            port: n.port,
            pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
        }
    }
    return r = i(window.location.href),
        function(o) {
            const a = ee.isString(o) ? i(o) : o;
            return a.protocol === r.protocol && a.host === r.host
        }
}() : function() {
    return function() {
        return !0
    }
}();

function uH(t) {
    const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
    return e && e[1] || ""
}

function fH(t, e) {
    t = t || 10;
    const n = new Array(t),
        r = new Array(t);
    let i = 0,
        s = 0,
        o;
    return e = e !== void 0 ? e : 1e3,
        function(c) {
            const l = Date.now(),
                u = r[s];
            o || (o = l), n[i] = c, r[i] = l;
            let f = s,
                d = 0;
            for (; f !== i;) d += n[f++], f = f % t;
            if (i = (i + 1) % t, i === s && (s = (s + 1) % t), l - o < e) return;
            const h = u && l - u;
            return h ? Math.round(d * 1e3 / h) : void 0
        }
}

function ay(t, e) {
    let n = 0;
    const r = fH(50, 250);
    return i => {
        const s = i.loaded,
            o = i.lengthComputable ? i.total : void 0,
            a = s - n,
            c = r(a),
            l = s <= o;
        n = s;
        const u = {
            loaded: s,
            total: o,
            progress: o ? s / o : void 0,
            bytes: a,
            rate: c || void 0,
            estimated: c && o && l ? (o - s) / c : void 0,
            event: i
        };
        u[e ? "download" : "upload"] = !0, t(u)
    }
}
const dH = typeof XMLHttpRequest < "u",
    hH = dH && function(t) {
        return new Promise(function(n, r) {
            let i = t.data;
            const s = ri.from(t.headers).normalize();
            let {
                responseType: o,
                withXSRFToken: a
            } = t, c;

            function l() {
                t.cancelToken && t.cancelToken.unsubscribe(c), t.signal && t.signal.removeEventListener("abort", c)
            }
            let u;
            if (ee.isFormData(i)) {
                if (kr.hasStandardBrowserEnv || kr.hasStandardBrowserWebWorkerEnv) s.setContentType(!1);
                else if ((u = s.getContentType()) !== !1) {
                    const [g, ...b] = u ? u.split(";").map(x => x.trim()).filter(Boolean) : [];
                    s.setContentType([g || "multipart/form-data", ...b].join("; "))
                }
            }
            let f = new XMLHttpRequest;
            if (t.auth) {
                const g = t.auth.username || "",
                    b = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : "";
                s.set("Authorization", "Basic " + btoa(g + ":" + b))
            }
            const d = bx(t.baseURL, t.url);
            f.open(t.method.toUpperCase(), px(d, t.params, t.paramsSerializer), !0), f.timeout = t.timeout;

            function h() {
                if (!f) return;
                const g = ri.from("getAllResponseHeaders" in f && f.getAllResponseHeaders()),
                    x = {
                        data: !o || o === "text" || o === "json" ? f.responseText : f.response,
                        status: f.status,
                        statusText: f.statusText,
                        headers: g,
                        config: t,
                        request: f
                    };
                sH(function(O) {
                    n(O), l()
                }, function(O) {
                    r(O), l()
                }, x), f = null
            }
            if ("onloadend" in f ? f.onloadend = h : f.onreadystatechange = function() {
                    !f || f.readyState !== 4 || f.status === 0 && !(f.responseURL && f.responseURL.indexOf("file:") === 0) || setTimeout(h)
                }, f.onabort = function() {
                    f && (r(new it("Request aborted", it.ECONNABORTED, t, f)), f = null)
                }, f.onerror = function() {
                    r(new it("Network Error", it.ERR_NETWORK, t, f)), f = null
                }, f.ontimeout = function() {
                    let b = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
                    const x = t.transitional || mx;
                    t.timeoutErrorMessage && (b = t.timeoutErrorMessage), r(new it(b, x.clarifyTimeoutError ? it.ETIMEDOUT : it.ECONNABORTED, t, f)), f = null
                }, kr.hasStandardBrowserEnv && (a && ee.isFunction(a) && (a = a(t)), a || a !== !1 && cH(d))) {
                const g = t.xsrfHeaderName && t.xsrfCookieName && oH.read(t.xsrfCookieName);
                g && s.set(t.xsrfHeaderName, g)
            }
            i === void 0 && s.setContentType(null), "setRequestHeader" in f && ee.forEach(s.toJSON(), function(b, x) {
                f.setRequestHeader(x, b)
            }), ee.isUndefined(t.withCredentials) || (f.withCredentials = !!t.withCredentials), o && o !== "json" && (f.responseType = t.responseType), typeof t.onDownloadProgress == "function" && f.addEventListener("progress", ay(t.onDownloadProgress, !0)), typeof t.onUploadProgress == "function" && f.upload && f.upload.addEventListener("progress", ay(t.onUploadProgress)), (t.cancelToken || t.signal) && (c = g => {
                f && (r(!g || g.type ? new Bl(null, t, f) : g), f.abort(), f = null)
            }, t.cancelToken && t.cancelToken.subscribe(c), t.signal && (t.signal.aborted ? c() : t.signal.addEventListener("abort", c)));
            const p = uH(d);
            if (p && kr.protocols.indexOf(p) === -1) {
                r(new it("Unsupported protocol " + p + ":", it.ERR_BAD_REQUEST, t));
                return
            }
            f.send(i || null)
        })
    },
    Rh = {
        http: MU,
        xhr: hH
    };
ee.forEach(Rh, (t, e) => {
    if (t) {
        try {
            Object.defineProperty(t, "name", {
                value: e
            })
        } catch {}
        Object.defineProperty(t, "adapterName", {
            value: e
        })
    }
});
const ly = t => `- ${t}`,
    pH = t => ee.isFunction(t) || t === null || t === !1,
    wx = {
        getAdapter: t => {
            t = ee.isArray(t) ? t : [t];
            const {
                length: e
            } = t;
            let n, r;
            const i = {};
            for (let s = 0; s < e; s++) {
                n = t[s];
                let o;
                if (r = n, !pH(n) && (r = Rh[(o = String(n)).toLowerCase()], r === void 0)) throw new it(`Unknown adapter '${o}'`);
                if (r) break;
                i[o || "#" + s] = r
            }
            if (!r) {
                const s = Object.entries(i).map(([a, c]) => `adapter ${a} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build"));
                let o = e ? s.length > 1 ? `since :
` + s.map(ly).join(`
`) : " " + ly(s[0]) : "as no adapter specified";
                throw new it("There is no suitable adapter to dispatch the request " + o, "ERR_NOT_SUPPORT")
            }
            return r
        },
        adapters: Rh
    };

function kd(t) {
    if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new Bl(null, t)
}

function cy(t) {
    return kd(t), t.headers = ri.from(t.headers), t.data = Ad.call(t, t.transformRequest), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), wx.getAdapter(t.adapter || am.adapter)(t).then(function(r) {
        return kd(t), r.data = Ad.call(t, t.transformResponse, r), r.headers = ri.from(r.headers), r
    }, function(r) {
        return vx(r) || (kd(t), r && r.response && (r.response.data = Ad.call(t, t.transformResponse, r.response), r.response.headers = ri.from(r.response.headers))), Promise.reject(r)
    })
}
const uy = t => t instanceof ri ? t.toJSON() : t;

function Go(t, e) {
    e = e || {};
    const n = {};

    function r(l, u, f) {
        return ee.isPlainObject(l) && ee.isPlainObject(u) ? ee.merge.call({
            caseless: f
        }, l, u) : ee.isPlainObject(u) ? ee.merge({}, u) : ee.isArray(u) ? u.slice() : u
    }

    function i(l, u, f) {
        if (ee.isUndefined(u)) {
            if (!ee.isUndefined(l)) return r(void 0, l, f)
        } else return r(l, u, f)
    }

    function s(l, u) {
        if (!ee.isUndefined(u)) return r(void 0, u)
    }

    function o(l, u) {
        if (ee.isUndefined(u)) {
            if (!ee.isUndefined(l)) return r(void 0, l)
        } else return r(void 0, u)
    }

    function a(l, u, f) {
        if (f in e) return r(l, u);
        if (f in t) return r(void 0, l)
    }
    const c = {
        url: s,
        method: s,
        data: s,
        baseURL: o,
        transformRequest: o,
        transformResponse: o,
        paramsSerializer: o,
        timeout: o,
        timeoutMessage: o,
        withCredentials: o,
        withXSRFToken: o,
        adapter: o,
        responseType: o,
        xsrfCookieName: o,
        xsrfHeaderName: o,
        onUploadProgress: o,
        onDownloadProgress: o,
        decompress: o,
        maxContentLength: o,
        maxBodyLength: o,
        beforeRedirect: o,
        transport: o,
        httpAgent: o,
        httpsAgent: o,
        cancelToken: o,
        socketPath: o,
        responseEncoding: o,
        validateStatus: a,
        headers: (l, u) => i(uy(l), uy(u), !0)
    };
    return ee.forEach(Object.keys(Object.assign({}, t, e)), function(u) {
        const f = c[u] || i,
            d = f(t[u], e[u], u);
        ee.isUndefined(d) && f !== a || (n[u] = d)
    }), n
}
const xx = "1.6.2",
    lm = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
    lm[t] = function(r) {
        return typeof r === t || "a" + (e < 1 ? "n " : " ") + t
    }
});
const fy = {};
lm.transitional = function(e, n, r) {
    function i(s, o) {
        return "[Axios v" + xx + "] Transitional option '" + s + "'" + o + (r ? ". " + r : "")
    }
    return (s, o, a) => {
        if (e === !1) throw new it(i(o, " has been removed" + (n ? " in " + n : "")), it.ERR_DEPRECATED);
        return n && !fy[o] && (fy[o] = !0, console.warn(i(o, " has been deprecated since v" + n + " and will be removed in the near future"))), e ? e(s, o, a) : !0
    }
};

function mH(t, e, n) {
    if (typeof t != "object") throw new it("options must be an object", it.ERR_BAD_OPTION_VALUE);
    const r = Object.keys(t);
    let i = r.length;
    for (; i-- > 0;) {
        const s = r[i],
            o = e[s];
        if (o) {
            const a = t[s],
                c = a === void 0 || o(a, s, t);
            if (c !== !0) throw new it("option " + s + " must be " + c, it.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (n !== !0) throw new it("Unknown option " + s, it.ERR_BAD_OPTION)
    }
}
const Ch = {
        assertOptions: mH,
        validators: lm
    },
    _i = Ch.validators;
class gu {
    constructor(e) {
        this.defaults = e, this.interceptors = {
            request: new sy,
            response: new sy
        }
    }
    request(e, n) {
        typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = Go(this.defaults, n);
        const {
            transitional: r,
            paramsSerializer: i,
            headers: s
        } = n;
        r !== void 0 && Ch.assertOptions(r, {
            silentJSONParsing: _i.transitional(_i.boolean),
            forcedJSONParsing: _i.transitional(_i.boolean),
            clarifyTimeoutError: _i.transitional(_i.boolean)
        }, !1), i != null && (ee.isFunction(i) ? n.paramsSerializer = {
            serialize: i
        } : Ch.assertOptions(i, {
            encode: _i.function,
            serialize: _i.function
        }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
        let o = s && ee.merge(s.common, s[n.method]);
        s && ee.forEach(["delete", "get", "head", "post", "put", "patch", "common"], p => {
            delete s[p]
        }), n.headers = ri.concat(o, s);
        const a = [];
        let c = !0;
        this.interceptors.request.forEach(function(g) {
            typeof g.runWhen == "function" && g.runWhen(n) === !1 || (c = c && g.synchronous, a.unshift(g.fulfilled, g.rejected))
        });
        const l = [];
        this.interceptors.response.forEach(function(g) {
            l.push(g.fulfilled, g.rejected)
        });
        let u, f = 0,
            d;
        if (!c) {
            const p = [cy.bind(this), void 0];
            for (p.unshift.apply(p, a), p.push.apply(p, l), d = p.length, u = Promise.resolve(n); f < d;) u = u.then(p[f++], p[f++]);
            return u
        }
        d = a.length;
        let h = n;
        for (f = 0; f < d;) {
            const p = a[f++],
                g = a[f++];
            try {
                h = p(h)
            } catch (b) {
                g.call(this, b);
                break
            }
        }
        try {
            u = cy.call(this, h)
        } catch (p) {
            return Promise.reject(p)
        }
        for (f = 0, d = l.length; f < d;) u = u.then(l[f++], l[f++]);
        return u
    }
    getUri(e) {
        e = Go(this.defaults, e);
        const n = bx(e.baseURL, e.url);
        return px(n, e.params, e.paramsSerializer)
    }
}
ee.forEach(["delete", "get", "head", "options"], function(e) {
    gu.prototype[e] = function(n, r) {
        return this.request(Go(r || {}, {
            method: e,
            url: n,
            data: (r || {}).data
        }))
    }
});
ee.forEach(["post", "put", "patch"], function(e) {
    function n(r) {
        return function(s, o, a) {
            return this.request(Go(a || {}, {
                method: e,
                headers: r ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: s,
                data: o
            }))
        }
    }
    gu.prototype[e] = n(), gu.prototype[e + "Form"] = n(!0)
});
const jc = gu;
class cm {
    constructor(e) {
        if (typeof e != "function") throw new TypeError("executor must be a function.");
        let n;
        this.promise = new Promise(function(s) {
            n = s
        });
        const r = this;
        this.promise.then(i => {
            if (!r._listeners) return;
            let s = r._listeners.length;
            for (; s-- > 0;) r._listeners[s](i);
            r._listeners = null
        }), this.promise.then = i => {
            let s;
            const o = new Promise(a => {
                r.subscribe(a), s = a
            }).then(i);
            return o.cancel = function() {
                r.unsubscribe(s)
            }, o
        }, e(function(s, o, a) {
            r.reason || (r.reason = new Bl(s, o, a), n(r.reason))
        })
    }
    throwIfRequested() {
        if (this.reason) throw this.reason
    }
    subscribe(e) {
        if (this.reason) {
            e(this.reason);
            return
        }
        this._listeners ? this._listeners.push(e) : this._listeners = [e]
    }
    unsubscribe(e) {
        if (!this._listeners) return;
        const n = this._listeners.indexOf(e);
        n !== -1 && this._listeners.splice(n, 1)
    }
    static source() {
        let e;
        return {
            token: new cm(function(i) {
                e = i
            }),
            cancel: e
        }
    }
}
const gH = cm;

function yH(t) {
    return function(n) {
        return t.apply(null, n)
    }
}

function vH(t) {
    return ee.isObject(t) && t.isAxiosError === !0
}
const Oh = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(Oh).forEach(([t, e]) => {
    Oh[e] = t
});
const bH = Oh;

function Ax(t) {
    const e = new jc(t),
        n = nx(jc.prototype.request, e);
    return ee.extend(n, jc.prototype, e, {
        allOwnKeys: !0
    }), ee.extend(n, e, null, {
        allOwnKeys: !0
    }), n.create = function(i) {
        return Ax(Go(t, i))
    }, n
}
const Gt = Ax(am);
Gt.Axios = jc;
Gt.CanceledError = Bl;
Gt.CancelToken = gH;
Gt.isCancel = vx;
Gt.VERSION = xx;
Gt.toFormData = af;
Gt.AxiosError = it;
Gt.Cancel = Gt.CanceledError;
Gt.all = function(e) {
    return Promise.all(e)
};
Gt.spread = yH;
Gt.isAxiosError = vH;
Gt.mergeConfig = Go;
Gt.AxiosHeaders = ri;
Gt.formToJSON = t => yx(ee.isHTMLForm(t) ? new FormData(t) : t);
Gt.getAdapter = wx.getAdapter;
Gt.HttpStatusCode = bH;
Gt.default = Gt;
const wH = Gt,
    xH = () => {
        console.log(`
  /**
   *       .
   *      / \\
   *     |.'.|
   *     |'.'|
   *   ,'|   |'.
   *  |,-'-|-'-.|
   *   __|_| |         _        _      _____           _
   *  | ___ \\|        | |      | |    | ___ \\         | |
   *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |
   *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |
   *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |
   *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|
   * +---------------------------------------------------+
   * |    DECENTRALISED STAKING PROTOCOL FOR ETHEREUM    |
   * +---------------------------------------------------+
   *
   *  Rocket Pool is a first-of-its-kind Ethereum staking pool protocol, designed to
   *  be community-owned, decentralised, and trustless.
   *
   *  For more information about Rocket Pool, visit https://rocketpool.net
   *
   *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty, Nick Ashley
   *
   */
 `)
    };
var kx = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r()
    })(_2, function() {
        return function(n) {
            var r = {};

            function i(s) {
                if (r[s]) return r[s].exports;
                var o = r[s] = {
                    i: s,
                    l: !1,
                    exports: {}
                };
                return n[s].call(o.exports, o, o.exports, i), o.l = !0, o.exports
            }
            return i.m = n, i.c = r, i.d = function(s, o, a) {
                i.o(s, o) || Object.defineProperty(s, o, {
                    enumerable: !0,
                    get: a
                })
            }, i.r = function(s) {
                typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(s, Symbol.toStringTag, {
                    value: "Module"
                }), Object.defineProperty(s, "__esModule", {
                    value: !0
                })
            }, i.t = function(s, o) {
                if (1 & o && (s = i(s)), 8 & o || 4 & o && typeof s == "object" && s && s.__esModule) return s;
                var a = Object.create(null);
                if (i.r(a), Object.defineProperty(a, "default", {
                        enumerable: !0,
                        value: s
                    }), 2 & o && typeof s != "string")
                    for (var c in s) i.d(a, c, function(l) {
                        return s[l]
                    }.bind(null, c));
                return a
            }, i.n = function(s) {
                var o = s && s.__esModule ? function() {
                    return s.default
                } : function() {
                    return s
                };
                return i.d(o, "a", o), o
            }, i.o = function(s, o) {
                return Object.prototype.hasOwnProperty.call(s, o)
            }, i.p = "", i(i.s = 0)
        }([function(n, r, i) {
            function s(p, g, b) {
                return g in p ? Object.defineProperty(p, g, {
                    value: b,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : p[g] = b, p
            }

            function o(p) {
                return (o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
                    return typeof g
                } : function(g) {
                    return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g
                })(p)
            }
            var a;

            function c(p) {
                return p < .5 ? 4 * p * p * p : (p - 1) * (2 * p - 2) * (2 * p - 2) + 1
            }
            i.r(r), i.d(r, "vSmoothScroll", function() {
                return h
            });

            function l() {
                return {
                    duration: 500,
                    offset: 0,
                    container: typeof window > "u" ? null : window,
                    updateHistory: !0,
                    easingFunction: null
                }
            }
            var u = Symbol("smoothScrollCtx");

            function f(p) {
                var g = p.scrollTo,
                    b = p.offset,
                    x = p.duration,
                    w = p.container,
                    O = p.updateHistory,
                    N = p.hash,
                    U = p.easingFunction;
                a || (a = window.requestAnimationFrame || function(E) {
                    window.setTimeout(E, 16)
                }), O && window.history.pushState && location.hash !== N && window.history.pushState("", "", N);
                var H, M, y = w.scrollTop || window.pageYOffset,
                    v = (M = y, (H = g).nodeName === "HTML" ? -M : H.getBoundingClientRect().top + M);
                v += b;
                var A = Date.now();
                (function E() {
                    var P = Date.now() - A,
                        R = v;
                    P < x ? (R = y + (v - y) * (typeof U == "function" && U || c)(P / x), a(E)) : O && location.replace("#" + g.id), w === window ? w.scrollTo(0, R) : w.scrollTop = R
                })()
            }
            var d = {
                install: function(p, g) {
                    var b, x = p.version[0] === "3",
                        w = g ? Object.assign(l(), g) : l();
                    p.directive("smooth-scroll", (s(b = {}, x ? "mounted" : "inserted", function(O, N, U) {
                        if ((typeof window > "u" ? "undefined" : o(window)) === "object" && window.pageYOffset !== void 0) {
                            var H = N.value || {},
                                M = H.duration,
                                y = H.offset,
                                v = H.container,
                                A = H.updateHistory,
                                E = H.easingFunction;
                            M = M || w.duration, y = y || w.offset, v = v || w.container, A = A !== void 0 ? A : w.updateHistory, E = E || w.easingFunction, typeof v == "string" && (v = document.querySelector(v));
                            var P = function(R) {
                                R.preventDefault();
                                var F = x ? U.props.href : U.data.attrs.href,
                                    _ = document.getElementById(F.substring(1));
                                _ && f({
                                    scrollTo: _,
                                    offset: y,
                                    duration: M,
                                    container: v,
                                    updateHistory: A,
                                    hash: F,
                                    easingFunction: E
                                })
                            };
                            O.addEventListener("click", P), O[u] = {
                                clickHandler: P
                            }
                        }
                    }), s(b, x ? "unmounted" : "unbind", function(O) {
                        O.removeEventListener("click", O[u].clickHandler), O[u] = null
                    }), b)), (x ? p.config.globalProperties : p.prototype).$smoothScroll = function(O) {
                        return f(Object.assign(l(), g, O))
                    }
                }
            };
            r.default = d;
            var h = f
        }])
    })
})(kx);
var AH = kx.exports;
const kH = E2(AH);

function dy(t, e) {
    var n = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(t);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(t, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function Pe(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e] != null ? arguments[e] : {};
        e % 2 ? dy(Object(n), !0).forEach(function(r) {
            Kt(t, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : dy(Object(n)).forEach(function(r) {
            Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return t
}

function yu(t) {
    "@babel/helpers - typeof";
    return yu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    } : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }, yu(t)
}

function _H(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function hy(t, e) {
    for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
    }
}

function EH(t, e, n) {
    return e && hy(t.prototype, e), n && hy(t, n), Object.defineProperty(t, "prototype", {
        writable: !1
    }), t
}

function Kt(t, e, n) {
    return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n, t
}

function um(t, e) {
    return SH(t) || RH(t, e) || _x(t, e) || OH()
}

function Il(t) {
    return PH(t) || NH(t) || _x(t) || CH()
}

function PH(t) {
    if (Array.isArray(t)) return Th(t)
}

function SH(t) {
    if (Array.isArray(t)) return t
}

function NH(t) {
    if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t)
}

function RH(t, e) {
    var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
    if (n != null) {
        var r = [],
            i = !0,
            s = !1,
            o, a;
        try {
            for (n = n.call(t); !(i = (o = n.next()).done) && (r.push(o.value), !(e && r.length === e)); i = !0);
        } catch (c) {
            s = !0, a = c
        } finally {
            try {
                !i && n.return != null && n.return()
            } finally {
                if (s) throw a
            }
        }
        return r
    }
}

function _x(t, e) {
    if (t) {
        if (typeof t == "string") return Th(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Th(t, e)
    }
}

function Th(t, e) {
    (e == null || e > t.length) && (e = t.length);
    for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
    return r
}

function CH() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function OH() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
var py = function() {},
    fm = {},
    Ex = {},
    Px = null,
    Sx = {
        mark: py,
        measure: py
    };
try {
    typeof window < "u" && (fm = window), typeof document < "u" && (Ex = document), typeof MutationObserver < "u" && (Px = MutationObserver), typeof performance < "u" && (Sx = performance)
} catch {}
var TH = fm.navigator || {},
    my = TH.userAgent,
    gy = my === void 0 ? "" : my,
    Gi = fm,
    kt = Ex,
    yy = Px,
    wc = Sx;
Gi.document;
var hi = !!kt.documentElement && !!kt.head && typeof kt.addEventListener == "function" && typeof kt.createElement == "function",
    Nx = ~gy.indexOf("MSIE") || ~gy.indexOf("Trident/"),
    xc, Ac, kc, _c, Ec, ai = "___FONT_AWESOME___",
    Bh = 16,
    Rx = "fa",
    Cx = "svg-inline--fa",
    Ls = "data-fa-i2svg",
    Ih = "data-fa-pseudo-element",
    BH = "data-fa-pseudo-element-pending",
    dm = "data-prefix",
    hm = "data-icon",
    vy = "fontawesome-i2svg",
    IH = "async",
    DH = ["HTML", "HEAD", "STYLE", "SCRIPT"],
    Ox = function() {
        try {
            return !0
        } catch {
            return !1
        }
    }(),
    At = "classic",
    Lt = "sharp",
    pm = [At, Lt];

function Dl(t) {
    return new Proxy(t, {
        get: function(n, r) {
            return r in n ? n[r] : n[At]
        }
    })
}
var ul = Dl((xc = {}, Kt(xc, At, {
        fa: "solid",
        fas: "solid",
        "fa-solid": "solid",
        far: "regular",
        "fa-regular": "regular",
        fal: "light",
        "fa-light": "light",
        fat: "thin",
        "fa-thin": "thin",
        fad: "duotone",
        "fa-duotone": "duotone",
        fab: "brands",
        "fa-brands": "brands",
        fak: "kit",
        "fa-kit": "kit"
    }), Kt(xc, Lt, {
        fa: "solid",
        fass: "solid",
        "fa-solid": "solid",
        fasr: "regular",
        "fa-regular": "regular",
        fasl: "light",
        "fa-light": "light"
    }), xc)),
    fl = Dl((Ac = {}, Kt(Ac, At, {
        solid: "fas",
        regular: "far",
        light: "fal",
        thin: "fat",
        duotone: "fad",
        brands: "fab",
        kit: "fak"
    }), Kt(Ac, Lt, {
        solid: "fass",
        regular: "fasr",
        light: "fasl"
    }), Ac)),
    dl = Dl((kc = {}, Kt(kc, At, {
        fab: "fa-brands",
        fad: "fa-duotone",
        fak: "fa-kit",
        fal: "fa-light",
        far: "fa-regular",
        fas: "fa-solid",
        fat: "fa-thin"
    }), Kt(kc, Lt, {
        fass: "fa-solid",
        fasr: "fa-regular",
        fasl: "fa-light"
    }), kc)),
    LH = Dl((_c = {}, Kt(_c, At, {
        "fa-brands": "fab",
        "fa-duotone": "fad",
        "fa-kit": "fak",
        "fa-light": "fal",
        "fa-regular": "far",
        "fa-solid": "fas",
        "fa-thin": "fat"
    }), Kt(_c, Lt, {
        "fa-solid": "fass",
        "fa-regular": "fasr",
        "fa-light": "fasl"
    }), _c)),
    MH = /fa(s|r|l|t|d|b|k|ss|sr|sl)?[\-\ ]/,
    Tx = "fa-layers-text",
    FH = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp|Kit)?.*/i,
    UH = Dl((Ec = {}, Kt(Ec, At, {
        900: "fas",
        400: "far",
        normal: "far",
        300: "fal",
        100: "fat"
    }), Kt(Ec, Lt, {
        900: "fass",
        400: "fasr",
        300: "fasl"
    }), Ec)),
    Bx = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    HH = Bx.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]),
    zH = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"],
    ws = {
        GROUP: "duotone-group",
        SWAP_OPACITY: "swap-opacity",
        PRIMARY: "primary",
        SECONDARY: "secondary"
    },
    hl = new Set;
Object.keys(fl[At]).map(hl.add.bind(hl));
Object.keys(fl[Lt]).map(hl.add.bind(hl));
var jH = [].concat(pm, Il(hl), ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", ws.GROUP, ws.SWAP_OPACITY, ws.PRIMARY, ws.SECONDARY]).concat(Bx.map(function(t) {
        return "".concat(t, "x")
    })).concat(HH.map(function(t) {
        return "w-".concat(t)
    })),
    Da = Gi.FontAwesomeConfig || {};

function VH(t) {
    var e = kt.querySelector("script[" + t + "]");
    if (e) return e.getAttribute(t)
}

function GH(t) {
    return t === "" ? !0 : t === "false" ? !1 : t === "true" ? !0 : t
}
if (kt && typeof kt.querySelector == "function") {
    var WH = [
        ["data-family-prefix", "familyPrefix"],
        ["data-css-prefix", "cssPrefix"],
        ["data-family-default", "familyDefault"],
        ["data-style-default", "styleDefault"],
        ["data-replacement-class", "replacementClass"],
        ["data-auto-replace-svg", "autoReplaceSvg"],
        ["data-auto-add-css", "autoAddCss"],
        ["data-auto-a11y", "autoA11y"],
        ["data-search-pseudo-elements", "searchPseudoElements"],
        ["data-observe-mutations", "observeMutations"],
        ["data-mutate-approach", "mutateApproach"],
        ["data-keep-original-source", "keepOriginalSource"],
        ["data-measure-performance", "measurePerformance"],
        ["data-show-missing-icons", "showMissingIcons"]
    ];
    WH.forEach(function(t) {
        var e = um(t, 2),
            n = e[0],
            r = e[1],
            i = GH(VH(n));
        i != null && (Da[r] = i)
    })
}
var Ix = {
    styleDefault: "solid",
    familyDefault: "classic",
    cssPrefix: Rx,
    replacementClass: Cx,
    autoReplaceSvg: !0,
    autoAddCss: !0,
    autoA11y: !0,
    searchPseudoElements: !1,
    observeMutations: !0,
    mutateApproach: "async",
    keepOriginalSource: !0,
    measurePerformance: !1,
    showMissingIcons: !0
};
Da.familyPrefix && (Da.cssPrefix = Da.familyPrefix);
var Wo = Pe(Pe({}, Ix), Da);
Wo.autoReplaceSvg || (Wo.observeMutations = !1);
var Re = {};
Object.keys(Ix).forEach(function(t) {
    Object.defineProperty(Re, t, {
        enumerable: !0,
        set: function(n) {
            Wo[t] = n, La.forEach(function(r) {
                return r(Re)
            })
        },
        get: function() {
            return Wo[t]
        }
    })
});
Object.defineProperty(Re, "familyPrefix", {
    enumerable: !0,
    set: function(e) {
        Wo.cssPrefix = e, La.forEach(function(n) {
            return n(Re)
        })
    },
    get: function() {
        return Wo.cssPrefix
    }
});
Gi.FontAwesomeConfig = Re;
var La = [];

function QH(t) {
    return La.push(t),
        function() {
            La.splice(La.indexOf(t), 1)
        }
}
var Ei = Bh,
    _r = {
        size: 16,
        x: 0,
        y: 0,
        rotate: 0,
        flipX: !1,
        flipY: !1
    };

function JH(t) {
    if (!(!t || !hi)) {
        var e = kt.createElement("style");
        e.setAttribute("type", "text/css"), e.innerHTML = t;
        for (var n = kt.head.childNodes, r = null, i = n.length - 1; i > -1; i--) {
            var s = n[i],
                o = (s.tagName || "").toUpperCase();
            ["STYLE", "LINK"].indexOf(o) > -1 && (r = s)
        }
        return kt.head.insertBefore(e, r), t
    }
}
var KH = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

function pl() {
    for (var t = 12, e = ""; t-- > 0;) e += KH[Math.random() * 62 | 0];
    return e
}

function ea(t) {
    for (var e = [], n = (t || []).length >>> 0; n--;) e[n] = t[n];
    return e
}

function mm(t) {
    return t.classList ? ea(t.classList) : (t.getAttribute("class") || "").split(" ").filter(function(e) {
        return e
    })
}

function Dx(t) {
    return "".concat(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
}

function ZH(t) {
    return Object.keys(t || {}).reduce(function(e, n) {
        return e + "".concat(n, '="').concat(Dx(t[n]), '" ')
    }, "").trim()
}

function cf(t) {
    return Object.keys(t || {}).reduce(function(e, n) {
        return e + "".concat(n, ": ").concat(t[n].trim(), ";")
    }, "")
}

function gm(t) {
    return t.size !== _r.size || t.x !== _r.x || t.y !== _r.y || t.rotate !== _r.rotate || t.flipX || t.flipY
}

function YH(t) {
    var e = t.transform,
        n = t.containerWidth,
        r = t.iconWidth,
        i = {
            transform: "translate(".concat(n / 2, " 256)")
        },
        s = "translate(".concat(e.x * 32, ", ").concat(e.y * 32, ") "),
        o = "scale(".concat(e.size / 16 * (e.flipX ? -1 : 1), ", ").concat(e.size / 16 * (e.flipY ? -1 : 1), ") "),
        a = "rotate(".concat(e.rotate, " 0 0)"),
        c = {
            transform: "".concat(s, " ").concat(o, " ").concat(a)
        },
        l = {
            transform: "translate(".concat(r / 2 * -1, " -256)")
        };
    return {
        outer: i,
        inner: c,
        path: l
    }
}

function XH(t) {
    var e = t.transform,
        n = t.width,
        r = n === void 0 ? Bh : n,
        i = t.height,
        s = i === void 0 ? Bh : i,
        o = t.startCentered,
        a = o === void 0 ? !1 : o,
        c = "";
    return a && Nx ? c += "translate(".concat(e.x / Ei - r / 2, "em, ").concat(e.y / Ei - s / 2, "em) ") : a ? c += "translate(calc(-50% + ".concat(e.x / Ei, "em), calc(-50% + ").concat(e.y / Ei, "em)) ") : c += "translate(".concat(e.x / Ei, "em, ").concat(e.y / Ei, "em) "), c += "scale(".concat(e.size / Ei * (e.flipX ? -1 : 1), ", ").concat(e.size / Ei * (e.flipY ? -1 : 1), ") "), c += "rotate(".concat(e.rotate, "deg) "), c
}
var qH = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Solid";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Regular";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Light";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Thin";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-counter-scale, 0.25));
          transform: scale(var(--fa-counter-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom right;
          transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: bottom left;
          transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  -webkit-transform: scale(var(--fa-layers-scale, 0.25));
          transform: scale(var(--fa-layers-scale, 0.25));
  -webkit-transform-origin: top left;
          transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(var(--fa-li-width, 2em) * -1);
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  -webkit-animation-name: fa-beat;
          animation-name: fa-beat;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  -webkit-animation-name: fa-bounce;
          animation-name: fa-bounce;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  -webkit-animation-name: fa-fade;
          animation-name: fa-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  -webkit-animation-name: fa-beat-fade;
          animation-name: fa-beat-fade;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
          animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  -webkit-animation-name: fa-flip;
          animation-name: fa-flip;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, ease-in-out);
          animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  -webkit-animation-name: fa-shake;
          animation-name: fa-shake;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-delay: var(--fa-animation-delay, 0s);
          animation-delay: var(--fa-animation-delay, 0s);
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 2s);
          animation-duration: var(--fa-animation-duration, 2s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, linear);
          animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  -webkit-animation-name: fa-spin;
          animation-name: fa-spin;
  -webkit-animation-direction: var(--fa-animation-direction, normal);
          animation-direction: var(--fa-animation-direction, normal);
  -webkit-animation-duration: var(--fa-animation-duration, 1s);
          animation-duration: var(--fa-animation-duration, 1s);
  -webkit-animation-iteration-count: var(--fa-animation-iteration-count, infinite);
          animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));
          animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    -webkit-animation-delay: -1ms;
            animation-delay: -1ms;
    -webkit-animation-duration: 1ms;
            animation-duration: 1ms;
    -webkit-animation-iteration-count: 1;
            animation-iteration-count: 1;
    -webkit-transition-delay: 0s;
            transition-delay: 0s;
    -webkit-transition-duration: 0s;
            transition-duration: 0s;
  }
}
@-webkit-keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-beat {
  0%, 90% {
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  45% {
    -webkit-transform: scale(var(--fa-beat-scale, 1.25));
            transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@-webkit-keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-bounce {
  0% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  10% {
    -webkit-transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
            transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    -webkit-transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
            transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    -webkit-transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
            transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    -webkit-transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
            transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
  100% {
    -webkit-transform: scale(1, 1) translateY(0);
            transform: scale(1, 1) translateY(0);
  }
}
@-webkit-keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@-webkit-keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    -webkit-transform: scale(1);
            transform: scale(1);
  }
  50% {
    opacity: 1;
    -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
            transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@-webkit-keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-flip {
  50% {
    -webkit-transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
            transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@-webkit-keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@keyframes fa-shake {
  0% {
    -webkit-transform: rotate(-15deg);
            transform: rotate(-15deg);
  }
  4% {
    -webkit-transform: rotate(15deg);
            transform: rotate(15deg);
  }
  8%, 24% {
    -webkit-transform: rotate(-18deg);
            transform: rotate(-18deg);
  }
  12%, 28% {
    -webkit-transform: rotate(18deg);
            transform: rotate(18deg);
  }
  16% {
    -webkit-transform: rotate(-22deg);
            transform: rotate(-22deg);
  }
  20% {
    -webkit-transform: rotate(22deg);
            transform: rotate(22deg);
  }
  32% {
    -webkit-transform: rotate(-12deg);
            transform: rotate(-12deg);
  }
  36% {
    -webkit-transform: rotate(12deg);
            transform: rotate(12deg);
  }
  40%, 100% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
}
@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  -webkit-transform: rotate(90deg);
          transform: rotate(90deg);
}

.fa-rotate-180 {
  -webkit-transform: rotate(180deg);
          transform: rotate(180deg);
}

.fa-rotate-270 {
  -webkit-transform: rotate(270deg);
          transform: rotate(270deg);
}

.fa-flip-horizontal {
  -webkit-transform: scale(-1, 1);
          transform: scale(-1, 1);
}

.fa-flip-vertical {
  -webkit-transform: scale(1, -1);
          transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  -webkit-transform: scale(-1, -1);
          transform: scale(-1, -1);
}

.fa-rotate-by {
  -webkit-transform: rotate(var(--fa-rotate-angle, none));
          transform: rotate(var(--fa-rotate-angle, none));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.fad.fa-inverse,
.fa-duotone.fa-inverse {
  color: var(--fa-inverse, #fff);
}`;

function Lx() {
    var t = Rx,
        e = Cx,
        n = Re.cssPrefix,
        r = Re.replacementClass,
        i = qH;
    if (n !== t || r !== e) {
        var s = new RegExp("\\.".concat(t, "\\-"), "g"),
            o = new RegExp("\\--".concat(t, "\\-"), "g"),
            a = new RegExp("\\.".concat(e), "g");
        i = i.replace(s, ".".concat(n, "-")).replace(o, "--".concat(n, "-")).replace(a, ".".concat(r))
    }
    return i
}
var by = !1;

function _d() {
    Re.autoAddCss && !by && (JH(Lx()), by = !0)
}
var $H = {
        mixout: function() {
            return {
                dom: {
                    css: Lx,
                    insertCss: _d
                }
            }
        },
        hooks: function() {
            return {
                beforeDOMElementCreation: function() {
                    _d()
                },
                beforeI2svg: function() {
                    _d()
                }
            }
        }
    },
    li = Gi || {};
li[ai] || (li[ai] = {});
li[ai].styles || (li[ai].styles = {});
li[ai].hooks || (li[ai].hooks = {});
li[ai].shims || (li[ai].shims = []);
var lr = li[ai],
    Mx = [],
    ez = function t() {
        kt.removeEventListener("DOMContentLoaded", t), vu = 1, Mx.map(function(e) {
            return e()
        })
    },
    vu = !1;
hi && (vu = (kt.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(kt.readyState), vu || kt.addEventListener("DOMContentLoaded", ez));

function tz(t) {
    hi && (vu ? setTimeout(t, 0) : Mx.push(t))
}

function Ll(t) {
    var e = t.tag,
        n = t.attributes,
        r = n === void 0 ? {} : n,
        i = t.children,
        s = i === void 0 ? [] : i;
    return typeof t == "string" ? Dx(t) : "<".concat(e, " ").concat(ZH(r), ">").concat(s.map(Ll).join(""), "</").concat(e, ">")
}

function wy(t, e, n) {
    if (t && t[e] && t[e][n]) return {
        prefix: e,
        iconName: n,
        icon: t[e][n]
    }
}
var nz = function(e, n) {
        return function(r, i, s, o) {
            return e.call(n, r, i, s, o)
        }
    },
    Ed = function(e, n, r, i) {
        var s = Object.keys(e),
            o = s.length,
            a = i !== void 0 ? nz(n, i) : n,
            c, l, u;
        for (r === void 0 ? (c = 1, u = e[s[0]]) : (c = 0, u = r); c < o; c++) l = s[c], u = a(u, e[l], l, e);
        return u
    };

function rz(t) {
    for (var e = [], n = 0, r = t.length; n < r;) {
        var i = t.charCodeAt(n++);
        if (i >= 55296 && i <= 56319 && n < r) {
            var s = t.charCodeAt(n++);
            (s & 64512) == 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i), n--)
        } else e.push(i)
    }
    return e
}

function Dh(t) {
    var e = rz(t);
    return e.length === 1 ? e[0].toString(16) : null
}

function iz(t, e) {
    var n = t.length,
        r = t.charCodeAt(e),
        i;
    return r >= 55296 && r <= 56319 && n > e + 1 && (i = t.charCodeAt(e + 1), i >= 56320 && i <= 57343) ? (r - 55296) * 1024 + i - 56320 + 65536 : r
}

function xy(t) {
    return Object.keys(t).reduce(function(e, n) {
        var r = t[n],
            i = !!r.icon;
        return i ? e[r.iconName] = r.icon : e[n] = r, e
    }, {})
}

function Lh(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        r = n.skipHooks,
        i = r === void 0 ? !1 : r,
        s = xy(e);
    typeof lr.hooks.addPack == "function" && !i ? lr.hooks.addPack(t, xy(e)) : lr.styles[t] = Pe(Pe({}, lr.styles[t] || {}), s), t === "fas" && Lh("fa", e)
}
var Pc, Sc, Nc, po = lr.styles,
    sz = lr.shims,
    oz = (Pc = {}, Kt(Pc, At, Object.values(dl[At])), Kt(Pc, Lt, Object.values(dl[Lt])), Pc),
    ym = null,
    Fx = {},
    Ux = {},
    Hx = {},
    zx = {},
    jx = {},
    az = (Sc = {}, Kt(Sc, At, Object.keys(ul[At])), Kt(Sc, Lt, Object.keys(ul[Lt])), Sc);

function lz(t) {
    return ~jH.indexOf(t)
}

function cz(t, e) {
    var n = e.split("-"),
        r = n[0],
        i = n.slice(1).join("-");
    return r === t && i !== "" && !lz(i) ? i : null
}
var Vx = function() {
    var e = function(s) {
        return Ed(po, function(o, a, c) {
            return o[c] = Ed(a, s, {}), o
        }, {})
    };
    Fx = e(function(i, s, o) {
        if (s[3] && (i[s[3]] = o), s[2]) {
            var a = s[2].filter(function(c) {
                return typeof c == "number"
            });
            a.forEach(function(c) {
                i[c.toString(16)] = o
            })
        }
        return i
    }), Ux = e(function(i, s, o) {
        if (i[o] = o, s[2]) {
            var a = s[2].filter(function(c) {
                return typeof c == "string"
            });
            a.forEach(function(c) {
                i[c] = o
            })
        }
        return i
    }), jx = e(function(i, s, o) {
        var a = s[2];
        return i[o] = o, a.forEach(function(c) {
            i[c] = o
        }), i
    });
    var n = "far" in po || Re.autoFetchSvg,
        r = Ed(sz, function(i, s) {
            var o = s[0],
                a = s[1],
                c = s[2];
            return a === "far" && !n && (a = "fas"), typeof o == "string" && (i.names[o] = {
                prefix: a,
                iconName: c
            }), typeof o == "number" && (i.unicodes[o.toString(16)] = {
                prefix: a,
                iconName: c
            }), i
        }, {
            names: {},
            unicodes: {}
        });
    Hx = r.names, zx = r.unicodes, ym = uf(Re.styleDefault, {
        family: Re.familyDefault
    })
};
QH(function(t) {
    ym = uf(t.styleDefault, {
        family: Re.familyDefault
    })
});
Vx();

function vm(t, e) {
    return (Fx[t] || {})[e]
}

function uz(t, e) {
    return (Ux[t] || {})[e]
}

function xs(t, e) {
    return (jx[t] || {})[e]
}

function Gx(t) {
    return Hx[t] || {
        prefix: null,
        iconName: null
    }
}

function fz(t) {
    var e = zx[t],
        n = vm("fas", t);
    return e || (n ? {
        prefix: "fas",
        iconName: n
    } : null) || {
        prefix: null,
        iconName: null
    }
}

function Wi() {
    return ym
}
var bm = function() {
    return {
        prefix: null,
        iconName: null,
        rest: []
    }
};

function uf(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        n = e.family,
        r = n === void 0 ? At : n,
        i = ul[r][t],
        s = fl[r][t] || fl[r][i],
        o = t in lr.styles ? t : null;
    return s || o || null
}
var Ay = (Nc = {}, Kt(Nc, At, Object.keys(dl[At])), Kt(Nc, Lt, Object.keys(dl[Lt])), Nc);

function ff(t) {
    var e, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        r = n.skipLookups,
        i = r === void 0 ? !1 : r,
        s = (e = {}, Kt(e, At, "".concat(Re.cssPrefix, "-").concat(At)), Kt(e, Lt, "".concat(Re.cssPrefix, "-").concat(Lt)), e),
        o = null,
        a = At;
    (t.includes(s[At]) || t.some(function(l) {
        return Ay[At].includes(l)
    })) && (a = At), (t.includes(s[Lt]) || t.some(function(l) {
        return Ay[Lt].includes(l)
    })) && (a = Lt);
    var c = t.reduce(function(l, u) {
        var f = cz(Re.cssPrefix, u);
        if (po[u] ? (u = oz[a].includes(u) ? LH[a][u] : u, o = u, l.prefix = u) : az[a].indexOf(u) > -1 ? (o = u, l.prefix = uf(u, {
                family: a
            })) : f ? l.iconName = f : u !== Re.replacementClass && u !== s[At] && u !== s[Lt] && l.rest.push(u), !i && l.prefix && l.iconName) {
            var d = o === "fa" ? Gx(l.iconName) : {},
                h = xs(l.prefix, l.iconName);
            d.prefix && (o = null), l.iconName = d.iconName || h || l.iconName, l.prefix = d.prefix || l.prefix, l.prefix === "far" && !po.far && po.fas && !Re.autoFetchSvg && (l.prefix = "fas")
        }
        return l
    }, bm());
    return (t.includes("fa-brands") || t.includes("fab")) && (c.prefix = "fab"), (t.includes("fa-duotone") || t.includes("fad")) && (c.prefix = "fad"), !c.prefix && a === Lt && (po.fass || Re.autoFetchSvg) && (c.prefix = "fass", c.iconName = xs(c.prefix, c.iconName) || c.iconName), (c.prefix === "fa" || o === "fa") && (c.prefix = Wi() || "fas"), c
}
var dz = function() {
        function t() {
            _H(this, t), this.definitions = {}
        }
        return EH(t, [{
            key: "add",
            value: function() {
                for (var n = this, r = arguments.length, i = new Array(r), s = 0; s < r; s++) i[s] = arguments[s];
                var o = i.reduce(this._pullDefinitions, {});
                Object.keys(o).forEach(function(a) {
                    n.definitions[a] = Pe(Pe({}, n.definitions[a] || {}), o[a]), Lh(a, o[a]);
                    var c = dl[At][a];
                    c && Lh(c, o[a]), Vx()
                })
            }
        }, {
            key: "reset",
            value: function() {
                this.definitions = {}
            }
        }, {
            key: "_pullDefinitions",
            value: function(n, r) {
                var i = r.prefix && r.iconName && r.icon ? {
                    0: r
                } : r;
                return Object.keys(i).map(function(s) {
                    var o = i[s],
                        a = o.prefix,
                        c = o.iconName,
                        l = o.icon,
                        u = l[2];
                    n[a] || (n[a] = {}), u.length > 0 && u.forEach(function(f) {
                        typeof f == "string" && (n[a][f] = l)
                    }), n[a][c] = l
                }), n
            }
        }]), t
    }(),
    ky = [],
    mo = {},
    Eo = {},
    hz = Object.keys(Eo);

function pz(t, e) {
    var n = e.mixoutsTo;
    return ky = t, mo = {}, Object.keys(Eo).forEach(function(r) {
        hz.indexOf(r) === -1 && delete Eo[r]
    }), ky.forEach(function(r) {
        var i = r.mixout ? r.mixout() : {};
        if (Object.keys(i).forEach(function(o) {
                typeof i[o] == "function" && (n[o] = i[o]), yu(i[o]) === "object" && Object.keys(i[o]).forEach(function(a) {
                    n[o] || (n[o] = {}), n[o][a] = i[o][a]
                })
            }), r.hooks) {
            var s = r.hooks();
            Object.keys(s).forEach(function(o) {
                mo[o] || (mo[o] = []), mo[o].push(s[o])
            })
        }
        r.provides && r.provides(Eo)
    }), n
}

function Mh(t, e) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++) r[i - 2] = arguments[i];
    var s = mo[t] || [];
    return s.forEach(function(o) {
        e = o.apply(null, [e].concat(r))
    }), e
}

function Ms(t) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
    var i = mo[t] || [];
    i.forEach(function(s) {
        s.apply(null, n)
    })
}

function ci() {
    var t = arguments[0],
        e = Array.prototype.slice.call(arguments, 1);
    return Eo[t] ? Eo[t].apply(null, e) : void 0
}

function Fh(t) {
    t.prefix === "fa" && (t.prefix = "fas");
    var e = t.iconName,
        n = t.prefix || Wi();
    if (e) return e = xs(n, e) || e, wy(Wx.definitions, n, e) || wy(lr.styles, n, e)
}
var Wx = new dz,
    mz = function() {
        Re.autoReplaceSvg = !1, Re.observeMutations = !1, Ms("noAuto")
    },
    gz = {
        i2svg: function() {
            var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return hi ? (Ms("beforeI2svg", e), ci("pseudoElements2svg", e), ci("i2svg", e)) : Promise.reject("Operation requires a DOM of some kind.")
        },
        watch: function() {
            var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
                n = e.autoReplaceSvgRoot;
            Re.autoReplaceSvg === !1 && (Re.autoReplaceSvg = !0), Re.observeMutations = !0, tz(function() {
                vz({
                    autoReplaceSvgRoot: n
                }), Ms("watch", e)
            })
        }
    },
    yz = {
        icon: function(e) {
            if (e === null) return null;
            if (yu(e) === "object" && e.prefix && e.iconName) return {
                prefix: e.prefix,
                iconName: xs(e.prefix, e.iconName) || e.iconName
            };
            if (Array.isArray(e) && e.length === 2) {
                var n = e[1].indexOf("fa-") === 0 ? e[1].slice(3) : e[1],
                    r = uf(e[0]);
                return {
                    prefix: r,
                    iconName: xs(r, n) || n
                }
            }
            if (typeof e == "string" && (e.indexOf("".concat(Re.cssPrefix, "-")) > -1 || e.match(MH))) {
                var i = ff(e.split(" "), {
                    skipLookups: !0
                });
                return {
                    prefix: i.prefix || Wi(),
                    iconName: xs(i.prefix, i.iconName) || i.iconName
                }
            }
            if (typeof e == "string") {
                var s = Wi();
                return {
                    prefix: s,
                    iconName: xs(s, e) || e
                }
            }
        }
    },
    Bn = {
        noAuto: mz,
        config: Re,
        dom: gz,
        parse: yz,
        library: Wx,
        findIconDefinition: Fh,
        toHtml: Ll
    },
    vz = function() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            n = e.autoReplaceSvgRoot,
            r = n === void 0 ? kt : n;
        (Object.keys(lr.styles).length > 0 || Re.autoFetchSvg) && hi && Re.autoReplaceSvg && Bn.dom.i2svg({
            node: r
        })
    };

function df(t, e) {
    return Object.defineProperty(t, "abstract", {
        get: e
    }), Object.defineProperty(t, "html", {
        get: function() {
            return t.abstract.map(function(r) {
                return Ll(r)
            })
        }
    }), Object.defineProperty(t, "node", {
        get: function() {
            if (hi) {
                var r = kt.createElement("div");
                return r.innerHTML = t.html, r.children
            }
        }
    }), t
}

function bz(t) {
    var e = t.children,
        n = t.main,
        r = t.mask,
        i = t.attributes,
        s = t.styles,
        o = t.transform;
    if (gm(o) && n.found && !r.found) {
        var a = n.width,
            c = n.height,
            l = {
                x: a / c / 2,
                y: .5
            };
        i.style = cf(Pe(Pe({}, s), {}, {
            "transform-origin": "".concat(l.x + o.x / 16, "em ").concat(l.y + o.y / 16, "em")
        }))
    }
    return [{
        tag: "svg",
        attributes: i,
        children: e
    }]
}

function wz(t) {
    var e = t.prefix,
        n = t.iconName,
        r = t.children,
        i = t.attributes,
        s = t.symbol,
        o = s === !0 ? "".concat(e, "-").concat(Re.cssPrefix, "-").concat(n) : s;
    return [{
        tag: "svg",
        attributes: {
            style: "display: none;"
        },
        children: [{
            tag: "symbol",
            attributes: Pe(Pe({}, i), {}, {
                id: o
            }),
            children: r
        }]
    }]
}

function wm(t) {
    var e = t.icons,
        n = e.main,
        r = e.mask,
        i = t.prefix,
        s = t.iconName,
        o = t.transform,
        a = t.symbol,
        c = t.title,
        l = t.maskId,
        u = t.titleId,
        f = t.extra,
        d = t.watchable,
        h = d === void 0 ? !1 : d,
        p = r.found ? r : n,
        g = p.width,
        b = p.height,
        x = i === "fak",
        w = [Re.replacementClass, s ? "".concat(Re.cssPrefix, "-").concat(s) : ""].filter(function(v) {
            return f.classes.indexOf(v) === -1
        }).filter(function(v) {
            return v !== "" || !!v
        }).concat(f.classes).join(" "),
        O = {
            children: [],
            attributes: Pe(Pe({}, f.attributes), {}, {
                "data-prefix": i,
                "data-icon": s,
                class: w,
                role: f.attributes.role || "img",
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: "0 0 ".concat(g, " ").concat(b)
            })
        },
        N = x && !~f.classes.indexOf("fa-fw") ? {
            width: "".concat(g / b * 16 * .0625, "em")
        } : {};
    h && (O.attributes[Ls] = ""), c && (O.children.push({
        tag: "title",
        attributes: {
            id: O.attributes["aria-labelledby"] || "title-".concat(u || pl())
        },
        children: [c]
    }), delete O.attributes.title);
    var U = Pe(Pe({}, O), {}, {
            prefix: i,
            iconName: s,
            main: n,
            mask: r,
            maskId: l,
            transform: o,
            symbol: a,
            styles: Pe(Pe({}, N), f.styles)
        }),
        H = r.found && n.found ? ci("generateAbstractMask", U) || {
            children: [],
            attributes: {}
        } : ci("generateAbstractIcon", U) || {
            children: [],
            attributes: {}
        },
        M = H.children,
        y = H.attributes;
    return U.children = M, U.attributes = y, a ? wz(U) : bz(U)
}

function _y(t) {
    var e = t.content,
        n = t.width,
        r = t.height,
        i = t.transform,
        s = t.title,
        o = t.extra,
        a = t.watchable,
        c = a === void 0 ? !1 : a,
        l = Pe(Pe(Pe({}, o.attributes), s ? {
            title: s
        } : {}), {}, {
            class: o.classes.join(" ")
        });
    c && (l[Ls] = "");
    var u = Pe({}, o.styles);
    gm(i) && (u.transform = XH({
        transform: i,
        startCentered: !0,
        width: n,
        height: r
    }), u["-webkit-transform"] = u.transform);
    var f = cf(u);
    f.length > 0 && (l.style = f);
    var d = [];
    return d.push({
        tag: "span",
        attributes: l,
        children: [e]
    }), s && d.push({
        tag: "span",
        attributes: {
            class: "sr-only"
        },
        children: [s]
    }), d
}

function xz(t) {
    var e = t.content,
        n = t.title,
        r = t.extra,
        i = Pe(Pe(Pe({}, r.attributes), n ? {
            title: n
        } : {}), {}, {
            class: r.classes.join(" ")
        }),
        s = cf(r.styles);
    s.length > 0 && (i.style = s);
    var o = [];
    return o.push({
        tag: "span",
        attributes: i,
        children: [e]
    }), n && o.push({
        tag: "span",
        attributes: {
            class: "sr-only"
        },
        children: [n]
    }), o
}
var Pd = lr.styles;

function Uh(t) {
    var e = t[0],
        n = t[1],
        r = t.slice(4),
        i = um(r, 1),
        s = i[0],
        o = null;
    return Array.isArray(s) ? o = {
        tag: "g",
        attributes: {
            class: "".concat(Re.cssPrefix, "-").concat(ws.GROUP)
        },
        children: [{
            tag: "path",
            attributes: {
                class: "".concat(Re.cssPrefix, "-").concat(ws.SECONDARY),
                fill: "currentColor",
                d: s[0]
            }
        }, {
            tag: "path",
            attributes: {
                class: "".concat(Re.cssPrefix, "-").concat(ws.PRIMARY),
                fill: "currentColor",
                d: s[1]
            }
        }]
    } : o = {
        tag: "path",
        attributes: {
            fill: "currentColor",
            d: s
        }
    }, {
        found: !0,
        width: e,
        height: n,
        icon: o
    }
}
var Az = {
    found: !1,
    width: 512,
    height: 512
};

function kz(t, e) {
    !Ox && !Re.showMissingIcons && t && console.error('Icon with name "'.concat(t, '" and prefix "').concat(e, '" is missing.'))
}

function Hh(t, e) {
    var n = e;
    return e === "fa" && Re.styleDefault !== null && (e = Wi()), new Promise(function(r, i) {
        if (ci("missingIconAbstract"), n === "fa") {
            var s = Gx(t) || {};
            t = s.iconName || t, e = s.prefix || e
        }
        if (t && e && Pd[e] && Pd[e][t]) {
            var o = Pd[e][t];
            return r(Uh(o))
        }
        kz(t, e), r(Pe(Pe({}, Az), {}, {
            icon: Re.showMissingIcons && t ? ci("missingIconAbstract") || {} : {}
        }))
    })
}
var Ey = function() {},
    zh = Re.measurePerformance && wc && wc.mark && wc.measure ? wc : {
        mark: Ey,
        measure: Ey
    },
    wa = 'FA "6.4.2"',
    _z = function(e) {
        return zh.mark("".concat(wa, " ").concat(e, " begins")),
            function() {
                return Qx(e)
            }
    },
    Qx = function(e) {
        zh.mark("".concat(wa, " ").concat(e, " ends")), zh.measure("".concat(wa, " ").concat(e), "".concat(wa, " ").concat(e, " begins"), "".concat(wa, " ").concat(e, " ends"))
    },
    xm = {
        begin: _z,
        end: Qx
    },
    Vc = function() {};

function Py(t) {
    var e = t.getAttribute ? t.getAttribute(Ls) : null;
    return typeof e == "string"
}

function Ez(t) {
    var e = t.getAttribute ? t.getAttribute(dm) : null,
        n = t.getAttribute ? t.getAttribute(hm) : null;
    return e && n
}

function Pz(t) {
    return t && t.classList && t.classList.contains && t.classList.contains(Re.replacementClass)
}

function Sz() {
    if (Re.autoReplaceSvg === !0) return Gc.replace;
    var t = Gc[Re.autoReplaceSvg];
    return t || Gc.replace
}

function Nz(t) {
    return kt.createElementNS("http://www.w3.org/2000/svg", t)
}

function Rz(t) {
    return kt.createElement(t)
}

function Jx(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        n = e.ceFn,
        r = n === void 0 ? t.tag === "svg" ? Nz : Rz : n;
    if (typeof t == "string") return kt.createTextNode(t);
    var i = r(t.tag);
    Object.keys(t.attributes || []).forEach(function(o) {
        i.setAttribute(o, t.attributes[o])
    });
    var s = t.children || [];
    return s.forEach(function(o) {
        i.appendChild(Jx(o, {
            ceFn: r
        }))
    }), i
}

function Cz(t) {
    var e = " ".concat(t.outerHTML, " ");
    return e = "".concat(e, "Font Awesome fontawesome.com "), e
}
var Gc = {
    replace: function(e) {
        var n = e[0];
        if (n.parentNode)
            if (e[1].forEach(function(i) {
                    n.parentNode.insertBefore(Jx(i), n)
                }), n.getAttribute(Ls) === null && Re.keepOriginalSource) {
                var r = kt.createComment(Cz(n));
                n.parentNode.replaceChild(r, n)
            } else n.remove()
    },
    nest: function(e) {
        var n = e[0],
            r = e[1];
        if (~mm(n).indexOf(Re.replacementClass)) return Gc.replace(e);
        var i = new RegExp("".concat(Re.cssPrefix, "-.*"));
        if (delete r[0].attributes.id, r[0].attributes.class) {
            var s = r[0].attributes.class.split(" ").reduce(function(a, c) {
                return c === Re.replacementClass || c.match(i) ? a.toSvg.push(c) : a.toNode.push(c), a
            }, {
                toNode: [],
                toSvg: []
            });
            r[0].attributes.class = s.toSvg.join(" "), s.toNode.length === 0 ? n.removeAttribute("class") : n.setAttribute("class", s.toNode.join(" "))
        }
        var o = r.map(function(a) {
            return Ll(a)
        }).join(`
`);
        n.setAttribute(Ls, ""), n.innerHTML = o
    }
};

function Sy(t) {
    t()
}

function Kx(t, e) {
    var n = typeof e == "function" ? e : Vc;
    if (t.length === 0) n();
    else {
        var r = Sy;
        Re.mutateApproach === IH && (r = Gi.requestAnimationFrame || Sy), r(function() {
            var i = Sz(),
                s = xm.begin("mutate");
            t.map(i), s(), n()
        })
    }
}
var Am = !1;

function Zx() {
    Am = !0
}

function jh() {
    Am = !1
}
var bu = null;

function Ny(t) {
    if (yy && Re.observeMutations) {
        var e = t.treeCallback,
            n = e === void 0 ? Vc : e,
            r = t.nodeCallback,
            i = r === void 0 ? Vc : r,
            s = t.pseudoElementsCallback,
            o = s === void 0 ? Vc : s,
            a = t.observeMutationsRoot,
            c = a === void 0 ? kt : a;
        bu = new yy(function(l) {
            if (!Am) {
                var u = Wi();
                ea(l).forEach(function(f) {
                    if (f.type === "childList" && f.addedNodes.length > 0 && !Py(f.addedNodes[0]) && (Re.searchPseudoElements && o(f.target), n(f.target)), f.type === "attributes" && f.target.parentNode && Re.searchPseudoElements && o(f.target.parentNode), f.type === "attributes" && Py(f.target) && ~zH.indexOf(f.attributeName))
                        if (f.attributeName === "class" && Ez(f.target)) {
                            var d = ff(mm(f.target)),
                                h = d.prefix,
                                p = d.iconName;
                            f.target.setAttribute(dm, h || u), p && f.target.setAttribute(hm, p)
                        } else Pz(f.target) && i(f.target)
                })
            }
        }), hi && bu.observe(c, {
            childList: !0,
            attributes: !0,
            characterData: !0,
            subtree: !0
        })
    }
}

function Oz() {
    bu && bu.disconnect()
}

function Tz(t) {
    var e = t.getAttribute("style"),
        n = [];
    return e && (n = e.split(";").reduce(function(r, i) {
        var s = i.split(":"),
            o = s[0],
            a = s.slice(1);
        return o && a.length > 0 && (r[o] = a.join(":").trim()), r
    }, {})), n
}

function Bz(t) {
    var e = t.getAttribute("data-prefix"),
        n = t.getAttribute("data-icon"),
        r = t.innerText !== void 0 ? t.innerText.trim() : "",
        i = ff(mm(t));
    return i.prefix || (i.prefix = Wi()), e && n && (i.prefix = e, i.iconName = n), i.iconName && i.prefix || (i.prefix && r.length > 0 && (i.iconName = uz(i.prefix, t.innerText) || vm(i.prefix, Dh(t.innerText))), !i.iconName && Re.autoFetchSvg && t.firstChild && t.firstChild.nodeType === Node.TEXT_NODE && (i.iconName = t.firstChild.data)), i
}

function Iz(t) {
    var e = ea(t.attributes).reduce(function(i, s) {
            return i.name !== "class" && i.name !== "style" && (i[s.name] = s.value), i
        }, {}),
        n = t.getAttribute("title"),
        r = t.getAttribute("data-fa-title-id");
    return Re.autoA11y && (n ? e["aria-labelledby"] = "".concat(Re.replacementClass, "-title-").concat(r || pl()) : (e["aria-hidden"] = "true", e.focusable = "false")), e
}

function Dz() {
    return {
        iconName: null,
        title: null,
        titleId: null,
        prefix: null,
        transform: _r,
        symbol: !1,
        mask: {
            iconName: null,
            prefix: null,
            rest: []
        },
        maskId: null,
        extra: {
            classes: [],
            styles: {},
            attributes: {}
        }
    }
}

function Ry(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            styleParser: !0
        },
        n = Bz(t),
        r = n.iconName,
        i = n.prefix,
        s = n.rest,
        o = Iz(t),
        a = Mh("parseNodeAttributes", {}, t),
        c = e.styleParser ? Tz(t) : [];
    return Pe({
        iconName: r,
        title: t.getAttribute("title"),
        titleId: t.getAttribute("data-fa-title-id"),
        prefix: i,
        transform: _r,
        mask: {
            iconName: null,
            prefix: null,
            rest: []
        },
        maskId: null,
        symbol: !1,
        extra: {
            classes: s,
            styles: c,
            attributes: o
        }
    }, a)
}
var Lz = lr.styles;

function Yx(t) {
    var e = Re.autoReplaceSvg === "nest" ? Ry(t, {
        styleParser: !1
    }) : Ry(t);
    return ~e.extra.classes.indexOf(Tx) ? ci("generateLayersText", t, e) : ci("generateSvgReplacementMutation", t, e)
}
var Qi = new Set;
pm.map(function(t) {
    Qi.add("fa-".concat(t))
});
Object.keys(ul[At]).map(Qi.add.bind(Qi));
Object.keys(ul[Lt]).map(Qi.add.bind(Qi));
Qi = Il(Qi);

function Cy(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!hi) return Promise.resolve();
    var n = kt.documentElement.classList,
        r = function(f) {
            return n.add("".concat(vy, "-").concat(f))
        },
        i = function(f) {
            return n.remove("".concat(vy, "-").concat(f))
        },
        s = Re.autoFetchSvg ? Qi : pm.map(function(u) {
            return "fa-".concat(u)
        }).concat(Object.keys(Lz));
    s.includes("fa") || s.push("fa");
    var o = [".".concat(Tx, ":not([").concat(Ls, "])")].concat(s.map(function(u) {
        return ".".concat(u, ":not([").concat(Ls, "])")
    })).join(", ");
    if (o.length === 0) return Promise.resolve();
    var a = [];
    try {
        a = ea(t.querySelectorAll(o))
    } catch {}
    if (a.length > 0) r("pending"), i("complete");
    else return Promise.resolve();
    var c = xm.begin("onTree"),
        l = a.reduce(function(u, f) {
            try {
                var d = Yx(f);
                d && u.push(d)
            } catch (h) {
                Ox || h.name === "MissingIcon" && console.error(h)
            }
            return u
        }, []);
    return new Promise(function(u, f) {
        Promise.all(l).then(function(d) {
            Kx(d, function() {
                r("active"), r("complete"), i("pending"), typeof e == "function" && e(), c(), u()
            })
        }).catch(function(d) {
            c(), f(d)
        })
    })
}

function Mz(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    Yx(t).then(function(n) {
        n && Kx([n], e)
    })
}

function Fz(t) {
    return function(e) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            r = (e || {}).icon ? e : Fh(e || {}),
            i = n.mask;
        return i && (i = (i || {}).icon ? i : Fh(i || {})), t(r, Pe(Pe({}, n), {}, {
            mask: i
        }))
    }
}
var Uz = function(e) {
        var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            r = n.transform,
            i = r === void 0 ? _r : r,
            s = n.symbol,
            o = s === void 0 ? !1 : s,
            a = n.mask,
            c = a === void 0 ? null : a,
            l = n.maskId,
            u = l === void 0 ? null : l,
            f = n.title,
            d = f === void 0 ? null : f,
            h = n.titleId,
            p = h === void 0 ? null : h,
            g = n.classes,
            b = g === void 0 ? [] : g,
            x = n.attributes,
            w = x === void 0 ? {} : x,
            O = n.styles,
            N = O === void 0 ? {} : O;
        if (e) {
            var U = e.prefix,
                H = e.iconName,
                M = e.icon;
            return df(Pe({
                type: "icon"
            }, e), function() {
                return Ms("beforeDOMElementCreation", {
                    iconDefinition: e,
                    params: n
                }), Re.autoA11y && (d ? w["aria-labelledby"] = "".concat(Re.replacementClass, "-title-").concat(p || pl()) : (w["aria-hidden"] = "true", w.focusable = "false")), wm({
                    icons: {
                        main: Uh(M),
                        mask: c ? Uh(c.icon) : {
                            found: !1,
                            width: null,
                            height: null,
                            icon: {}
                        }
                    },
                    prefix: U,
                    iconName: H,
                    transform: Pe(Pe({}, _r), i),
                    symbol: o,
                    title: d,
                    maskId: u,
                    titleId: p,
                    extra: {
                        attributes: w,
                        styles: N,
                        classes: b
                    }
                })
            })
        }
    },
    Hz = {
        mixout: function() {
            return {
                icon: Fz(Uz)
            }
        },
        hooks: function() {
            return {
                mutationObserverCallbacks: function(n) {
                    return n.treeCallback = Cy, n.nodeCallback = Mz, n
                }
            }
        },
        provides: function(e) {
            e.i2svg = function(n) {
                var r = n.node,
                    i = r === void 0 ? kt : r,
                    s = n.callback,
                    o = s === void 0 ? function() {} : s;
                return Cy(i, o)
            }, e.generateSvgReplacementMutation = function(n, r) {
                var i = r.iconName,
                    s = r.title,
                    o = r.titleId,
                    a = r.prefix,
                    c = r.transform,
                    l = r.symbol,
                    u = r.mask,
                    f = r.maskId,
                    d = r.extra;
                return new Promise(function(h, p) {
                    Promise.all([Hh(i, a), u.iconName ? Hh(u.iconName, u.prefix) : Promise.resolve({
                        found: !1,
                        width: 512,
                        height: 512,
                        icon: {}
                    })]).then(function(g) {
                        var b = um(g, 2),
                            x = b[0],
                            w = b[1];
                        h([n, wm({
                            icons: {
                                main: x,
                                mask: w
                            },
                            prefix: a,
                            iconName: i,
                            transform: c,
                            symbol: l,
                            maskId: f,
                            title: s,
                            titleId: o,
                            extra: d,
                            watchable: !0
                        })])
                    }).catch(p)
                })
            }, e.generateAbstractIcon = function(n) {
                var r = n.children,
                    i = n.attributes,
                    s = n.main,
                    o = n.transform,
                    a = n.styles,
                    c = cf(a);
                c.length > 0 && (i.style = c);
                var l;
                return gm(o) && (l = ci("generateAbstractTransformGrouping", {
                    main: s,
                    transform: o,
                    containerWidth: s.width,
                    iconWidth: s.width
                })), r.push(l || s.icon), {
                    children: r,
                    attributes: i
                }
            }
        }
    },
    zz = {
        mixout: function() {
            return {
                layer: function(n) {
                    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                        i = r.classes,
                        s = i === void 0 ? [] : i;
                    return df({
                        type: "layer"
                    }, function() {
                        Ms("beforeDOMElementCreation", {
                            assembler: n,
                            params: r
                        });
                        var o = [];
                        return n(function(a) {
                            Array.isArray(a) ? a.map(function(c) {
                                o = o.concat(c.abstract)
                            }) : o = o.concat(a.abstract)
                        }), [{
                            tag: "span",
                            attributes: {
                                class: ["".concat(Re.cssPrefix, "-layers")].concat(Il(s)).join(" ")
                            },
                            children: o
                        }]
                    })
                }
            }
        }
    },
    jz = {
        mixout: function() {
            return {
                counter: function(n) {
                    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                        i = r.title,
                        s = i === void 0 ? null : i,
                        o = r.classes,
                        a = o === void 0 ? [] : o,
                        c = r.attributes,
                        l = c === void 0 ? {} : c,
                        u = r.styles,
                        f = u === void 0 ? {} : u;
                    return df({
                        type: "counter",
                        content: n
                    }, function() {
                        return Ms("beforeDOMElementCreation", {
                            content: n,
                            params: r
                        }), xz({
                            content: n.toString(),
                            title: s,
                            extra: {
                                attributes: l,
                                styles: f,
                                classes: ["".concat(Re.cssPrefix, "-layers-counter")].concat(Il(a))
                            }
                        })
                    })
                }
            }
        }
    },
    Vz = {
        mixout: function() {
            return {
                text: function(n) {
                    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                        i = r.transform,
                        s = i === void 0 ? _r : i,
                        o = r.title,
                        a = o === void 0 ? null : o,
                        c = r.classes,
                        l = c === void 0 ? [] : c,
                        u = r.attributes,
                        f = u === void 0 ? {} : u,
                        d = r.styles,
                        h = d === void 0 ? {} : d;
                    return df({
                        type: "text",
                        content: n
                    }, function() {
                        return Ms("beforeDOMElementCreation", {
                            content: n,
                            params: r
                        }), _y({
                            content: n,
                            transform: Pe(Pe({}, _r), s),
                            title: a,
                            extra: {
                                attributes: f,
                                styles: h,
                                classes: ["".concat(Re.cssPrefix, "-layers-text")].concat(Il(l))
                            }
                        })
                    })
                }
            }
        },
        provides: function(e) {
            e.generateLayersText = function(n, r) {
                var i = r.title,
                    s = r.transform,
                    o = r.extra,
                    a = null,
                    c = null;
                if (Nx) {
                    var l = parseInt(getComputedStyle(n).fontSize, 10),
                        u = n.getBoundingClientRect();
                    a = u.width / l, c = u.height / l
                }
                return Re.autoA11y && !i && (o.attributes["aria-hidden"] = "true"), Promise.resolve([n, _y({
                    content: n.innerHTML,
                    width: a,
                    height: c,
                    transform: s,
                    title: i,
                    extra: o,
                    watchable: !0
                })])
            }
        }
    },
    Gz = new RegExp('"', "ug"),
    Oy = [1105920, 1112319];

function Wz(t) {
    var e = t.replace(Gz, ""),
        n = iz(e, 0),
        r = n >= Oy[0] && n <= Oy[1],
        i = e.length === 2 ? e[0] === e[1] : !1;
    return {
        value: Dh(i ? e[0] : e),
        isSecondary: r || i
    }
}

function Ty(t, e) {
    var n = "".concat(BH).concat(e.replace(":", "-"));
    return new Promise(function(r, i) {
        if (t.getAttribute(n) !== null) return r();
        var s = ea(t.children),
            o = s.filter(function(M) {
                return M.getAttribute(Ih) === e
            })[0],
            a = Gi.getComputedStyle(t, e),
            c = a.getPropertyValue("font-family").match(FH),
            l = a.getPropertyValue("font-weight"),
            u = a.getPropertyValue("content");
        if (o && !c) return t.removeChild(o), r();
        if (c && u !== "none" && u !== "") {
            var f = a.getPropertyValue("content"),
                d = ~["Sharp"].indexOf(c[2]) ? Lt : At,
                h = ~["Solid", "Regular", "Light", "Thin", "Duotone", "Brands", "Kit"].indexOf(c[2]) ? fl[d][c[2].toLowerCase()] : UH[d][l],
                p = Wz(f),
                g = p.value,
                b = p.isSecondary,
                x = c[0].startsWith("FontAwesome"),
                w = vm(h, g),
                O = w;
            if (x) {
                var N = fz(g);
                N.iconName && N.prefix && (w = N.iconName, h = N.prefix)
            }
            if (w && !b && (!o || o.getAttribute(dm) !== h || o.getAttribute(hm) !== O)) {
                t.setAttribute(n, O), o && t.removeChild(o);
                var U = Dz(),
                    H = U.extra;
                H.attributes[Ih] = e, Hh(w, h).then(function(M) {
                    var y = wm(Pe(Pe({}, U), {}, {
                            icons: {
                                main: M,
                                mask: bm()
                            },
                            prefix: h,
                            iconName: O,
                            extra: H,
                            watchable: !0
                        })),
                        v = kt.createElementNS("http://www.w3.org/2000/svg", "svg");
                    e === "::before" ? t.insertBefore(v, t.firstChild) : t.appendChild(v), v.outerHTML = y.map(function(A) {
                        return Ll(A)
                    }).join(`
`), t.removeAttribute(n), r()
                }).catch(i)
            } else r()
        } else r()
    })
}

function Qz(t) {
    return Promise.all([Ty(t, "::before"), Ty(t, "::after")])
}

function Jz(t) {
    return t.parentNode !== document.head && !~DH.indexOf(t.tagName.toUpperCase()) && !t.getAttribute(Ih) && (!t.parentNode || t.parentNode.tagName !== "svg")
}

function By(t) {
    if (hi) return new Promise(function(e, n) {
        var r = ea(t.querySelectorAll("*")).filter(Jz).map(Qz),
            i = xm.begin("searchPseudoElements");
        Zx(), Promise.all(r).then(function() {
            i(), jh(), e()
        }).catch(function() {
            i(), jh(), n()
        })
    })
}
var Kz = {
        hooks: function() {
            return {
                mutationObserverCallbacks: function(n) {
                    return n.pseudoElementsCallback = By, n
                }
            }
        },
        provides: function(e) {
            e.pseudoElements2svg = function(n) {
                var r = n.node,
                    i = r === void 0 ? kt : r;
                Re.searchPseudoElements && By(i)
            }
        }
    },
    Iy = !1,
    Zz = {
        mixout: function() {
            return {
                dom: {
                    unwatch: function() {
                        Zx(), Iy = !0
                    }
                }
            }
        },
        hooks: function() {
            return {
                bootstrap: function() {
                    Ny(Mh("mutationObserverCallbacks", {}))
                },
                noAuto: function() {
                    Oz()
                },
                watch: function(n) {
                    var r = n.observeMutationsRoot;
                    Iy ? jh() : Ny(Mh("mutationObserverCallbacks", {
                        observeMutationsRoot: r
                    }))
                }
            }
        }
    },
    Dy = function(e) {
        var n = {
            size: 16,
            x: 0,
            y: 0,
            flipX: !1,
            flipY: !1,
            rotate: 0
        };
        return e.toLowerCase().split(" ").reduce(function(r, i) {
            var s = i.toLowerCase().split("-"),
                o = s[0],
                a = s.slice(1).join("-");
            if (o && a === "h") return r.flipX = !0, r;
            if (o && a === "v") return r.flipY = !0, r;
            if (a = parseFloat(a), isNaN(a)) return r;
            switch (o) {
                case "grow":
                    r.size = r.size + a;
                    break;
                case "shrink":
                    r.size = r.size - a;
                    break;
                case "left":
                    r.x = r.x - a;
                    break;
                case "right":
                    r.x = r.x + a;
                    break;
                case "up":
                    r.y = r.y - a;
                    break;
                case "down":
                    r.y = r.y + a;
                    break;
                case "rotate":
                    r.rotate = r.rotate + a;
                    break
            }
            return r
        }, n)
    },
    Yz = {
        mixout: function() {
            return {
                parse: {
                    transform: function(n) {
                        return Dy(n)
                    }
                }
            }
        },
        hooks: function() {
            return {
                parseNodeAttributes: function(n, r) {
                    var i = r.getAttribute("data-fa-transform");
                    return i && (n.transform = Dy(i)), n
                }
            }
        },
        provides: function(e) {
            e.generateAbstractTransformGrouping = function(n) {
                var r = n.main,
                    i = n.transform,
                    s = n.containerWidth,
                    o = n.iconWidth,
                    a = {
                        transform: "translate(".concat(s / 2, " 256)")
                    },
                    c = "translate(".concat(i.x * 32, ", ").concat(i.y * 32, ") "),
                    l = "scale(".concat(i.size / 16 * (i.flipX ? -1 : 1), ", ").concat(i.size / 16 * (i.flipY ? -1 : 1), ") "),
                    u = "rotate(".concat(i.rotate, " 0 0)"),
                    f = {
                        transform: "".concat(c, " ").concat(l, " ").concat(u)
                    },
                    d = {
                        transform: "translate(".concat(o / 2 * -1, " -256)")
                    },
                    h = {
                        outer: a,
                        inner: f,
                        path: d
                    };
                return {
                    tag: "g",
                    attributes: Pe({}, h.outer),
                    children: [{
                        tag: "g",
                        attributes: Pe({}, h.inner),
                        children: [{
                            tag: r.icon.tag,
                            children: r.icon.children,
                            attributes: Pe(Pe({}, r.icon.attributes), h.path)
                        }]
                    }]
                }
            }
        }
    },
    Sd = {
        x: 0,
        y: 0,
        width: "100%",
        height: "100%"
    };

function Ly(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return t.attributes && (t.attributes.fill || e) && (t.attributes.fill = "black"), t
}

function Xz(t) {
    return t.tag === "g" ? t.children : [t]
}
var qz = {
        hooks: function() {
            return {
                parseNodeAttributes: function(n, r) {
                    var i = r.getAttribute("data-fa-mask"),
                        s = i ? ff(i.split(" ").map(function(o) {
                            return o.trim()
                        })) : bm();
                    return s.prefix || (s.prefix = Wi()), n.mask = s, n.maskId = r.getAttribute("data-fa-mask-id"), n
                }
            }
        },
        provides: function(e) {
            e.generateAbstractMask = function(n) {
                var r = n.children,
                    i = n.attributes,
                    s = n.main,
                    o = n.mask,
                    a = n.maskId,
                    c = n.transform,
                    l = s.width,
                    u = s.icon,
                    f = o.width,
                    d = o.icon,
                    h = YH({
                        transform: c,
                        containerWidth: f,
                        iconWidth: l
                    }),
                    p = {
                        tag: "rect",
                        attributes: Pe(Pe({}, Sd), {}, {
                            fill: "white"
                        })
                    },
                    g = u.children ? {
                        children: u.children.map(Ly)
                    } : {},
                    b = {
                        tag: "g",
                        attributes: Pe({}, h.inner),
                        children: [Ly(Pe({
                            tag: u.tag,
                            attributes: Pe(Pe({}, u.attributes), h.path)
                        }, g))]
                    },
                    x = {
                        tag: "g",
                        attributes: Pe({}, h.outer),
                        children: [b]
                    },
                    w = "mask-".concat(a || pl()),
                    O = "clip-".concat(a || pl()),
                    N = {
                        tag: "mask",
                        attributes: Pe(Pe({}, Sd), {}, {
                            id: w,
                            maskUnits: "userSpaceOnUse",
                            maskContentUnits: "userSpaceOnUse"
                        }),
                        children: [p, x]
                    },
                    U = {
                        tag: "defs",
                        children: [{
                            tag: "clipPath",
                            attributes: {
                                id: O
                            },
                            children: Xz(d)
                        }, N]
                    };
                return r.push(U, {
                    tag: "rect",
                    attributes: Pe({
                        fill: "currentColor",
                        "clip-path": "url(#".concat(O, ")"),
                        mask: "url(#".concat(w, ")")
                    }, Sd)
                }), {
                    children: r,
                    attributes: i
                }
            }
        }
    },
    $z = {
        provides: function(e) {
            var n = !1;
            Gi.matchMedia && (n = Gi.matchMedia("(prefers-reduced-motion: reduce)").matches), e.missingIconAbstract = function() {
                var r = [],
                    i = {
                        fill: "currentColor"
                    },
                    s = {
                        attributeType: "XML",
                        repeatCount: "indefinite",
                        dur: "2s"
                    };
                r.push({
                    tag: "path",
                    attributes: Pe(Pe({}, i), {}, {
                        d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
                    })
                });
                var o = Pe(Pe({}, s), {}, {
                        attributeName: "opacity"
                    }),
                    a = {
                        tag: "circle",
                        attributes: Pe(Pe({}, i), {}, {
                            cx: "256",
                            cy: "364",
                            r: "28"
                        }),
                        children: []
                    };
                return n || a.children.push({
                    tag: "animate",
                    attributes: Pe(Pe({}, s), {}, {
                        attributeName: "r",
                        values: "28;14;28;28;14;28;"
                    })
                }, {
                    tag: "animate",
                    attributes: Pe(Pe({}, o), {}, {
                        values: "1;0;1;1;0;1;"
                    })
                }), r.push(a), r.push({
                    tag: "path",
                    attributes: Pe(Pe({}, i), {}, {
                        opacity: "1",
                        d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
                    }),
                    children: n ? [] : [{
                        tag: "animate",
                        attributes: Pe(Pe({}, o), {}, {
                            values: "1;0;0;0;0;1;"
                        })
                    }]
                }), n || r.push({
                    tag: "path",
                    attributes: Pe(Pe({}, i), {}, {
                        opacity: "0",
                        d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
                    }),
                    children: [{
                        tag: "animate",
                        attributes: Pe(Pe({}, o), {}, {
                            values: "0;0;1;1;0;0;"
                        })
                    }]
                }), {
                    tag: "g",
                    attributes: {
                        class: "missing"
                    },
                    children: r
                }
            }
        }
    },
    ej = {
        hooks: function() {
            return {
                parseNodeAttributes: function(n, r) {
                    var i = r.getAttribute("data-fa-symbol"),
                        s = i === null ? !1 : i === "" ? !0 : i;
                    return n.symbol = s, n
                }
            }
        }
    },
    tj = [$H, Hz, zz, jz, Vz, Kz, Zz, Yz, qz, $z, ej];
pz(tj, {
    mixoutsTo: Bn
});
Bn.noAuto;
Bn.config;
var nj = Bn.library;
Bn.dom;
var Vh = Bn.parse;
Bn.findIconDefinition;
Bn.toHtml;
var rj = Bn.icon;
Bn.layer;
Bn.text;
Bn.counter;

function My(t, e) {
    var n = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var r = Object.getOwnPropertySymbols(t);
        e && (r = r.filter(function(i) {
            return Object.getOwnPropertyDescriptor(t, i).enumerable
        })), n.push.apply(n, r)
    }
    return n
}

function Xr(t) {
    for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e] != null ? arguments[e] : {};
        e % 2 ? My(Object(n), !0).forEach(function(r) {
            vn(t, r, n[r])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : My(Object(n)).forEach(function(r) {
            Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r))
        })
    }
    return t
}

function wu(t) {
    "@babel/helpers - typeof";
    return wu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    } : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }, wu(t)
}

function vn(t, e, n) {
    return e = aj(e), e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = n, t
}

function ij(t, e) {
    if (t == null) return {};
    var n = {},
        r = Object.keys(t),
        i, s;
    for (s = 0; s < r.length; s++) i = r[s], !(e.indexOf(i) >= 0) && (n[i] = t[i]);
    return n
}

function sj(t, e) {
    if (t == null) return {};
    var n = ij(t, e),
        r, i;
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(t);
        for (i = 0; i < s.length; i++) r = s[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r])
    }
    return n
}

function oj(t, e) {
    if (typeof t != "object" || t === null) return t;
    var n = t[Symbol.toPrimitive];
    if (n !== void 0) {
        var r = n.call(t, e || "default");
        if (typeof r != "object") return r;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(t)
}

function aj(t) {
    var e = oj(t, "string");
    return typeof e == "symbol" ? e : String(e)
}
var lj = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
    Xx = {
        exports: {}
    };
(function(t) {
    (function(e) {
        var n = function(x, w, O) {
                if (!l(w) || f(w) || d(w) || h(w) || c(w)) return w;
                var N, U = 0,
                    H = 0;
                if (u(w))
                    for (N = [], H = w.length; U < H; U++) N.push(n(x, w[U], O));
                else {
                    N = {};
                    for (var M in w) Object.prototype.hasOwnProperty.call(w, M) && (N[x(M, O)] = n(x, w[M], O))
                }
                return N
            },
            r = function(x, w) {
                w = w || {};
                var O = w.separator || "_",
                    N = w.split || /(?=[A-Z])/;
                return x.split(N).join(O)
            },
            i = function(x) {
                return p(x) ? x : (x = x.replace(/[\-_\s]+(.)?/g, function(w, O) {
                    return O ? O.toUpperCase() : ""
                }), x.substr(0, 1).toLowerCase() + x.substr(1))
            },
            s = function(x) {
                var w = i(x);
                return w.substr(0, 1).toUpperCase() + w.substr(1)
            },
            o = function(x, w) {
                return r(x, w).toLowerCase()
            },
            a = Object.prototype.toString,
            c = function(x) {
                return typeof x == "function"
            },
            l = function(x) {
                return x === Object(x)
            },
            u = function(x) {
                return a.call(x) == "[object Array]"
            },
            f = function(x) {
                return a.call(x) == "[object Date]"
            },
            d = function(x) {
                return a.call(x) == "[object RegExp]"
            },
            h = function(x) {
                return a.call(x) == "[object Boolean]"
            },
            p = function(x) {
                return x = x - 0, x === x
            },
            g = function(x, w) {
                var O = w && "process" in w ? w.process : w;
                return typeof O != "function" ? x : function(N, U) {
                    return O(N, x, U)
                }
            },
            b = {
                camelize: i,
                decamelize: o,
                pascalize: s,
                depascalize: o,
                camelizeKeys: function(x, w) {
                    return n(g(i, w), x)
                },
                decamelizeKeys: function(x, w) {
                    return n(g(o, w), x, w)
                },
                pascalizeKeys: function(x, w) {
                    return n(g(s, w), x)
                },
                depascalizeKeys: function() {
                    return this.decamelizeKeys.apply(this, arguments)
                }
            };
        t.exports ? t.exports = b : e.humps = b
    })(lj)
})(Xx);
var cj = Xx.exports,
    uj = ["class", "style"];

function fj(t) {
    return t.split(";").map(function(e) {
        return e.trim()
    }).filter(function(e) {
        return e
    }).reduce(function(e, n) {
        var r = n.indexOf(":"),
            i = cj.camelize(n.slice(0, r)),
            s = n.slice(r + 1).trim();
        return e[i] = s, e
    }, {})
}

function dj(t) {
    return t.split(/\s+/).reduce(function(e, n) {
        return e[n] = !0, e
    }, {})
}

function qx(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (typeof t == "string") return t;
    var r = (t.children || []).map(function(c) {
            return qx(c)
        }),
        i = Object.keys(t.attributes || {}).reduce(function(c, l) {
            var u = t.attributes[l];
            switch (l) {
                case "class":
                    c.class = dj(u);
                    break;
                case "style":
                    c.style = fj(u);
                    break;
                default:
                    c.attrs[l] = u
            }
            return c
        }, {
            attrs: {},
            class: {},
            style: {}
        });
    n.class;
    var s = n.style,
        o = s === void 0 ? {} : s,
        a = sj(n, uj);
    return Ns(t.tag, Xr(Xr(Xr({}, e), {}, {
        class: i.class,
        style: Xr(Xr({}, i.style), o)
    }, i.attrs), a), r)
}
var $x = !1;
try {
    $x = !0
} catch {}

function hj() {
    if (!$x && console && typeof console.error == "function") {
        var t;
        (t = console).error.apply(t, arguments)
    }
}

function Nd(t, e) {
    return Array.isArray(e) && e.length > 0 || !Array.isArray(e) && e ? vn({}, t, e) : {}
}

function pj(t) {
    var e, n = (e = {
        "fa-spin": t.spin,
        "fa-pulse": t.pulse,
        "fa-fw": t.fixedWidth,
        "fa-border": t.border,
        "fa-li": t.listItem,
        "fa-inverse": t.inverse,
        "fa-flip": t.flip === !0,
        "fa-flip-horizontal": t.flip === "horizontal" || t.flip === "both",
        "fa-flip-vertical": t.flip === "vertical" || t.flip === "both"
    }, vn(e, "fa-".concat(t.size), t.size !== null), vn(e, "fa-rotate-".concat(t.rotation), t.rotation !== null), vn(e, "fa-pull-".concat(t.pull), t.pull !== null), vn(e, "fa-swap-opacity", t.swapOpacity), vn(e, "fa-bounce", t.bounce), vn(e, "fa-shake", t.shake), vn(e, "fa-beat", t.beat), vn(e, "fa-fade", t.fade), vn(e, "fa-beat-fade", t.beatFade), vn(e, "fa-flash", t.flash), vn(e, "fa-spin-pulse", t.spinPulse), vn(e, "fa-spin-reverse", t.spinReverse), e);
    return Object.keys(n).map(function(r) {
        return n[r] ? r : null
    }).filter(function(r) {
        return r
    })
}

function Fy(t) {
    if (t && wu(t) === "object" && t.prefix && t.iconName && t.icon) return t;
    if (Vh.icon) return Vh.icon(t);
    if (t === null) return null;
    if (wu(t) === "object" && t.prefix && t.iconName) return t;
    if (Array.isArray(t) && t.length === 2) return {
        prefix: t[0],
        iconName: t[1]
    };
    if (typeof t == "string") return {
        prefix: "fas",
        iconName: t
    }
}
var mj = nt({
        name: "FontAwesomeIcon",
        props: {
            border: {
                type: Boolean,
                default: !1
            },
            fixedWidth: {
                type: Boolean,
                default: !1
            },
            flip: {
                type: [Boolean, String],
                default: !1,
                validator: function(e) {
                    return [!0, !1, "horizontal", "vertical", "both"].indexOf(e) > -1
                }
            },
            icon: {
                type: [Object, Array, String],
                required: !0
            },
            mask: {
                type: [Object, Array, String],
                default: null
            },
            maskId: {
                type: String,
                default: null
            },
            listItem: {
                type: Boolean,
                default: !1
            },
            pull: {
                type: String,
                default: null,
                validator: function(e) {
                    return ["right", "left"].indexOf(e) > -1
                }
            },
            pulse: {
                type: Boolean,
                default: !1
            },
            rotation: {
                type: [String, Number],
                default: null,
                validator: function(e) {
                    return [90, 180, 270].indexOf(Number.parseInt(e, 10)) > -1
                }
            },
            swapOpacity: {
                type: Boolean,
                default: !1
            },
            size: {
                type: String,
                default: null,
                validator: function(e) {
                    return ["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"].indexOf(e) > -1
                }
            },
            spin: {
                type: Boolean,
                default: !1
            },
            transform: {
                type: [String, Object],
                default: null
            },
            symbol: {
                type: [Boolean, String],
                default: !1
            },
            title: {
                type: String,
                default: null
            },
            titleId: {
                type: String,
                default: null
            },
            inverse: {
                type: Boolean,
                default: !1
            },
            bounce: {
                type: Boolean,
                default: !1
            },
            shake: {
                type: Boolean,
                default: !1
            },
            beat: {
                type: Boolean,
                default: !1
            },
            fade: {
                type: Boolean,
                default: !1
            },
            beatFade: {
                type: Boolean,
                default: !1
            },
            flash: {
                type: Boolean,
                default: !1
            },
            spinPulse: {
                type: Boolean,
                default: !1
            },
            spinReverse: {
                type: Boolean,
                default: !1
            }
        },
        setup: function(e, n) {
            var r = n.attrs,
                i = ze(function() {
                    return Fy(e.icon)
                }),
                s = ze(function() {
                    return Nd("classes", pj(e))
                }),
                o = ze(function() {
                    return Nd("transform", typeof e.transform == "string" ? Vh.transform(e.transform) : e.transform)
                }),
                a = ze(function() {
                    return Nd("mask", Fy(e.mask))
                }),
                c = ze(function() {
                    return rj(i.value, Xr(Xr(Xr(Xr({}, s.value), o.value), a.value), {}, {
                        symbol: e.symbol,
                        title: e.title,
                        titleId: e.titleId,
                        maskId: e.maskId
                    }))
                });
            Xe(c, function(u) {
                if (!u) return hj("Could not find one or more icon(s)", i.value, a.value)
            }, {
                immediate: !0
            });
            var l = ze(function() {
                return c.value ? qx(c.value.abstract[0], {}, r) : null
            });
            return function() {
                return l.value
            }
        }
    }),
    eA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fab",
        n = "ethereum",
        r = 320,
        i = 512,
        s = [],
        o = "f42e",
        a = "M311.9 260.8L160 353.6 8 260.8 160 0l151.9 260.8zM160 383.4L8 290.6 160 512l152-221.4-152 92.8z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faEthereum = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(eA);
var tA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "users",
        r = 640,
        i = 512,
        s = [],
        o = "f0c0",
        a = "M144 0a80 80 0 1 1 0 160A80 80 0 1 1 144 0zM512 0a80 80 0 1 1 0 160A80 80 0 1 1 512 0zM0 298.7C0 239.8 47.8 192 106.7 192h42.7c15.9 0 31 3.5 44.6 9.7c-1.3 7.2-1.9 14.7-1.9 22.3c0 38.2 16.8 72.5 43.3 96c-.2 0-.4 0-.7 0H21.3C9.6 320 0 310.4 0 298.7zM405.3 320c-.2 0-.4 0-.7 0c26.6-23.5 43.3-57.8 43.3-96c0-7.6-.7-15-1.9-22.3c13.6-6.3 28.7-9.7 44.6-9.7h42.7C592.2 192 640 239.8 640 298.7c0 11.8-9.6 21.3-21.3 21.3H405.3zM224 224a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zM128 485.3C128 411.7 187.7 352 261.3 352H378.7C452.3 352 512 411.7 512 485.3c0 14.7-11.9 26.7-26.7 26.7H154.7c-14.7 0-26.7-11.9-26.7-26.7z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faUsers = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(tA);
var nA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "lock",
        r = 448,
        i = 512,
        s = [128274],
        o = "f023",
        a = "M144 144v48H304V144c0-44.2-35.8-80-80-80s-80 35.8-80 80zM80 192V144C80 64.5 144.5 0 224 0s144 64.5 144 144v48h16c35.3 0 64 28.7 64 64V448c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V256c0-35.3 28.7-64 64-64H80z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faLock = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(nA);
var rA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "network-wired",
        r = 640,
        i = 512,
        s = [],
        o = "f6ff",
        a = "M256 64H384v64H256V64zM240 0c-26.5 0-48 21.5-48 48v96c0 26.5 21.5 48 48 48h48v32H32c-17.7 0-32 14.3-32 32s14.3 32 32 32h96v32H80c-26.5 0-48 21.5-48 48v96c0 26.5 21.5 48 48 48H240c26.5 0 48-21.5 48-48V368c0-26.5-21.5-48-48-48H192V288H448v32H400c-26.5 0-48 21.5-48 48v96c0 26.5 21.5 48 48 48H560c26.5 0 48-21.5 48-48V368c0-26.5-21.5-48-48-48H512V288h96c17.7 0 32-14.3 32-32s-14.3-32-32-32H352V192h48c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48H240zM96 448V384H224v64H96zm320-64H544v64H416V384z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faNetworkWired = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(rA);
var iA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "dollar-sign",
        r = 320,
        i = 512,
        s = [128178, 61781, "dollar", "usd"],
        o = "24",
        a = "M160 0c17.7 0 32 14.3 32 32V67.7c1.6 .2 3.1 .4 4.7 .7c.4 .1 .7 .1 1.1 .2l48 8.8c17.4 3.2 28.9 19.9 25.7 37.2s-19.9 28.9-37.2 25.7l-47.5-8.7c-31.3-4.6-58.9-1.5-78.3 6.2s-27.2 18.3-29 28.1c-2 10.7-.5 16.7 1.2 20.4c1.8 3.9 5.5 8.3 12.8 13.2c16.3 10.7 41.3 17.7 73.7 26.3l2.9 .8c28.6 7.6 63.6 16.8 89.6 33.8c14.2 9.3 27.6 21.9 35.9 39.5c8.5 17.9 10.3 37.9 6.4 59.2c-6.9 38-33.1 63.4-65.6 76.7c-13.7 5.6-28.6 9.2-44.4 11V480c0 17.7-14.3 32-32 32s-32-14.3-32-32V445.1c-.4-.1-.9-.1-1.3-.2l-.2 0 0 0c-24.4-3.8-64.5-14.3-91.5-26.3c-16.1-7.2-23.4-26.1-16.2-42.2s26.1-23.4 42.2-16.2c20.9 9.3 55.3 18.5 75.2 21.6c31.9 4.7 58.2 2 76-5.3c16.9-6.9 24.6-16.9 26.8-28.9c1.9-10.6 .4-16.7-1.3-20.4c-1.9-4-5.6-8.4-13-13.3c-16.4-10.7-41.5-17.7-74-26.3l-2.8-.7 0 0C119.4 279.3 84.4 270 58.4 253c-14.2-9.3-27.5-22-35.8-39.6c-8.4-17.9-10.1-37.9-6.1-59.2C23.7 116 52.3 91.2 84.8 78.3c13.3-5.3 27.9-8.9 43.2-11V32c0-17.7 14.3-32 32-32z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faDollarSign = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(iA);
var sA = {},
    oA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "file-lines",
        r = 384,
        i = 512,
        s = [128441, 128462, 61686, "file-alt", "file-text"],
        o = "f15c",
        a = "M64 0C28.7 0 0 28.7 0 64V448c0 35.3 28.7 64 64 64H320c35.3 0 64-28.7 64-64V160H256c-17.7 0-32-14.3-32-32V0H64zM256 0V128H384L256 0zM112 256H272c8.8 0 16 7.2 16 16s-7.2 16-16 16H112c-8.8 0-16-7.2-16-16s7.2-16 16-16zm0 64H272c8.8 0 16 7.2 16 16s-7.2 16-16 16H112c-8.8 0-16-7.2-16-16s7.2-16 16-16zm0 64H272c8.8 0 16 7.2 16 16s-7.2 16-16 16H112c-8.8 0-16-7.2-16-16s7.2-16 16-16z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faFileLines = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(oA);
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = oA;
    t.definition = {
        prefix: e.prefix,
        iconName: e.iconName,
        icon: [e.width, e.height, e.aliases, e.unicode, e.svgPathData]
    }, t.faFileAlt = t.definition, t.prefix = e.prefix, t.iconName = e.iconName, t.width = e.width, t.height = e.height, t.ligatures = e.aliases, t.unicode = e.unicode, t.svgPathData = e.svgPathData, t.aliases = e.aliases
})(sA);
var aA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "server",
        r = 512,
        i = 512,
        s = [],
        o = "f233",
        a = "M64 32C28.7 32 0 60.7 0 96v64c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zm280 72a24 24 0 1 1 0 48 24 24 0 1 1 0-48zm48 24a24 24 0 1 1 48 0 24 24 0 1 1 -48 0zM64 288c-35.3 0-64 28.7-64 64v64c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V352c0-35.3-28.7-64-64-64H64zm280 72a24 24 0 1 1 0 48 24 24 0 1 1 0-48zm56 24a24 24 0 1 1 48 0 24 24 0 1 1 -48 0z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faServer = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(aA);
var lA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "sitemap",
        r = 576,
        i = 512,
        s = [],
        o = "f0e8",
        a = "M208 80c0-26.5 21.5-48 48-48h64c26.5 0 48 21.5 48 48v64c0 26.5-21.5 48-48 48h-8v40H464c30.9 0 56 25.1 56 56v32h8c26.5 0 48 21.5 48 48v64c0 26.5-21.5 48-48 48H464c-26.5 0-48-21.5-48-48V368c0-26.5 21.5-48 48-48h8V288c0-4.4-3.6-8-8-8H312v40h8c26.5 0 48 21.5 48 48v64c0 26.5-21.5 48-48 48H256c-26.5 0-48-21.5-48-48V368c0-26.5 21.5-48 48-48h8V280H112c-4.4 0-8 3.6-8 8v32h8c26.5 0 48 21.5 48 48v64c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V368c0-26.5 21.5-48 48-48h8V288c0-30.9 25.1-56 56-56H264V192h-8c-26.5 0-48-21.5-48-48V80z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faSitemap = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(lA);
var cA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "rocket",
        r = 512,
        i = 512,
        s = [],
        o = "f135",
        a = "M156.6 384.9L125.7 354c-8.5-8.5-11.5-20.8-7.7-32.2c3-8.9 7-20.5 11.8-33.8L24 288c-8.6 0-16.6-4.6-20.9-12.1s-4.2-16.7 .2-24.1l52.5-88.5c13-21.9 36.5-35.3 61.9-35.3l82.3 0c2.4-4 4.8-7.7 7.2-11.3C289.1-4.1 411.1-8.1 483.9 5.3c11.6 2.1 20.6 11.2 22.8 22.8c13.4 72.9 9.3 194.8-111.4 276.7c-3.5 2.4-7.3 4.8-11.3 7.2v82.3c0 25.4-13.4 49-35.3 61.9l-88.5 52.5c-7.4 4.4-16.6 4.5-24.1 .2s-12.1-12.2-12.1-20.9V380.8c-14.1 4.9-26.4 8.9-35.7 11.9c-11.2 3.6-23.4 .5-31.8-7.8zM384 168a40 40 0 1 0 0-80 40 40 0 1 0 0 80z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faRocket = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(cA);
var uA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fab",
        n = "github",
        r = 496,
        i = 512,
        s = [],
        o = "f09b",
        a = "M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faGithub = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(uA);
var fA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fab",
        n = "discourse",
        r = 448,
        i = 512,
        s = [],
        o = "f393",
        a = "M225.9 32C103.3 32 0 130.5 0 252.1 0 256 .1 480 .1 480l225.8-.2c122.7 0 222.1-102.3 222.1-223.9C448 134.3 348.6 32 225.9 32zM224 384c-19.4 0-37.9-4.3-54.4-12.1L88.5 392l22.9-75c-9.8-18.1-15.4-38.9-15.4-61 0-70.7 57.3-128 128-128s128 57.3 128 128-57.3 128-128 128z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faDiscourse = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(fA);
var dA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fab",
        n = "x-twitter",
        r = 512,
        i = 512,
        s = [],
        o = "e61b",
        a = "M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faXTwitter = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(dA);
var hA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fab",
        n = "discord",
        r = 640,
        i = 512,
        s = [],
        o = "f392",
        a = "M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faDiscord = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(hA);
var pA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fab",
        n = "medium",
        r = 640,
        i = 512,
        s = [62407, "medium-m"],
        o = "f23a",
        a = "M180.5,74.262C80.813,74.262,0,155.633,0,256S80.819,437.738,180.5,437.738,361,356.373,361,256,280.191,74.262,180.5,74.262Zm288.25,10.646c-49.845,0-90.245,76.619-90.245,171.095s40.406,171.1,90.251,171.1,90.251-76.619,90.251-171.1H559C559,161.5,518.6,84.908,468.752,84.908Zm139.506,17.821c-17.526,0-31.735,68.628-31.735,153.274s14.2,153.274,31.735,153.274S640,340.631,640,256C640,171.351,625.785,102.729,608.258,102.729Z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faMedium = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(pA);
var mA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "arrow-down",
        r = 384,
        i = 512,
        s = [8595],
        o = "f063",
        a = "M169.4 470.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 370.8 224 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 306.7L54.6 265.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faArrowDown = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(mA);
var gA = {},
    yA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fad",
        n = "down",
        r = 384,
        i = 512,
        s = ["arrow-alt-down"],
        o = "f354",
        a = ["M256 256H128V72c0-22.1 17.9-40 40-40h48c22.1 0 40 17.9 40 40l0 184z", "M128 256v0l-96 0c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l160 160c12.5 12.5 32.8 12.5 45.3 0l160-160c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8l-96 0v0H128z"];
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faDown = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(yA);
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = yA;
    t.definition = {
        prefix: e.prefix,
        iconName: e.iconName,
        icon: [e.width, e.height, e.aliases, e.unicode, e.svgPathData]
    }, t.faArrowAltDown = t.definition, t.prefix = e.prefix, t.iconName = e.iconName, t.width = e.width, t.height = e.height, t.ligatures = e.aliases, t.unicode = e.unicode, t.svgPathData = e.svgPathData, t.aliases = e.aliases
})(gA);
var vA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "flask",
        r = 448,
        i = 512,
        s = [],
        o = "f0c3",
        a = "M288 0H160 128C110.3 0 96 14.3 96 32s14.3 32 32 32V196.8c0 11.8-3.3 23.5-9.5 33.5L10.3 406.2C3.6 417.2 0 429.7 0 442.6C0 480.9 31.1 512 69.4 512H378.6c38.3 0 69.4-31.1 69.4-69.4c0-12.8-3.6-25.4-10.3-36.4L329.5 230.4c-6.2-10.1-9.5-21.7-9.5-33.5V64c17.7 0 32-14.3 32-32s-14.3-32-32-32H288zM192 196.8V64h64V196.8c0 23.7 6.6 46.9 19 67.1L309.5 320h-171L173 263.9c12.4-20.2 19-43.4 19-67.1z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faFlask = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(vA);
var bA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "key",
        r = 512,
        i = 512,
        s = [128273],
        o = "f084",
        a = "M336 352c97.2 0 176-78.8 176-176S433.2 0 336 0S160 78.8 160 176c0 18.7 2.9 36.8 8.3 53.7L7 391c-4.5 4.5-7 10.6-7 17v80c0 13.3 10.7 24 24 24h80c13.3 0 24-10.7 24-24V448h40c13.3 0 24-10.7 24-24V384h40c6.4 0 12.5-2.5 17-7l33.3-33.3c16.9 5.4 35 8.3 53.7 8.3zM376 96a40 40 0 1 1 0 80 40 40 0 1 1 0-80z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faKey = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(bA);
var wA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "satellite-dish",
        r = 512,
        i = 512,
        s = [128225],
        o = "f7c0",
        a = "M192 32c0-17.7 14.3-32 32-32C383.1 0 512 128.9 512 288c0 17.7-14.3 32-32 32s-32-14.3-32-32C448 164.3 347.7 64 224 64c-17.7 0-32-14.3-32-32zM60.6 220.6L164.7 324.7l28.4-28.4c-.7-2.6-1.1-5.4-1.1-8.3c0-17.7 14.3-32 32-32s32 14.3 32 32s-14.3 32-32 32c-2.9 0-5.6-.4-8.3-1.1l-28.4 28.4L291.4 451.4c14.5 14.5 11.8 38.8-7.3 46.3C260.5 506.9 234.9 512 208 512C93.1 512 0 418.9 0 304c0-26.9 5.1-52.5 14.4-76.1c7.5-19 31.8-21.8 46.3-7.3zM224 96c106 0 192 86 192 192c0 17.7-14.3 32-32 32s-32-14.3-32-32c0-70.7-57.3-128-128-128c-17.7 0-32-14.3-32-32s14.3-32 32-32z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faSatelliteDish = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(wA);
var xA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "coins",
        r = 512,
        i = 512,
        s = [],
        o = "f51e",
        a = "M512 80c0 18-14.3 34.6-38.4 48c-29.1 16.1-72.5 27.5-122.3 30.9c-3.7-1.8-7.4-3.5-11.3-5C300.6 137.4 248.2 128 192 128c-8.3 0-16.4 .2-24.5 .6l-1.1-.6C142.3 114.6 128 98 128 80c0-44.2 86-80 192-80S512 35.8 512 80zM160.7 161.1c10.2-.7 20.7-1.1 31.3-1.1c62.2 0 117.4 12.3 152.5 31.4C369.3 204.9 384 221.7 384 240c0 4-.7 7.9-2.1 11.7c-4.6 13.2-17 25.3-35 35.5c0 0 0 0 0 0c-.1 .1-.3 .1-.4 .2l0 0 0 0c-.3 .2-.6 .3-.9 .5c-35 19.4-90.8 32-153.6 32c-59.6 0-112.9-11.3-148.2-29.1c-1.9-.9-3.7-1.9-5.5-2.9C14.3 274.6 0 258 0 240c0-34.8 53.4-64.5 128-75.4c10.5-1.5 21.4-2.7 32.7-3.5zM416 240c0-21.9-10.6-39.9-24.1-53.4c28.3-4.4 54.2-11.4 76.2-20.5c16.3-6.8 31.5-15.2 43.9-25.5V176c0 19.3-16.5 37.1-43.8 50.9c-14.6 7.4-32.4 13.7-52.4 18.5c.1-1.8 .2-3.5 .2-5.3zm-32 96c0 18-14.3 34.6-38.4 48c-1.8 1-3.6 1.9-5.5 2.9C304.9 404.7 251.6 416 192 416c-62.8 0-118.6-12.6-153.6-32C14.3 370.6 0 354 0 336V300.6c12.5 10.3 27.6 18.7 43.9 25.5C83.4 342.6 135.8 352 192 352s108.6-9.4 148.1-25.9c7.8-3.2 15.3-6.9 22.4-10.9c6.1-3.4 11.8-7.2 17.2-11.2c1.5-1.1 2.9-2.3 4.3-3.4V304v5.7V336zm32 0V304 278.1c19-4.2 36.5-9.5 52.1-16c16.3-6.8 31.5-15.2 43.9-25.5V272c0 10.5-5 21-14.9 30.9c-16.3 16.3-45 29.7-81.3 38.4c.1-1.7 .2-3.5 .2-5.3zM192 448c56.2 0 108.6-9.4 148.1-25.9c16.3-6.8 31.5-15.2 43.9-25.5V432c0 44.2-86 80-192 80S0 476.2 0 432V396.6c12.5 10.3 27.6 18.7 43.9 25.5C83.4 438.6 135.8 448 192 448z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faCoins = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(xA);
var AA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "house-laptop",
        r = 640,
        i = 512,
        s = ["laptop-house"],
        o = "e066",
        a = "M218.3 8.5c12.3-11.3 31.2-11.3 43.4 0l208 192c6.7 6.2 10.3 14.8 10.3 23.5H336c-19.1 0-36.3 8.4-48 21.7V208c0-8.8-7.2-16-16-16H208c-8.8 0-16 7.2-16 16v64c0 8.8 7.2 16 16 16h64V416H112c-26.5 0-48-21.5-48-48V256H32c-13.2 0-25-8.1-29.8-20.3s-1.6-26.2 8.1-35.2l208-192zM352 304V448H544V304H352zm-48-16c0-17.7 14.3-32 32-32H560c17.7 0 32 14.3 32 32V448h32c8.8 0 16 7.2 16 16c0 26.5-21.5 48-48 48H544 352 304c-26.5 0-48-21.5-48-48c0-8.8 7.2-16 16-16h32V288z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faHouseLaptop = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(AA);
var kA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "laptop-code",
        r = 640,
        i = 512,
        s = [],
        o = "f5fc",
        a = "M64 96c0-35.3 28.7-64 64-64H512c35.3 0 64 28.7 64 64V352H512V96H128V352H64V96zM0 403.2C0 392.6 8.6 384 19.2 384H620.8c10.6 0 19.2 8.6 19.2 19.2c0 42.4-34.4 76.8-76.8 76.8H76.8C34.4 480 0 445.6 0 403.2zM281 209l-31 31 31 31c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-48-48c-9.4-9.4-9.4-24.6 0-33.9l48-48c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9zM393 175l48 48c9.4 9.4 9.4 24.6 0 33.9l-48 48c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l31-31-31-31c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faLaptopCode = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(kA);
var _A = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "hand-holding-dollar",
        r = 576,
        i = 512,
        s = ["hand-holding-usd"],
        o = "f4c0",
        a = "M312 24V34.5c6.4 1.2 12.6 2.7 18.2 4.2c12.8 3.4 20.4 16.6 17 29.4s-16.6 20.4-29.4 17c-10.9-2.9-21.1-4.9-30.2-5c-7.3-.1-14.7 1.7-19.4 4.4c-2.1 1.3-3.1 2.4-3.5 3c-.3 .5-.7 1.2-.7 2.8c0 .3 0 .5 0 .6c.2 .2 .9 1.2 3.3 2.6c5.8 3.5 14.4 6.2 27.4 10.1l.9 .3c11.1 3.3 25.9 7.8 37.9 15.3c13.7 8.6 26.1 22.9 26.4 44.9c.3 22.5-11.4 38.9-26.7 48.5c-6.7 4.1-13.9 7-21.3 8.8V232c0 13.3-10.7 24-24 24s-24-10.7-24-24V220.6c-9.5-2.3-18.2-5.3-25.6-7.8c-2.1-.7-4.1-1.4-6-2c-12.6-4.2-19.4-17.8-15.2-30.4s17.8-19.4 30.4-15.2c2.6 .9 5 1.7 7.3 2.5c13.6 4.6 23.4 7.9 33.9 8.3c8 .3 15.1-1.6 19.2-4.1c1.9-1.2 2.8-2.2 3.2-2.9c.4-.6 .9-1.8 .8-4.1l0-.2c0-1 0-2.1-4-4.6c-5.7-3.6-14.3-6.4-27.1-10.3l-1.9-.6c-10.8-3.2-25-7.5-36.4-14.4c-13.5-8.1-26.5-22-26.6-44.1c-.1-22.9 12.9-38.6 27.7-47.4c6.4-3.8 13.3-6.4 20.2-8.2V24c0-13.3 10.7-24 24-24s24 10.7 24 24zM568.2 336.3c13.1 17.8 9.3 42.8-8.5 55.9L433.1 485.5c-23.4 17.2-51.6 26.5-80.7 26.5H192 32c-17.7 0-32-14.3-32-32V416c0-17.7 14.3-32 32-32H68.8l44.9-36c22.7-18.2 50.9-28 80-28H272h16 64c17.7 0 32 14.3 32 32s-14.3 32-32 32H288 272c-8.8 0-16 7.2-16 16s7.2 16 16 16H392.6l119.7-88.2c17.8-13.1 42.8-9.3 55.9 8.5zM193.6 384l0 0-.9 0c.3 0 .6 0 .9 0z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faHandHoldingDollar = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(_A);
var EA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "circle-dollar",
        r = 512,
        i = 512,
        s = ["dollar-circle", "usd-circle"],
        o = "f2e8",
        a = "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zm20.8-378.4v14.2c9.7 1.2 19.4 3.9 29 6.6c1.9 .5 3.7 1 5.6 1.6c11.5 3.2 18.3 15.1 15.1 26.6s-15.1 18.2-26.6 15.1c-1.6-.4-3.1-.9-4.7-1.3c-7-2-14-3.9-21.1-5.3c-13.2-2.5-28.5-1.3-40.8 4c-11 4.8-20.1 16.4-7.6 24.4c9.8 6.3 21.8 9.5 33.2 12.6c2.4 .6 4.7 1.3 7 1.9c15.6 4.4 35.5 10.1 50.4 20.3c19.4 13.3 28.5 34.9 24.2 58.1c-4.1 22.4-19.7 37.1-38.4 44.7c-7.8 3.2-16.3 5.2-25.2 6.2l0 15.2c0 11.9-9.7 21.6-21.6 21.6s-21.6-9.7-21.6-21.6l0-17.4c-14.5-3.3-28.7-7.9-42.8-12.5c-11.3-3.7-17.5-16-13.7-27.3s16-17.5 27.3-13.7c2.5 .8 5 1.7 7.5 2.5c11.3 3.8 22.9 7.7 34.5 9.6c17 2.5 30.6 1 39.5-2.6c12-4.8 17.7-19.1 5.9-27.1c-10.1-6.9-22.6-10.3-34.5-13.5c-2.3-.6-4.5-1.2-6.8-1.9c-15.1-4.3-34-9.6-48.2-18.7c-19.5-12.5-29.4-33.3-25.2-56.4c4-21.8 21-36.3 39-44.1c5.5-2.4 11.4-4.3 17.5-5.7V133.6c0-11.9 9.7-21.6 21.6-21.6s21.6 9.7 21.6 21.6z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faCircleDollar = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(EA);
var PA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "chart-pie-simple",
        r = 512,
        i = 512,
        s = ["chart-pie-alt"],
        o = "f64e",
        a = "M495.4 240H272V16.6c0-9 7-16.6 16-16.6C411.7 0 512 100.3 512 224c0 9-7.6 16-16.6 16zM190.2 37.2c18.1-3.8 33.8 11 33.8 29.5V288H445.3c18.5 0 33.3 15.7 29.5 33.8C451.9 430.5 355.5 512 240 512C107.5 512 0 404.6 0 272C0 156.5 81.5 60.1 190.2 37.2z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faChartPieSimple = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(PA);
var SA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fas",
        n = "wrench",
        r = 512,
        i = 512,
        s = [128295],
        o = "f0ad",
        a = "M352 320c88.4 0 160-71.6 160-160c0-15.3-2.2-30.1-6.2-44.2c-3.1-10.8-16.4-13.2-24.3-5.3l-76.8 76.8c-3 3-7.1 4.7-11.3 4.7H336c-8.8 0-16-7.2-16-16V118.6c0-4.2 1.7-8.3 4.7-11.3l76.8-76.8c7.9-7.9 5.4-21.2-5.3-24.3C382.1 2.2 367.3 0 352 0C263.6 0 192 71.6 192 160c0 19.1 3.4 37.5 9.5 54.5L19.9 396.1C7.2 408.8 0 426.1 0 444.1C0 481.6 30.4 512 67.9 512c18 0 35.3-7.2 48-19.9L297.5 310.5c17 6.2 35.4 9.5 54.5 9.5zM80 408a24 24 0 1 1 0 48 24 24 0 1 1 0-48z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faWrench = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(SA);
var NA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fab",
        n = "reddit",
        r = 512,
        i = 512,
        s = [],
        o = "f1a1",
        a = "M201.5 305.5c-13.8 0-24.9-11.1-24.9-24.6 0-13.8 11.1-24.9 24.9-24.9 13.6 0 24.6 11.1 24.6 24.9 0 13.6-11.1 24.6-24.6 24.6zM504 256c0 137-111 248-248 248S8 393 8 256 119 8 256 8s248 111 248 248zm-132.3-41.2c-9.4 0-17.7 3.9-23.8 10-22.4-15.5-52.6-25.5-86.1-26.6l17.4-78.3 55.4 12.5c0 13.6 11.1 24.6 24.6 24.6 13.8 0 24.9-11.3 24.9-24.9s-11.1-24.9-24.9-24.9c-9.7 0-18 5.8-22.1 13.8l-61.2-13.6c-3-.8-6.1 1.4-6.9 4.4l-19.1 86.4c-33.2 1.4-63.1 11.3-85.5 26.8-6.1-6.4-14.7-10.2-24.1-10.2-34.9 0-46.3 46.9-14.4 62.8-1.1 5-1.7 10.2-1.7 15.5 0 52.6 59.2 95.2 132 95.2 73.1 0 132.3-42.6 132.3-95.2 0-5.3-.6-10.8-1.9-15.8 31.3-16 19.8-62.5-14.9-62.5zM302.8 331c-18.2 18.2-76.1 17.9-93.6 0-2.2-2.2-6.1-2.2-8.3 0-2.5 2.5-2.5 6.4 0 8.6 22.8 22.8 87.3 22.8 110.2 0 2.5-2.2 2.5-6.1 0-8.6-2.2-2.2-6.1-2.2-8.3 0zm7.7-75c-13.6 0-24.6 11.1-24.6 24.9 0 13.6 11.1 24.6 24.6 24.6 13.8 0 24.9-11.1 24.9-24.6 0-13.8-11-24.9-24.9-24.9z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faReddit = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(NA);
var RA = {};
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    var e = "fab",
        n = "youtube",
        r = 576,
        i = 512,
        s = [61802],
        o = "f167",
        a = "M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z";
    t.definition = {
        prefix: e,
        iconName: n,
        icon: [r, i, s, o, a]
    }, t.faYoutube = t.definition, t.prefix = e, t.iconName = n, t.width = r, t.height = i, t.ligatures = s, t.unicode = o, t.svgPathData = a, t.aliases = s
})(RA);
nj.add(eA.faEthereum, tA.faUsers, nA.faLock, rA.faNetworkWired, iA.faDollarSign, sA.faFileAlt, aA.faServer, lA.faSitemap, cA.faRocket, uA.faGithub, fA.faDiscourse, dA.faXTwitter, hA.faDiscord, pA.faMedium, mA.faArrowDown, gA.faArrowAltDown, vA.faFlask, bA.faKey, wA.faSatelliteDish, xA.faCoins, AA.faHouseLaptop, kA.faLaptopCode, _A.faHandHoldingDollar, EA.faCircleDollar, PA.faChartPieSimple, SA.faWrench, NA.faReddit, RA.faYoutube);
const gj = W3({
        history: a3(),
        routes: nU
    }),
    CA = bR(),
    Zi = _4(vR);
Zi.config.globalProperties.emitter = CA;
Zi.use(gj);
Zi.use(kH);
Zi.provide("axios", wH);
Zi.provide("emitter", CA);
Zi.component("fa", mj);
Zi.component("vue3-autocounter", AR);
Zi.mount("#app");
xH();